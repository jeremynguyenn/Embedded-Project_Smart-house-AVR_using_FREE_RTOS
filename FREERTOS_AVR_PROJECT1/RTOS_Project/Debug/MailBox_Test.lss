
MailBox_Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003ad6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002e  00800060  00003ad6  00003b6a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000067a  0080008e  0080008e  00003b98  2**0
                  ALLOC
  3 .stab         000066d8  00000000  00000000  00003b98  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003560  00000000  00000000  0000a270  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a0 0c 	jmp	0x1940	; 0x1940 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 ed       	ldi	r30, 0xD6	; 214
      68:	fa e3       	ldi	r31, 0x3A	; 58
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 38       	cpi	r26, 0x8E	; 142
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ae e8       	ldi	r26, 0x8E	; 142
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 30       	cpi	r26, 0x08	; 8
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <main>
      8a:	0c 94 69 1d 	jmp	0x3ad2	; 0x3ad2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	0f 92       	push	r0
      a6:	cd b7       	in	r28, 0x3d	; 61
      a8:	de b7       	in	r29, 0x3e	; 62
      aa:	89 83       	std	Y+1, r24	; 0x01
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
      ac:	8a e0       	ldi	r24, 0x0A	; 10
      ae:	62 e0       	ldi	r22, 0x02	; 2
      b0:	40 e0       	ldi	r20, 0x00	; 0
      b2:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <xQueueGenericCreate>
      b6:	90 93 91 00 	sts	0x0091, r25
      ba:	80 93 90 00 	sts	0x0090, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
      be:	8d ec       	ldi	r24, 0xCD	; 205
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	20 e6       	ldi	r18, 0x60	; 96
      c4:	30 e0       	ldi	r19, 0x00	; 0
      c6:	e0 e9       	ldi	r30, 0x90	; 144
      c8:	f0 e0       	ldi	r31, 0x00	; 0
      ca:	b9 01       	movw	r22, r18
      cc:	45 e5       	ldi	r20, 0x55	; 85
      ce:	50 e0       	ldi	r21, 0x00	; 0
      d0:	9f 01       	movw	r18, r30
      d2:	09 81       	ldd	r16, Y+1	; 0x01
      d4:	ee 24       	eor	r14, r14
      d6:	ff 24       	eor	r15, r15
      d8:	cc 24       	eor	r12, r12
      da:	dd 24       	eor	r13, r13
      dc:	aa 24       	eor	r10, r10
      de:	bb 24       	eor	r11, r11
      e0:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
      e4:	80 e9       	ldi	r24, 0x90	; 144
      e6:	90 e0       	ldi	r25, 0x00	; 0
      e8:	28 e6       	ldi	r18, 0x68	; 104
      ea:	30 e0       	ldi	r19, 0x00	; 0
      ec:	e0 e9       	ldi	r30, 0x90	; 144
      ee:	f0 e0       	ldi	r31, 0x00	; 0
      f0:	b9 01       	movw	r22, r18
      f2:	45 e5       	ldi	r20, 0x55	; 85
      f4:	50 e0       	ldi	r21, 0x00	; 0
      f6:	9f 01       	movw	r18, r30
      f8:	09 81       	ldd	r16, Y+1	; 0x01
      fa:	ee 24       	eor	r14, r14
      fc:	ff 24       	eor	r15, r15
      fe:	cc 24       	eor	r12, r12
     100:	dd 24       	eor	r13, r13
     102:	aa 24       	eor	r10, r10
     104:	bb 24       	eor	r11, r11
     106:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <xTaskGenericCreate>
}
     10a:	0f 90       	pop	r0
     10c:	cf 91       	pop	r28
     10e:	df 91       	pop	r29
     110:	0f 91       	pop	r16
     112:	ff 90       	pop	r15
     114:	ef 90       	pop	r14
     116:	df 90       	pop	r13
     118:	cf 90       	pop	r12
     11a:	bf 90       	pop	r11
     11c:	af 90       	pop	r10
     11e:	08 95       	ret

00000120 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     120:	df 93       	push	r29
     122:	cf 93       	push	r28
     124:	00 d0       	rcall	.+0      	; 0x126 <vPolledQueueProducer+0x6>
     126:	00 d0       	rcall	.+0      	; 0x128 <vPolledQueueProducer+0x8>
     128:	00 d0       	rcall	.+0      	; 0x12a <vPolledQueueProducer+0xa>
     12a:	cd b7       	in	r28, 0x3d	; 61
     12c:	de b7       	in	r29, 0x3e	; 62
     12e:	9e 83       	std	Y+6, r25	; 0x06
     130:	8d 83       	std	Y+5, r24	; 0x05
uint16_t usValue = ( uint16_t ) 0;
     132:	1c 82       	std	Y+4, r1	; 0x04
     134:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xError = pdFALSE, xLoop;
     136:	1a 82       	std	Y+2, r1	; 0x02

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     138:	19 82       	std	Y+1, r1	; 0x01
     13a:	27 c0       	rjmp	.+78     	; 0x18a <vPolledQueueProducer+0x6a>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     13c:	ed 81       	ldd	r30, Y+5	; 0x05
     13e:	fe 81       	ldd	r31, Y+6	; 0x06
     140:	80 81       	ld	r24, Z
     142:	91 81       	ldd	r25, Z+1	; 0x01
     144:	9e 01       	movw	r18, r28
     146:	2d 5f       	subi	r18, 0xFD	; 253
     148:	3f 4f       	sbci	r19, 0xFF	; 255
     14a:	b9 01       	movw	r22, r18
     14c:	40 e0       	ldi	r20, 0x00	; 0
     14e:	50 e0       	ldi	r21, 0x00	; 0
     150:	20 e0       	ldi	r18, 0x00	; 0
     152:	0e 94 a6 0d 	call	0x1b4c	; 0x1b4c <xQueueGenericSend>
     156:	81 30       	cpi	r24, 0x01	; 1
     158:	19 f0       	breq	.+6      	; 0x160 <vPolledQueueProducer+0x40>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     15a:	81 e0       	ldi	r24, 0x01	; 1
     15c:	8a 83       	std	Y+2, r24	; 0x02
     15e:	12 c0       	rjmp	.+36     	; 0x184 <vPolledQueueProducer+0x64>
			}
			else
			{
				if( xError == pdFALSE )
     160:	8a 81       	ldd	r24, Y+2	; 0x02
     162:	88 23       	and	r24, r24
     164:	51 f4       	brne	.+20     	; 0x17a <vPolledQueueProducer+0x5a>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     166:	0f b6       	in	r0, 0x3f	; 63
     168:	f8 94       	cli
     16a:	0f 92       	push	r0
						xPollingProducerCount++;
     16c:	80 91 8f 00 	lds	r24, 0x008F
     170:	8f 5f       	subi	r24, 0xFF	; 255
     172:	80 93 8f 00 	sts	0x008F, r24
					portEXIT_CRITICAL();
     176:	0f 90       	pop	r0
     178:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     17a:	8b 81       	ldd	r24, Y+3	; 0x03
     17c:	9c 81       	ldd	r25, Y+4	; 0x04
     17e:	01 96       	adiw	r24, 0x01	; 1
     180:	9c 83       	std	Y+4, r25	; 0x04
     182:	8b 83       	std	Y+3, r24	; 0x03
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     184:	89 81       	ldd	r24, Y+1	; 0x01
     186:	8f 5f       	subi	r24, 0xFF	; 255
     188:	89 83       	std	Y+1, r24	; 0x01
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	83 30       	cpi	r24, 0x03	; 3
     18e:	b4 f2       	brlt	.-84     	; 0x13c <vPolledQueueProducer+0x1c>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     190:	88 ec       	ldi	r24, 0xC8	; 200
     192:	90 e0       	ldi	r25, 0x00	; 0
     194:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <vTaskDelay>
     198:	cf cf       	rjmp	.-98     	; 0x138 <vPolledQueueProducer+0x18>

0000019a <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     19a:	df 93       	push	r29
     19c:	cf 93       	push	r28
     19e:	cd b7       	in	r28, 0x3d	; 61
     1a0:	de b7       	in	r29, 0x3e	; 62
     1a2:	27 97       	sbiw	r28, 0x07	; 7
     1a4:	0f b6       	in	r0, 0x3f	; 63
     1a6:	f8 94       	cli
     1a8:	de bf       	out	0x3e, r29	; 62
     1aa:	0f be       	out	0x3f, r0	; 63
     1ac:	cd bf       	out	0x3d, r28	; 61
     1ae:	9f 83       	std	Y+7, r25	; 0x07
     1b0:	8e 83       	std	Y+6, r24	; 0x06
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     1b2:	1b 82       	std	Y+3, r1	; 0x03
     1b4:	1a 82       	std	Y+2, r1	; 0x02
BaseType_t xError = pdFALSE;
     1b6:	19 82       	std	Y+1, r1	; 0x01
     1b8:	2f c0       	rjmp	.+94     	; 0x218 <vPolledQueueConsumer+0x7e>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     1ba:	ee 81       	ldd	r30, Y+6	; 0x06
     1bc:	ff 81       	ldd	r31, Y+7	; 0x07
     1be:	80 81       	ld	r24, Z
     1c0:	91 81       	ldd	r25, Z+1	; 0x01
     1c2:	9e 01       	movw	r18, r28
     1c4:	2c 5f       	subi	r18, 0xFC	; 252
     1c6:	3f 4f       	sbci	r19, 0xFF	; 255
     1c8:	b9 01       	movw	r22, r18
     1ca:	40 e0       	ldi	r20, 0x00	; 0
     1cc:	50 e0       	ldi	r21, 0x00	; 0
     1ce:	20 e0       	ldi	r18, 0x00	; 0
     1d0:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xQueueGenericReceive>
     1d4:	81 30       	cpi	r24, 0x01	; 1
     1d6:	01 f5       	brne	.+64     	; 0x218 <vPolledQueueConsumer+0x7e>
			{
				if( usData != usExpectedValue )
     1d8:	2c 81       	ldd	r18, Y+4	; 0x04
     1da:	3d 81       	ldd	r19, Y+5	; 0x05
     1dc:	8a 81       	ldd	r24, Y+2	; 0x02
     1de:	9b 81       	ldd	r25, Y+3	; 0x03
     1e0:	28 17       	cp	r18, r24
     1e2:	39 07       	cpc	r19, r25
     1e4:	39 f0       	breq	.+14     	; 0x1f4 <vPolledQueueConsumer+0x5a>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     1e6:	81 e0       	ldi	r24, 0x01	; 1
     1e8:	89 83       	std	Y+1, r24	; 0x01

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
     1ea:	8c 81       	ldd	r24, Y+4	; 0x04
     1ec:	9d 81       	ldd	r25, Y+5	; 0x05
     1ee:	9b 83       	std	Y+3, r25	; 0x03
     1f0:	8a 83       	std	Y+2, r24	; 0x02
     1f2:	0d c0       	rjmp	.+26     	; 0x20e <vPolledQueueConsumer+0x74>
				}
				else
				{
					if( xError == pdFALSE )
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	88 23       	and	r24, r24
     1f8:	51 f4       	brne	.+20     	; 0x20e <vPolledQueueConsumer+0x74>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     1fa:	0f b6       	in	r0, 0x3f	; 63
     1fc:	f8 94       	cli
     1fe:	0f 92       	push	r0
							xPollingConsumerCount++;
     200:	80 91 8e 00 	lds	r24, 0x008E
     204:	8f 5f       	subi	r24, 0xFF	; 255
     206:	80 93 8e 00 	sts	0x008E, r24
						portEXIT_CRITICAL();
     20a:	0f 90       	pop	r0
     20c:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	01 96       	adiw	r24, 0x01	; 1
     214:	9b 83       	std	Y+3, r25	; 0x03
     216:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     218:	ee 81       	ldd	r30, Y+6	; 0x06
     21a:	ff 81       	ldd	r31, Y+7	; 0x07
     21c:	80 81       	ld	r24, Z
     21e:	91 81       	ldd	r25, Z+1	; 0x01
     220:	0e 94 08 10 	call	0x2010	; 0x2010 <uxQueueMessagesWaiting>
     224:	88 23       	and	r24, r24
     226:	49 f6       	brne	.-110    	; 0x1ba <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     228:	84 eb       	ldi	r24, 0xB4	; 180
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <vTaskDelay>
     230:	f3 cf       	rjmp	.-26     	; 0x218 <vPolledQueueConsumer+0x7e>

00000232 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
     232:	df 93       	push	r29
     234:	cf 93       	push	r28
     236:	0f 92       	push	r0
     238:	cd b7       	in	r28, 0x3d	; 61
     23a:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
     23c:	80 91 8e 00 	lds	r24, 0x008E
     240:	88 23       	and	r24, r24
     242:	21 f0       	breq	.+8      	; 0x24c <xArePollingQueuesStillRunning+0x1a>
     244:	80 91 8f 00 	lds	r24, 0x008F
     248:	88 23       	and	r24, r24
     24a:	11 f4       	brne	.+4      	; 0x250 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
     24c:	19 82       	std	Y+1, r1	; 0x01
     24e:	02 c0       	rjmp	.+4      	; 0x254 <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
     254:	10 92 8e 00 	sts	0x008E, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
     258:	10 92 8f 00 	sts	0x008F, r1

	return xReturn;
     25c:	89 81       	ldd	r24, Y+1	; 0x01
}
     25e:	0f 90       	pop	r0
     260:	cf 91       	pop	r28
     262:	df 91       	pop	r29
     264:	08 95       	ret

00000266 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     266:	df 93       	push	r29
     268:	cf 93       	push	r28
     26a:	cd b7       	in	r28, 0x3d	; 61
     26c:	de b7       	in	r29, 0x3e	; 62
     26e:	27 97       	sbiw	r28, 0x07	; 7
     270:	0f b6       	in	r0, 0x3f	; 63
     272:	f8 94       	cli
     274:	de bf       	out	0x3e, r29	; 62
     276:	0f be       	out	0x3f, r0	; 63
     278:	cd bf       	out	0x3d, r28	; 61
     27a:	9d 83       	std	Y+5, r25	; 0x05
     27c:	8c 83       	std	Y+4, r24	; 0x04
     27e:	6e 83       	std	Y+6, r22	; 0x06
     280:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     282:	8a e1       	ldi	r24, 0x1A	; 26
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
     28a:	9a 83       	std	Y+2, r25	; 0x02
     28c:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     28e:	89 81       	ldd	r24, Y+1	; 0x01
     290:	9a 81       	ldd	r25, Y+2	; 0x02
     292:	00 97       	sbiw	r24, 0x00	; 0
     294:	09 f4       	brne	.+2      	; 0x298 <xCoRoutineCreate+0x32>
     296:	6f c0       	rjmp	.+222    	; 0x376 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     298:	80 91 92 00 	lds	r24, 0x0092
     29c:	90 91 93 00 	lds	r25, 0x0093
     2a0:	00 97       	sbiw	r24, 0x00	; 0
     2a2:	41 f4       	brne	.+16     	; 0x2b4 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     2a4:	89 81       	ldd	r24, Y+1	; 0x01
     2a6:	9a 81       	ldd	r25, Y+2	; 0x02
     2a8:	90 93 93 00 	sts	0x0093, r25
     2ac:	80 93 92 00 	sts	0x0092, r24
			prvInitialiseCoRoutineLists();
     2b0:	0e 94 9a 03 	call	0x734	; 0x734 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     2b4:	8e 81       	ldd	r24, Y+6	; 0x06
     2b6:	82 30       	cpi	r24, 0x02	; 2
     2b8:	10 f0       	brcs	.+4      	; 0x2be <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     2ba:	81 e0       	ldi	r24, 0x01	; 1
     2bc:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     2be:	e9 81       	ldd	r30, Y+1	; 0x01
     2c0:	fa 81       	ldd	r31, Y+2	; 0x02
     2c2:	11 8e       	std	Z+25, r1	; 0x19
     2c4:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     2c6:	e9 81       	ldd	r30, Y+1	; 0x01
     2c8:	fa 81       	ldd	r31, Y+2	; 0x02
     2ca:	8e 81       	ldd	r24, Y+6	; 0x06
     2cc:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     2ce:	e9 81       	ldd	r30, Y+1	; 0x01
     2d0:	fa 81       	ldd	r31, Y+2	; 0x02
     2d2:	8f 81       	ldd	r24, Y+7	; 0x07
     2d4:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     2d6:	e9 81       	ldd	r30, Y+1	; 0x01
     2d8:	fa 81       	ldd	r31, Y+2	; 0x02
     2da:	8c 81       	ldd	r24, Y+4	; 0x04
     2dc:	9d 81       	ldd	r25, Y+5	; 0x05
     2de:	91 83       	std	Z+1, r25	; 0x01
     2e0:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	9a 81       	ldd	r25, Y+2	; 0x02
     2e6:	02 96       	adiw	r24, 0x02	; 2
     2e8:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	0c 96       	adiw	r24, 0x0c	; 12
     2f2:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     2f6:	e9 81       	ldd	r30, Y+1	; 0x01
     2f8:	fa 81       	ldd	r31, Y+2	; 0x02
     2fa:	89 81       	ldd	r24, Y+1	; 0x01
     2fc:	9a 81       	ldd	r25, Y+2	; 0x02
     2fe:	91 87       	std	Z+9, r25	; 0x09
     300:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     302:	e9 81       	ldd	r30, Y+1	; 0x01
     304:	fa 81       	ldd	r31, Y+2	; 0x02
     306:	89 81       	ldd	r24, Y+1	; 0x01
     308:	9a 81       	ldd	r25, Y+2	; 0x02
     30a:	93 8b       	std	Z+19, r25	; 0x13
     30c:	82 8b       	std	Z+18, r24	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     30e:	8e 81       	ldd	r24, Y+6	; 0x06
     310:	28 2f       	mov	r18, r24
     312:	30 e0       	ldi	r19, 0x00	; 0
     314:	82 e0       	ldi	r24, 0x02	; 2
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	82 1b       	sub	r24, r18
     31a:	93 0b       	sbc	r25, r19
     31c:	e9 81       	ldd	r30, Y+1	; 0x01
     31e:	fa 81       	ldd	r31, Y+2	; 0x02
     320:	95 87       	std	Z+13, r25	; 0x0d
     322:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     324:	e9 81       	ldd	r30, Y+1	; 0x01
     326:	fa 81       	ldd	r31, Y+2	; 0x02
     328:	96 89       	ldd	r25, Z+22	; 0x16
     32a:	80 91 94 00 	lds	r24, 0x0094
     32e:	89 17       	cp	r24, r25
     330:	28 f4       	brcc	.+10     	; 0x33c <xCoRoutineCreate+0xd6>
     332:	e9 81       	ldd	r30, Y+1	; 0x01
     334:	fa 81       	ldd	r31, Y+2	; 0x02
     336:	86 89       	ldd	r24, Z+22	; 0x16
     338:	80 93 94 00 	sts	0x0094, r24
     33c:	e9 81       	ldd	r30, Y+1	; 0x01
     33e:	fa 81       	ldd	r31, Y+2	; 0x02
     340:	86 89       	ldd	r24, Z+22	; 0x16
     342:	28 2f       	mov	r18, r24
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	c9 01       	movw	r24, r18
     348:	88 0f       	add	r24, r24
     34a:	99 1f       	adc	r25, r25
     34c:	88 0f       	add	r24, r24
     34e:	99 1f       	adc	r25, r25
     350:	88 0f       	add	r24, r24
     352:	99 1f       	adc	r25, r25
     354:	82 0f       	add	r24, r18
     356:	93 1f       	adc	r25, r19
     358:	ac 01       	movw	r20, r24
     35a:	45 56       	subi	r20, 0x65	; 101
     35c:	5f 4f       	sbci	r21, 0xFF	; 255
     35e:	89 81       	ldd	r24, Y+1	; 0x01
     360:	9a 81       	ldd	r25, Y+2	; 0x02
     362:	9c 01       	movw	r18, r24
     364:	2e 5f       	subi	r18, 0xFE	; 254
     366:	3f 4f       	sbci	r19, 0xFF	; 255
     368:	ca 01       	movw	r24, r20
     36a:	b9 01       	movw	r22, r18
     36c:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

		xReturn = pdPASS;
     370:	81 e0       	ldi	r24, 0x01	; 1
     372:	8b 83       	std	Y+3, r24	; 0x03
     374:	02 c0       	rjmp	.+4      	; 0x37a <xCoRoutineCreate+0x114>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     376:	8f ef       	ldi	r24, 0xFF	; 255
     378:	8b 83       	std	Y+3, r24	; 0x03
	}

	return xReturn;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
}
     37c:	27 96       	adiw	r28, 0x07	; 7
     37e:	0f b6       	in	r0, 0x3f	; 63
     380:	f8 94       	cli
     382:	de bf       	out	0x3e, r29	; 62
     384:	0f be       	out	0x3f, r0	; 63
     386:	cd bf       	out	0x3d, r28	; 61
     388:	cf 91       	pop	r28
     38a:	df 91       	pop	r29
     38c:	08 95       	ret

0000038e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     38e:	df 93       	push	r29
     390:	cf 93       	push	r28
     392:	00 d0       	rcall	.+0      	; 0x394 <vCoRoutineAddToDelayedList+0x6>
     394:	00 d0       	rcall	.+0      	; 0x396 <vCoRoutineAddToDelayedList+0x8>
     396:	00 d0       	rcall	.+0      	; 0x398 <vCoRoutineAddToDelayedList+0xa>
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
     39c:	9c 83       	std	Y+4, r25	; 0x04
     39e:	8b 83       	std	Y+3, r24	; 0x03
     3a0:	7e 83       	std	Y+6, r23	; 0x06
     3a2:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     3a4:	20 91 95 00 	lds	r18, 0x0095
     3a8:	30 91 96 00 	lds	r19, 0x0096
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	82 0f       	add	r24, r18
     3b2:	93 1f       	adc	r25, r19
     3b4:	9a 83       	std	Y+2, r25	; 0x02
     3b6:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3b8:	80 91 92 00 	lds	r24, 0x0092
     3bc:	90 91 93 00 	lds	r25, 0x0093
     3c0:	02 96       	adiw	r24, 0x02	; 2
     3c2:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     3c6:	e0 91 92 00 	lds	r30, 0x0092
     3ca:	f0 91 93 00 	lds	r31, 0x0093
     3ce:	89 81       	ldd	r24, Y+1	; 0x01
     3d0:	9a 81       	ldd	r25, Y+2	; 0x02
     3d2:	93 83       	std	Z+3, r25	; 0x03
     3d4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     3d6:	20 91 95 00 	lds	r18, 0x0095
     3da:	30 91 96 00 	lds	r19, 0x0096
     3de:	89 81       	ldd	r24, Y+1	; 0x01
     3e0:	9a 81       	ldd	r25, Y+2	; 0x02
     3e2:	82 17       	cp	r24, r18
     3e4:	93 07       	cpc	r25, r19
     3e6:	70 f4       	brcc	.+28     	; 0x404 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3e8:	80 91 c1 00 	lds	r24, 0x00C1
     3ec:	90 91 c2 00 	lds	r25, 0x00C2
     3f0:	20 91 92 00 	lds	r18, 0x0092
     3f4:	30 91 93 00 	lds	r19, 0x0093
     3f8:	2e 5f       	subi	r18, 0xFE	; 254
     3fa:	3f 4f       	sbci	r19, 0xFF	; 255
     3fc:	b9 01       	movw	r22, r18
     3fe:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>
     402:	0d c0       	rjmp	.+26     	; 0x41e <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     404:	80 91 bf 00 	lds	r24, 0x00BF
     408:	90 91 c0 00 	lds	r25, 0x00C0
     40c:	20 91 92 00 	lds	r18, 0x0092
     410:	30 91 93 00 	lds	r19, 0x0093
     414:	2e 5f       	subi	r18, 0xFE	; 254
     416:	3f 4f       	sbci	r19, 0xFF	; 255
     418:	b9 01       	movw	r22, r18
     41a:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>
	}

	if( pxEventList )
     41e:	8d 81       	ldd	r24, Y+5	; 0x05
     420:	9e 81       	ldd	r25, Y+6	; 0x06
     422:	00 97       	sbiw	r24, 0x00	; 0
     424:	61 f0       	breq	.+24     	; 0x43e <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     426:	80 91 92 00 	lds	r24, 0x0092
     42a:	90 91 93 00 	lds	r25, 0x0093
     42e:	9c 01       	movw	r18, r24
     430:	24 5f       	subi	r18, 0xF4	; 244
     432:	3f 4f       	sbci	r19, 0xFF	; 255
     434:	8d 81       	ldd	r24, Y+5	; 0x05
     436:	9e 81       	ldd	r25, Y+6	; 0x06
     438:	b9 01       	movw	r22, r18
     43a:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>
	}
}
     43e:	26 96       	adiw	r28, 0x06	; 6
     440:	0f b6       	in	r0, 0x3f	; 63
     442:	f8 94       	cli
     444:	de bf       	out	0x3e, r29	; 62
     446:	0f be       	out	0x3f, r0	; 63
     448:	cd bf       	out	0x3d, r28	; 61
     44a:	cf 91       	pop	r28
     44c:	df 91       	pop	r29
     44e:	08 95       	ret

00000450 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     450:	df 93       	push	r29
     452:	cf 93       	push	r28
     454:	00 d0       	rcall	.+0      	; 0x456 <prvCheckPendingReadyList+0x6>
     456:	cd b7       	in	r28, 0x3d	; 61
     458:	de b7       	in	r29, 0x3e	; 62
     45a:	3a c0       	rjmp	.+116    	; 0x4d0 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     45c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     45e:	e0 91 c8 00 	lds	r30, 0x00C8
     462:	f0 91 c9 00 	lds	r31, 0x00C9
     466:	86 81       	ldd	r24, Z+6	; 0x06
     468:	97 81       	ldd	r25, Z+7	; 0x07
     46a:	9a 83       	std	Y+2, r25	; 0x02
     46c:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     46e:	89 81       	ldd	r24, Y+1	; 0x01
     470:	9a 81       	ldd	r25, Y+2	; 0x02
     472:	0c 96       	adiw	r24, 0x0c	; 12
     474:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     478:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     47a:	89 81       	ldd	r24, Y+1	; 0x01
     47c:	9a 81       	ldd	r25, Y+2	; 0x02
     47e:	02 96       	adiw	r24, 0x02	; 2
     480:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     484:	e9 81       	ldd	r30, Y+1	; 0x01
     486:	fa 81       	ldd	r31, Y+2	; 0x02
     488:	96 89       	ldd	r25, Z+22	; 0x16
     48a:	80 91 94 00 	lds	r24, 0x0094
     48e:	89 17       	cp	r24, r25
     490:	28 f4       	brcc	.+10     	; 0x49c <prvCheckPendingReadyList+0x4c>
     492:	e9 81       	ldd	r30, Y+1	; 0x01
     494:	fa 81       	ldd	r31, Y+2	; 0x02
     496:	86 89       	ldd	r24, Z+22	; 0x16
     498:	80 93 94 00 	sts	0x0094, r24
     49c:	e9 81       	ldd	r30, Y+1	; 0x01
     49e:	fa 81       	ldd	r31, Y+2	; 0x02
     4a0:	86 89       	ldd	r24, Z+22	; 0x16
     4a2:	28 2f       	mov	r18, r24
     4a4:	30 e0       	ldi	r19, 0x00	; 0
     4a6:	c9 01       	movw	r24, r18
     4a8:	88 0f       	add	r24, r24
     4aa:	99 1f       	adc	r25, r25
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	88 0f       	add	r24, r24
     4b2:	99 1f       	adc	r25, r25
     4b4:	82 0f       	add	r24, r18
     4b6:	93 1f       	adc	r25, r19
     4b8:	ac 01       	movw	r20, r24
     4ba:	45 56       	subi	r20, 0x65	; 101
     4bc:	5f 4f       	sbci	r21, 0xFF	; 255
     4be:	89 81       	ldd	r24, Y+1	; 0x01
     4c0:	9a 81       	ldd	r25, Y+2	; 0x02
     4c2:	9c 01       	movw	r18, r24
     4c4:	2e 5f       	subi	r18, 0xFE	; 254
     4c6:	3f 4f       	sbci	r19, 0xFF	; 255
     4c8:	ca 01       	movw	r24, r20
     4ca:	b9 01       	movw	r22, r18
     4cc:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     4d0:	80 91 c3 00 	lds	r24, 0x00C3
     4d4:	88 23       	and	r24, r24
     4d6:	09 f0       	breq	.+2      	; 0x4da <prvCheckPendingReadyList+0x8a>
     4d8:	c1 cf       	rjmp	.-126    	; 0x45c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     4da:	0f 90       	pop	r0
     4dc:	0f 90       	pop	r0
     4de:	cf 91       	pop	r28
     4e0:	df 91       	pop	r29
     4e2:	08 95       	ret

000004e4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     4e4:	df 93       	push	r29
     4e6:	cf 93       	push	r28
     4e8:	00 d0       	rcall	.+0      	; 0x4ea <prvCheckDelayedList+0x6>
     4ea:	00 d0       	rcall	.+0      	; 0x4ec <prvCheckDelayedList+0x8>
     4ec:	cd b7       	in	r28, 0x3d	; 61
     4ee:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     4f0:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <xTaskGetTickCount>
     4f4:	20 91 97 00 	lds	r18, 0x0097
     4f8:	30 91 98 00 	lds	r19, 0x0098
     4fc:	82 1b       	sub	r24, r18
     4fe:	93 0b       	sbc	r25, r19
     500:	90 93 9a 00 	sts	0x009A, r25
     504:	80 93 99 00 	sts	0x0099, r24
     508:	85 c0       	rjmp	.+266    	; 0x614 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     50a:	80 91 95 00 	lds	r24, 0x0095
     50e:	90 91 96 00 	lds	r25, 0x0096
     512:	01 96       	adiw	r24, 0x01	; 1
     514:	90 93 96 00 	sts	0x0096, r25
     518:	80 93 95 00 	sts	0x0095, r24
		xPassedTicks--;
     51c:	80 91 99 00 	lds	r24, 0x0099
     520:	90 91 9a 00 	lds	r25, 0x009A
     524:	01 97       	sbiw	r24, 0x01	; 1
     526:	90 93 9a 00 	sts	0x009A, r25
     52a:	80 93 99 00 	sts	0x0099, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     52e:	80 91 95 00 	lds	r24, 0x0095
     532:	90 91 96 00 	lds	r25, 0x0096
     536:	00 97       	sbiw	r24, 0x00	; 0
     538:	09 f0       	breq	.+2      	; 0x53c <prvCheckDelayedList+0x58>
     53a:	64 c0       	rjmp	.+200    	; 0x604 <prvCheckDelayedList+0x120>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     53c:	80 91 bf 00 	lds	r24, 0x00BF
     540:	90 91 c0 00 	lds	r25, 0x00C0
     544:	9a 83       	std	Y+2, r25	; 0x02
     546:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     548:	80 91 c1 00 	lds	r24, 0x00C1
     54c:	90 91 c2 00 	lds	r25, 0x00C2
     550:	90 93 c0 00 	sts	0x00C0, r25
     554:	80 93 bf 00 	sts	0x00BF, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	9a 81       	ldd	r25, Y+2	; 0x02
     55c:	90 93 c2 00 	sts	0x00C2, r25
     560:	80 93 c1 00 	sts	0x00C1, r24
     564:	4f c0       	rjmp	.+158    	; 0x604 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     566:	e0 91 bf 00 	lds	r30, 0x00BF
     56a:	f0 91 c0 00 	lds	r31, 0x00C0
     56e:	05 80       	ldd	r0, Z+5	; 0x05
     570:	f6 81       	ldd	r31, Z+6	; 0x06
     572:	e0 2d       	mov	r30, r0
     574:	86 81       	ldd	r24, Z+6	; 0x06
     576:	97 81       	ldd	r25, Z+7	; 0x07
     578:	9c 83       	std	Y+4, r25	; 0x04
     57a:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     57c:	eb 81       	ldd	r30, Y+3	; 0x03
     57e:	fc 81       	ldd	r31, Y+4	; 0x04
     580:	22 81       	ldd	r18, Z+2	; 0x02
     582:	33 81       	ldd	r19, Z+3	; 0x03
     584:	80 91 95 00 	lds	r24, 0x0095
     588:	90 91 96 00 	lds	r25, 0x0096
     58c:	82 17       	cp	r24, r18
     58e:	93 07       	cpc	r25, r19
     590:	08 f4       	brcc	.+2      	; 0x594 <prvCheckDelayedList+0xb0>
     592:	40 c0       	rjmp	.+128    	; 0x614 <prvCheckDelayedList+0x130>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     594:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	02 96       	adiw	r24, 0x02	; 2
     59c:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     5a0:	eb 81       	ldd	r30, Y+3	; 0x03
     5a2:	fc 81       	ldd	r31, Y+4	; 0x04
     5a4:	84 89       	ldd	r24, Z+20	; 0x14
     5a6:	95 89       	ldd	r25, Z+21	; 0x15
     5a8:	00 97       	sbiw	r24, 0x00	; 0
     5aa:	29 f0       	breq	.+10     	; 0x5b6 <prvCheckDelayedList+0xd2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     5ac:	8b 81       	ldd	r24, Y+3	; 0x03
     5ae:	9c 81       	ldd	r25, Y+4	; 0x04
     5b0:	0c 96       	adiw	r24, 0x0c	; 12
     5b2:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     5b6:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     5b8:	eb 81       	ldd	r30, Y+3	; 0x03
     5ba:	fc 81       	ldd	r31, Y+4	; 0x04
     5bc:	96 89       	ldd	r25, Z+22	; 0x16
     5be:	80 91 94 00 	lds	r24, 0x0094
     5c2:	89 17       	cp	r24, r25
     5c4:	28 f4       	brcc	.+10     	; 0x5d0 <prvCheckDelayedList+0xec>
     5c6:	eb 81       	ldd	r30, Y+3	; 0x03
     5c8:	fc 81       	ldd	r31, Y+4	; 0x04
     5ca:	86 89       	ldd	r24, Z+22	; 0x16
     5cc:	80 93 94 00 	sts	0x0094, r24
     5d0:	eb 81       	ldd	r30, Y+3	; 0x03
     5d2:	fc 81       	ldd	r31, Y+4	; 0x04
     5d4:	86 89       	ldd	r24, Z+22	; 0x16
     5d6:	28 2f       	mov	r18, r24
     5d8:	30 e0       	ldi	r19, 0x00	; 0
     5da:	c9 01       	movw	r24, r18
     5dc:	88 0f       	add	r24, r24
     5de:	99 1f       	adc	r25, r25
     5e0:	88 0f       	add	r24, r24
     5e2:	99 1f       	adc	r25, r25
     5e4:	88 0f       	add	r24, r24
     5e6:	99 1f       	adc	r25, r25
     5e8:	82 0f       	add	r24, r18
     5ea:	93 1f       	adc	r25, r19
     5ec:	ac 01       	movw	r20, r24
     5ee:	45 56       	subi	r20, 0x65	; 101
     5f0:	5f 4f       	sbci	r21, 0xFF	; 255
     5f2:	8b 81       	ldd	r24, Y+3	; 0x03
     5f4:	9c 81       	ldd	r25, Y+4	; 0x04
     5f6:	9c 01       	movw	r18, r24
     5f8:	2e 5f       	subi	r18, 0xFE	; 254
     5fa:	3f 4f       	sbci	r19, 0xFF	; 255
     5fc:	ca 01       	movw	r24, r20
     5fe:	b9 01       	movw	r22, r18
     600:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     604:	e0 91 bf 00 	lds	r30, 0x00BF
     608:	f0 91 c0 00 	lds	r31, 0x00C0
     60c:	80 81       	ld	r24, Z
     60e:	88 23       	and	r24, r24
     610:	09 f0       	breq	.+2      	; 0x614 <prvCheckDelayedList+0x130>
     612:	a9 cf       	rjmp	.-174    	; 0x566 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     614:	80 91 99 00 	lds	r24, 0x0099
     618:	90 91 9a 00 	lds	r25, 0x009A
     61c:	00 97       	sbiw	r24, 0x00	; 0
     61e:	09 f0       	breq	.+2      	; 0x622 <prvCheckDelayedList+0x13e>
     620:	74 cf       	rjmp	.-280    	; 0x50a <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     622:	80 91 95 00 	lds	r24, 0x0095
     626:	90 91 96 00 	lds	r25, 0x0096
     62a:	90 93 98 00 	sts	0x0098, r25
     62e:	80 93 97 00 	sts	0x0097, r24
}
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	0f 90       	pop	r0
     63a:	cf 91       	pop	r28
     63c:	df 91       	pop	r29
     63e:	08 95       	ret

00000640 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     640:	df 93       	push	r29
     642:	cf 93       	push	r28
     644:	00 d0       	rcall	.+0      	; 0x646 <vCoRoutineSchedule+0x6>
     646:	cd b7       	in	r28, 0x3d	; 61
     648:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     64a:	0e 94 28 02 	call	0x450	; 0x450 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     64e:	0e 94 72 02 	call	0x4e4	; 0x4e4 <prvCheckDelayedList>
     652:	0a c0       	rjmp	.+20     	; 0x668 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     654:	80 91 94 00 	lds	r24, 0x0094
     658:	88 23       	and	r24, r24
     65a:	09 f4       	brne	.+2      	; 0x65e <vCoRoutineSchedule+0x1e>
     65c:	66 c0       	rjmp	.+204    	; 0x72a <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     65e:	80 91 94 00 	lds	r24, 0x0094
     662:	81 50       	subi	r24, 0x01	; 1
     664:	80 93 94 00 	sts	0x0094, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     668:	80 91 94 00 	lds	r24, 0x0094
     66c:	28 2f       	mov	r18, r24
     66e:	30 e0       	ldi	r19, 0x00	; 0
     670:	c9 01       	movw	r24, r18
     672:	88 0f       	add	r24, r24
     674:	99 1f       	adc	r25, r25
     676:	88 0f       	add	r24, r24
     678:	99 1f       	adc	r25, r25
     67a:	88 0f       	add	r24, r24
     67c:	99 1f       	adc	r25, r25
     67e:	82 0f       	add	r24, r18
     680:	93 1f       	adc	r25, r19
     682:	fc 01       	movw	r30, r24
     684:	e5 56       	subi	r30, 0x65	; 101
     686:	ff 4f       	sbci	r31, 0xFF	; 255
     688:	80 81       	ld	r24, Z
     68a:	88 23       	and	r24, r24
     68c:	19 f3       	breq	.-58     	; 0x654 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     68e:	80 91 94 00 	lds	r24, 0x0094
     692:	28 2f       	mov	r18, r24
     694:	30 e0       	ldi	r19, 0x00	; 0
     696:	c9 01       	movw	r24, r18
     698:	88 0f       	add	r24, r24
     69a:	99 1f       	adc	r25, r25
     69c:	88 0f       	add	r24, r24
     69e:	99 1f       	adc	r25, r25
     6a0:	88 0f       	add	r24, r24
     6a2:	99 1f       	adc	r25, r25
     6a4:	82 0f       	add	r24, r18
     6a6:	93 1f       	adc	r25, r19
     6a8:	85 56       	subi	r24, 0x65	; 101
     6aa:	9f 4f       	sbci	r25, 0xFF	; 255
     6ac:	9a 83       	std	Y+2, r25	; 0x02
     6ae:	89 83       	std	Y+1, r24	; 0x01
     6b0:	e9 81       	ldd	r30, Y+1	; 0x01
     6b2:	fa 81       	ldd	r31, Y+2	; 0x02
     6b4:	01 80       	ldd	r0, Z+1	; 0x01
     6b6:	f2 81       	ldd	r31, Z+2	; 0x02
     6b8:	e0 2d       	mov	r30, r0
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	93 81       	ldd	r25, Z+3	; 0x03
     6be:	e9 81       	ldd	r30, Y+1	; 0x01
     6c0:	fa 81       	ldd	r31, Y+2	; 0x02
     6c2:	92 83       	std	Z+2, r25	; 0x02
     6c4:	81 83       	std	Z+1, r24	; 0x01
     6c6:	e9 81       	ldd	r30, Y+1	; 0x01
     6c8:	fa 81       	ldd	r31, Y+2	; 0x02
     6ca:	21 81       	ldd	r18, Z+1	; 0x01
     6cc:	32 81       	ldd	r19, Z+2	; 0x02
     6ce:	89 81       	ldd	r24, Y+1	; 0x01
     6d0:	9a 81       	ldd	r25, Y+2	; 0x02
     6d2:	03 96       	adiw	r24, 0x03	; 3
     6d4:	28 17       	cp	r18, r24
     6d6:	39 07       	cpc	r19, r25
     6d8:	59 f4       	brne	.+22     	; 0x6f0 <vCoRoutineSchedule+0xb0>
     6da:	e9 81       	ldd	r30, Y+1	; 0x01
     6dc:	fa 81       	ldd	r31, Y+2	; 0x02
     6de:	01 80       	ldd	r0, Z+1	; 0x01
     6e0:	f2 81       	ldd	r31, Z+2	; 0x02
     6e2:	e0 2d       	mov	r30, r0
     6e4:	82 81       	ldd	r24, Z+2	; 0x02
     6e6:	93 81       	ldd	r25, Z+3	; 0x03
     6e8:	e9 81       	ldd	r30, Y+1	; 0x01
     6ea:	fa 81       	ldd	r31, Y+2	; 0x02
     6ec:	92 83       	std	Z+2, r25	; 0x02
     6ee:	81 83       	std	Z+1, r24	; 0x01
     6f0:	e9 81       	ldd	r30, Y+1	; 0x01
     6f2:	fa 81       	ldd	r31, Y+2	; 0x02
     6f4:	01 80       	ldd	r0, Z+1	; 0x01
     6f6:	f2 81       	ldd	r31, Z+2	; 0x02
     6f8:	e0 2d       	mov	r30, r0
     6fa:	86 81       	ldd	r24, Z+6	; 0x06
     6fc:	97 81       	ldd	r25, Z+7	; 0x07
     6fe:	90 93 93 00 	sts	0x0093, r25
     702:	80 93 92 00 	sts	0x0092, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     706:	e0 91 92 00 	lds	r30, 0x0092
     70a:	f0 91 93 00 	lds	r31, 0x0093
     70e:	40 81       	ld	r20, Z
     710:	51 81       	ldd	r21, Z+1	; 0x01
     712:	80 91 92 00 	lds	r24, 0x0092
     716:	90 91 93 00 	lds	r25, 0x0093
     71a:	e0 91 92 00 	lds	r30, 0x0092
     71e:	f0 91 93 00 	lds	r31, 0x0093
     722:	27 89       	ldd	r18, Z+23	; 0x17
     724:	62 2f       	mov	r22, r18
     726:	fa 01       	movw	r30, r20
     728:	09 95       	icall

	return;
}
     72a:	0f 90       	pop	r0
     72c:	0f 90       	pop	r0
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     734:	df 93       	push	r29
     736:	cf 93       	push	r28
     738:	0f 92       	push	r0
     73a:	cd b7       	in	r28, 0x3d	; 61
     73c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     73e:	19 82       	std	Y+1, r1	; 0x01
     740:	13 c0       	rjmp	.+38     	; 0x768 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     742:	89 81       	ldd	r24, Y+1	; 0x01
     744:	28 2f       	mov	r18, r24
     746:	30 e0       	ldi	r19, 0x00	; 0
     748:	c9 01       	movw	r24, r18
     74a:	88 0f       	add	r24, r24
     74c:	99 1f       	adc	r25, r25
     74e:	88 0f       	add	r24, r24
     750:	99 1f       	adc	r25, r25
     752:	88 0f       	add	r24, r24
     754:	99 1f       	adc	r25, r25
     756:	82 0f       	add	r24, r18
     758:	93 1f       	adc	r25, r19
     75a:	85 56       	subi	r24, 0x65	; 101
     75c:	9f 4f       	sbci	r25, 0xFF	; 255
     75e:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     762:	89 81       	ldd	r24, Y+1	; 0x01
     764:	8f 5f       	subi	r24, 0xFF	; 255
     766:	89 83       	std	Y+1, r24	; 0x01
     768:	89 81       	ldd	r24, Y+1	; 0x01
     76a:	82 30       	cpi	r24, 0x02	; 2
     76c:	50 f3       	brcs	.-44     	; 0x742 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     76e:	8d ea       	ldi	r24, 0xAD	; 173
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     776:	86 eb       	ldi	r24, 0xB6	; 182
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     77e:	83 ec       	ldi	r24, 0xC3	; 195
     780:	90 e0       	ldi	r25, 0x00	; 0
     782:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     786:	8d ea       	ldi	r24, 0xAD	; 173
     788:	90 e0       	ldi	r25, 0x00	; 0
     78a:	90 93 c0 00 	sts	0x00C0, r25
     78e:	80 93 bf 00 	sts	0x00BF, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     792:	86 eb       	ldi	r24, 0xB6	; 182
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	90 93 c2 00 	sts	0x00C2, r25
     79a:	80 93 c1 00 	sts	0x00C1, r24
}
     79e:	0f 90       	pop	r0
     7a0:	cf 91       	pop	r28
     7a2:	df 91       	pop	r29
     7a4:	08 95       	ret

000007a6 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     7a6:	df 93       	push	r29
     7a8:	cf 93       	push	r28
     7aa:	00 d0       	rcall	.+0      	; 0x7ac <xCoRoutineRemoveFromEventList+0x6>
     7ac:	00 d0       	rcall	.+0      	; 0x7ae <xCoRoutineRemoveFromEventList+0x8>
     7ae:	0f 92       	push	r0
     7b0:	cd b7       	in	r28, 0x3d	; 61
     7b2:	de b7       	in	r29, 0x3e	; 62
     7b4:	9d 83       	std	Y+5, r25	; 0x05
     7b6:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     7b8:	ec 81       	ldd	r30, Y+4	; 0x04
     7ba:	fd 81       	ldd	r31, Y+5	; 0x05
     7bc:	05 80       	ldd	r0, Z+5	; 0x05
     7be:	f6 81       	ldd	r31, Z+6	; 0x06
     7c0:	e0 2d       	mov	r30, r0
     7c2:	86 81       	ldd	r24, Z+6	; 0x06
     7c4:	97 81       	ldd	r25, Z+7	; 0x07
     7c6:	9b 83       	std	Y+3, r25	; 0x03
     7c8:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     7ca:	8a 81       	ldd	r24, Y+2	; 0x02
     7cc:	9b 81       	ldd	r25, Y+3	; 0x03
     7ce:	0c 96       	adiw	r24, 0x0c	; 12
     7d0:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     7d4:	8a 81       	ldd	r24, Y+2	; 0x02
     7d6:	9b 81       	ldd	r25, Y+3	; 0x03
     7d8:	9c 01       	movw	r18, r24
     7da:	24 5f       	subi	r18, 0xF4	; 244
     7dc:	3f 4f       	sbci	r19, 0xFF	; 255
     7de:	83 ec       	ldi	r24, 0xC3	; 195
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	b9 01       	movw	r22, r18
     7e4:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     7e8:	ea 81       	ldd	r30, Y+2	; 0x02
     7ea:	fb 81       	ldd	r31, Y+3	; 0x03
     7ec:	96 89       	ldd	r25, Z+22	; 0x16
     7ee:	e0 91 92 00 	lds	r30, 0x0092
     7f2:	f0 91 93 00 	lds	r31, 0x0093
     7f6:	86 89       	ldd	r24, Z+22	; 0x16
     7f8:	98 17       	cp	r25, r24
     7fa:	18 f0       	brcs	.+6      	; 0x802 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     7fc:	81 e0       	ldi	r24, 0x01	; 1
     7fe:	89 83       	std	Y+1, r24	; 0x01
     800:	01 c0       	rjmp	.+2      	; 0x804 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     802:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     804:	89 81       	ldd	r24, Y+1	; 0x01
}
     806:	0f 90       	pop	r0
     808:	0f 90       	pop	r0
     80a:	0f 90       	pop	r0
     80c:	0f 90       	pop	r0
     80e:	0f 90       	pop	r0
     810:	cf 91       	pop	r28
     812:	df 91       	pop	r29
     814:	08 95       	ret

00000816 <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
     816:	df 93       	push	r29
     818:	cf 93       	push	r28
     81a:	00 d0       	rcall	.+0      	; 0x81c <xEventGroupCreate+0x6>
     81c:	cd b7       	in	r28, 0x3d	; 61
     81e:	de b7       	in	r29, 0x3e	; 62
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
     820:	8b e0       	ldi	r24, 0x0B	; 11
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
     828:	9a 83       	std	Y+2, r25	; 0x02
     82a:	89 83       	std	Y+1, r24	; 0x01
	if( pxEventBits != NULL )
     82c:	89 81       	ldd	r24, Y+1	; 0x01
     82e:	9a 81       	ldd	r25, Y+2	; 0x02
     830:	00 97       	sbiw	r24, 0x00	; 0
     832:	49 f0       	breq	.+18     	; 0x846 <xEventGroupCreate+0x30>
	{
		pxEventBits->uxEventBits = 0;
     834:	e9 81       	ldd	r30, Y+1	; 0x01
     836:	fa 81       	ldd	r31, Y+2	; 0x02
     838:	11 82       	std	Z+1, r1	; 0x01
     83a:	10 82       	st	Z, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     83c:	89 81       	ldd	r24, Y+1	; 0x01
     83e:	9a 81       	ldd	r25, Y+2	; 0x02
     840:	02 96       	adiw	r24, 0x02	; 2
     842:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
     846:	89 81       	ldd	r24, Y+1	; 0x01
     848:	9a 81       	ldd	r25, Y+2	; 0x02
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	cf 91       	pop	r28
     850:	df 91       	pop	r29
     852:	08 95       	ret

00000854 <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     854:	df 93       	push	r29
     856:	cf 93       	push	r28
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	60 97       	sbiw	r28, 0x10	; 16
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 87       	std	Y+10, r25	; 0x0a
     86a:	89 87       	std	Y+9, r24	; 0x09
     86c:	7c 87       	std	Y+12, r23	; 0x0c
     86e:	6b 87       	std	Y+11, r22	; 0x0b
     870:	5e 87       	std	Y+14, r21	; 0x0e
     872:	4d 87       	std	Y+13, r20	; 0x0d
     874:	38 8b       	std	Y+16, r19	; 0x10
     876:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     878:	89 85       	ldd	r24, Y+9	; 0x09
     87a:	9a 85       	ldd	r25, Y+10	; 0x0a
     87c:	9c 83       	std	Y+4, r25	; 0x04
     87e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     880:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     882:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     886:	eb 81       	ldd	r30, Y+3	; 0x03
     888:	fc 81       	ldd	r31, Y+4	; 0x04
     88a:	80 81       	ld	r24, Z
     88c:	91 81       	ldd	r25, Z+1	; 0x01
     88e:	98 87       	std	Y+8, r25	; 0x08
     890:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     892:	89 85       	ldd	r24, Y+9	; 0x09
     894:	9a 85       	ldd	r25, Y+10	; 0x0a
     896:	2b 85       	ldd	r18, Y+11	; 0x0b
     898:	3c 85       	ldd	r19, Y+12	; 0x0c
     89a:	b9 01       	movw	r22, r18
     89c:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     8a0:	2f 81       	ldd	r18, Y+7	; 0x07
     8a2:	38 85       	ldd	r19, Y+8	; 0x08
     8a4:	8b 85       	ldd	r24, Y+11	; 0x0b
     8a6:	9c 85       	ldd	r25, Y+12	; 0x0c
     8a8:	28 2b       	or	r18, r24
     8aa:	39 2b       	or	r19, r25
     8ac:	8d 85       	ldd	r24, Y+13	; 0x0d
     8ae:	9e 85       	ldd	r25, Y+14	; 0x0e
     8b0:	28 23       	and	r18, r24
     8b2:	39 23       	and	r19, r25
     8b4:	8d 85       	ldd	r24, Y+13	; 0x0d
     8b6:	9e 85       	ldd	r25, Y+14	; 0x0e
     8b8:	28 17       	cp	r18, r24
     8ba:	39 07       	cpc	r19, r25
     8bc:	c9 f4       	brne	.+50     	; 0x8f0 <__stack+0x91>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     8be:	2f 81       	ldd	r18, Y+7	; 0x07
     8c0:	38 85       	ldd	r19, Y+8	; 0x08
     8c2:	8b 85       	ldd	r24, Y+11	; 0x0b
     8c4:	9c 85       	ldd	r25, Y+12	; 0x0c
     8c6:	82 2b       	or	r24, r18
     8c8:	93 2b       	or	r25, r19
     8ca:	9e 83       	std	Y+6, r25	; 0x06
     8cc:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8ce:	eb 81       	ldd	r30, Y+3	; 0x03
     8d0:	fc 81       	ldd	r31, Y+4	; 0x04
     8d2:	20 81       	ld	r18, Z
     8d4:	31 81       	ldd	r19, Z+1	; 0x01
     8d6:	8d 85       	ldd	r24, Y+13	; 0x0d
     8d8:	9e 85       	ldd	r25, Y+14	; 0x0e
     8da:	80 95       	com	r24
     8dc:	90 95       	com	r25
     8de:	82 23       	and	r24, r18
     8e0:	93 23       	and	r25, r19
     8e2:	eb 81       	ldd	r30, Y+3	; 0x03
     8e4:	fc 81       	ldd	r31, Y+4	; 0x04
     8e6:	91 83       	std	Z+1, r25	; 0x01
     8e8:	80 83       	st	Z, r24

			xTicksToWait = 0;
     8ea:	18 8a       	std	Y+16, r1	; 0x10
     8ec:	1f 86       	std	Y+15, r1	; 0x0f
     8ee:	1c c0       	rjmp	.+56     	; 0x928 <__stack+0xc9>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     8f0:	8f 85       	ldd	r24, Y+15	; 0x0f
     8f2:	98 89       	ldd	r25, Y+16	; 0x10
     8f4:	00 97       	sbiw	r24, 0x00	; 0
     8f6:	91 f0       	breq	.+36     	; 0x91c <__stack+0xbd>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     8f8:	8b 81       	ldd	r24, Y+3	; 0x03
     8fa:	9c 81       	ldd	r25, Y+4	; 0x04
     8fc:	bc 01       	movw	r22, r24
     8fe:	6e 5f       	subi	r22, 0xFE	; 254
     900:	7f 4f       	sbci	r23, 0xFF	; 255
     902:	8d 85       	ldd	r24, Y+13	; 0x0d
     904:	9e 85       	ldd	r25, Y+14	; 0x0e
     906:	9c 01       	movw	r18, r24
     908:	35 60       	ori	r19, 0x05	; 5
     90a:	4f 85       	ldd	r20, Y+15	; 0x0f
     90c:	58 89       	ldd	r21, Y+16	; 0x10
     90e:	cb 01       	movw	r24, r22
     910:	b9 01       	movw	r22, r18
     912:	0e 94 54 18 	call	0x30a8	; 0x30a8 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     916:	1e 82       	std	Y+6, r1	; 0x06
     918:	1d 82       	std	Y+5, r1	; 0x05
     91a:	06 c0       	rjmp	.+12     	; 0x928 <__stack+0xc9>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     91c:	eb 81       	ldd	r30, Y+3	; 0x03
     91e:	fc 81       	ldd	r31, Y+4	; 0x04
     920:	80 81       	ld	r24, Z
     922:	91 81       	ldd	r25, Z+1	; 0x01
     924:	9e 83       	std	Y+6, r25	; 0x06
     926:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     928:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
     92c:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     92e:	8f 85       	ldd	r24, Y+15	; 0x0f
     930:	98 89       	ldd	r25, Y+16	; 0x10
     932:	00 97       	sbiw	r24, 0x00	; 0
     934:	09 f4       	brne	.+2      	; 0x938 <__stack+0xd9>
     936:	3a c0       	rjmp	.+116    	; 0x9ac <__stack+0x14d>
	{
		if( xAlreadyYielded == pdFALSE )
     938:	8a 81       	ldd	r24, Y+2	; 0x02
     93a:	88 23       	and	r24, r24
     93c:	11 f4       	brne	.+4      	; 0x942 <__stack+0xe3>
		{
			portYIELD_WITHIN_API();
     93e:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     942:	0e 94 ba 1b 	call	0x3774	; 0x3774 <uxTaskResetEventItemValue>
     946:	9e 83       	std	Y+6, r25	; 0x06
     948:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     94a:	8d 81       	ldd	r24, Y+5	; 0x05
     94c:	9e 81       	ldd	r25, Y+6	; 0x06
     94e:	80 70       	andi	r24, 0x00	; 0
     950:	92 70       	andi	r25, 0x02	; 2
     952:	00 97       	sbiw	r24, 0x00	; 0
     954:	31 f5       	brne	.+76     	; 0x9a2 <__stack+0x143>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     956:	0f b6       	in	r0, 0x3f	; 63
     958:	f8 94       	cli
     95a:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     95c:	eb 81       	ldd	r30, Y+3	; 0x03
     95e:	fc 81       	ldd	r31, Y+4	; 0x04
     960:	80 81       	ld	r24, Z
     962:	91 81       	ldd	r25, Z+1	; 0x01
     964:	9e 83       	std	Y+6, r25	; 0x06
     966:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     968:	2d 81       	ldd	r18, Y+5	; 0x05
     96a:	3e 81       	ldd	r19, Y+6	; 0x06
     96c:	8d 85       	ldd	r24, Y+13	; 0x0d
     96e:	9e 85       	ldd	r25, Y+14	; 0x0e
     970:	28 23       	and	r18, r24
     972:	39 23       	and	r19, r25
     974:	8d 85       	ldd	r24, Y+13	; 0x0d
     976:	9e 85       	ldd	r25, Y+14	; 0x0e
     978:	28 17       	cp	r18, r24
     97a:	39 07       	cpc	r19, r25
     97c:	71 f4       	brne	.+28     	; 0x99a <__stack+0x13b>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     97e:	eb 81       	ldd	r30, Y+3	; 0x03
     980:	fc 81       	ldd	r31, Y+4	; 0x04
     982:	20 81       	ld	r18, Z
     984:	31 81       	ldd	r19, Z+1	; 0x01
     986:	8d 85       	ldd	r24, Y+13	; 0x0d
     988:	9e 85       	ldd	r25, Y+14	; 0x0e
     98a:	80 95       	com	r24
     98c:	90 95       	com	r25
     98e:	82 23       	and	r24, r18
     990:	93 23       	and	r25, r19
     992:	eb 81       	ldd	r30, Y+3	; 0x03
     994:	fc 81       	ldd	r31, Y+4	; 0x04
     996:	91 83       	std	Z+1, r25	; 0x01
     998:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     99a:	0f 90       	pop	r0
     99c:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     9a2:	8d 81       	ldd	r24, Y+5	; 0x05
     9a4:	9e 81       	ldd	r25, Y+6	; 0x06
     9a6:	90 70       	andi	r25, 0x00	; 0
     9a8:	9e 83       	std	Y+6, r25	; 0x06
     9aa:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
     9ac:	8d 81       	ldd	r24, Y+5	; 0x05
     9ae:	9e 81       	ldd	r25, Y+6	; 0x06
}
     9b0:	60 96       	adiw	r28, 0x10	; 16
     9b2:	0f b6       	in	r0, 0x3f	; 63
     9b4:	f8 94       	cli
     9b6:	de bf       	out	0x3e, r29	; 62
     9b8:	0f be       	out	0x3f, r0	; 63
     9ba:	cd bf       	out	0x3d, r28	; 61
     9bc:	cf 91       	pop	r28
     9be:	df 91       	pop	r29
     9c0:	08 95       	ret

000009c2 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     9c2:	0f 93       	push	r16
     9c4:	1f 93       	push	r17
     9c6:	df 93       	push	r29
     9c8:	cf 93       	push	r28
     9ca:	cd b7       	in	r28, 0x3d	; 61
     9cc:	de b7       	in	r29, 0x3e	; 62
     9ce:	63 97       	sbiw	r28, 0x13	; 19
     9d0:	0f b6       	in	r0, 0x3f	; 63
     9d2:	f8 94       	cli
     9d4:	de bf       	out	0x3e, r29	; 62
     9d6:	0f be       	out	0x3f, r0	; 63
     9d8:	cd bf       	out	0x3d, r28	; 61
     9da:	9d 87       	std	Y+13, r25	; 0x0d
     9dc:	8c 87       	std	Y+12, r24	; 0x0c
     9de:	7f 87       	std	Y+15, r23	; 0x0f
     9e0:	6e 87       	std	Y+14, r22	; 0x0e
     9e2:	48 8b       	std	Y+16, r20	; 0x10
     9e4:	29 8b       	std	Y+17, r18	; 0x11
     9e6:	1b 8b       	std	Y+19, r17	; 0x13
     9e8:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     9ea:	8c 85       	ldd	r24, Y+12	; 0x0c
     9ec:	9d 85       	ldd	r25, Y+13	; 0x0d
     9ee:	9b 87       	std	Y+11, r25	; 0x0b
     9f0:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     9f2:	1f 82       	std	Y+7, r1	; 0x07
     9f4:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     9f6:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     9f8:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     9fc:	ea 85       	ldd	r30, Y+10	; 0x0a
     9fe:	fb 85       	ldd	r31, Y+11	; 0x0b
     a00:	80 81       	ld	r24, Z
     a02:	91 81       	ldd	r25, Z+1	; 0x01
     a04:	9a 83       	std	Y+2, r25	; 0x02
     a06:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     a08:	89 81       	ldd	r24, Y+1	; 0x01
     a0a:	9a 81       	ldd	r25, Y+2	; 0x02
     a0c:	2e 85       	ldd	r18, Y+14	; 0x0e
     a0e:	3f 85       	ldd	r19, Y+15	; 0x0f
     a10:	b9 01       	movw	r22, r18
     a12:	49 89       	ldd	r20, Y+17	; 0x11
     a14:	0e 94 19 07 	call	0xe32	; 0xe32 <prvTestWaitCondition>
     a18:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     a1a:	8d 81       	ldd	r24, Y+5	; 0x05
     a1c:	88 23       	and	r24, r24
     a1e:	c1 f0       	breq	.+48     	; 0xa50 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	99 87       	std	Y+9, r25	; 0x09
     a26:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     a28:	1b 8a       	std	Y+19, r1	; 0x13
     a2a:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     a2c:	88 89       	ldd	r24, Y+16	; 0x10
     a2e:	88 23       	and	r24, r24
     a30:	d9 f1       	breq	.+118    	; 0xaa8 <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a32:	ea 85       	ldd	r30, Y+10	; 0x0a
     a34:	fb 85       	ldd	r31, Y+11	; 0x0b
     a36:	20 81       	ld	r18, Z
     a38:	31 81       	ldd	r19, Z+1	; 0x01
     a3a:	8e 85       	ldd	r24, Y+14	; 0x0e
     a3c:	9f 85       	ldd	r25, Y+15	; 0x0f
     a3e:	80 95       	com	r24
     a40:	90 95       	com	r25
     a42:	82 23       	and	r24, r18
     a44:	93 23       	and	r25, r19
     a46:	ea 85       	ldd	r30, Y+10	; 0x0a
     a48:	fb 85       	ldd	r31, Y+11	; 0x0b
     a4a:	91 83       	std	Z+1, r25	; 0x01
     a4c:	80 83       	st	Z, r24
     a4e:	2c c0       	rjmp	.+88     	; 0xaa8 <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     a50:	8a 89       	ldd	r24, Y+18	; 0x12
     a52:	9b 89       	ldd	r25, Y+19	; 0x13
     a54:	00 97       	sbiw	r24, 0x00	; 0
     a56:	29 f4       	brne	.+10     	; 0xa62 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     a58:	89 81       	ldd	r24, Y+1	; 0x01
     a5a:	9a 81       	ldd	r25, Y+2	; 0x02
     a5c:	99 87       	std	Y+9, r25	; 0x09
     a5e:	88 87       	std	Y+8, r24	; 0x08
     a60:	23 c0       	rjmp	.+70     	; 0xaa8 <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     a62:	88 89       	ldd	r24, Y+16	; 0x10
     a64:	88 23       	and	r24, r24
     a66:	29 f0       	breq	.+10     	; 0xa72 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     a68:	8e 81       	ldd	r24, Y+6	; 0x06
     a6a:	9f 81       	ldd	r25, Y+7	; 0x07
     a6c:	91 60       	ori	r25, 0x01	; 1
     a6e:	9f 83       	std	Y+7, r25	; 0x07
     a70:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     a72:	89 89       	ldd	r24, Y+17	; 0x11
     a74:	88 23       	and	r24, r24
     a76:	29 f0       	breq	.+10     	; 0xa82 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     a78:	8e 81       	ldd	r24, Y+6	; 0x06
     a7a:	9f 81       	ldd	r25, Y+7	; 0x07
     a7c:	94 60       	ori	r25, 0x04	; 4
     a7e:	9f 83       	std	Y+7, r25	; 0x07
     a80:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     a82:	8a 85       	ldd	r24, Y+10	; 0x0a
     a84:	9b 85       	ldd	r25, Y+11	; 0x0b
     a86:	bc 01       	movw	r22, r24
     a88:	6e 5f       	subi	r22, 0xFE	; 254
     a8a:	7f 4f       	sbci	r23, 0xFF	; 255
     a8c:	2e 85       	ldd	r18, Y+14	; 0x0e
     a8e:	3f 85       	ldd	r19, Y+15	; 0x0f
     a90:	8e 81       	ldd	r24, Y+6	; 0x06
     a92:	9f 81       	ldd	r25, Y+7	; 0x07
     a94:	28 2b       	or	r18, r24
     a96:	39 2b       	or	r19, r25
     a98:	4a 89       	ldd	r20, Y+18	; 0x12
     a9a:	5b 89       	ldd	r21, Y+19	; 0x13
     a9c:	cb 01       	movw	r24, r22
     a9e:	b9 01       	movw	r22, r18
     aa0:	0e 94 54 18 	call	0x30a8	; 0x30a8 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     aa4:	19 86       	std	Y+9, r1	; 0x09
     aa6:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     aa8:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
     aac:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     aae:	8a 89       	ldd	r24, Y+18	; 0x12
     ab0:	9b 89       	ldd	r25, Y+19	; 0x13
     ab2:	00 97       	sbiw	r24, 0x00	; 0
     ab4:	09 f4       	brne	.+2      	; 0xab8 <xEventGroupWaitBits+0xf6>
     ab6:	3b c0       	rjmp	.+118    	; 0xb2e <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
     ab8:	8c 81       	ldd	r24, Y+4	; 0x04
     aba:	88 23       	and	r24, r24
     abc:	11 f4       	brne	.+4      	; 0xac2 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
     abe:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     ac2:	0e 94 ba 1b 	call	0x3774	; 0x3774 <uxTaskResetEventItemValue>
     ac6:	99 87       	std	Y+9, r25	; 0x09
     ac8:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     aca:	88 85       	ldd	r24, Y+8	; 0x08
     acc:	99 85       	ldd	r25, Y+9	; 0x09
     ace:	80 70       	andi	r24, 0x00	; 0
     ad0:	92 70       	andi	r25, 0x02	; 2
     ad2:	00 97       	sbiw	r24, 0x00	; 0
     ad4:	39 f5       	brne	.+78     	; 0xb24 <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
     ad6:	0f b6       	in	r0, 0x3f	; 63
     ad8:	f8 94       	cli
     ada:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     adc:	ea 85       	ldd	r30, Y+10	; 0x0a
     ade:	fb 85       	ldd	r31, Y+11	; 0x0b
     ae0:	80 81       	ld	r24, Z
     ae2:	91 81       	ldd	r25, Z+1	; 0x01
     ae4:	99 87       	std	Y+9, r25	; 0x09
     ae6:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     ae8:	88 85       	ldd	r24, Y+8	; 0x08
     aea:	99 85       	ldd	r25, Y+9	; 0x09
     aec:	2e 85       	ldd	r18, Y+14	; 0x0e
     aee:	3f 85       	ldd	r19, Y+15	; 0x0f
     af0:	b9 01       	movw	r22, r18
     af2:	49 89       	ldd	r20, Y+17	; 0x11
     af4:	0e 94 19 07 	call	0xe32	; 0xe32 <prvTestWaitCondition>
     af8:	88 23       	and	r24, r24
     afa:	89 f0       	breq	.+34     	; 0xb1e <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
     afc:	88 89       	ldd	r24, Y+16	; 0x10
     afe:	88 23       	and	r24, r24
     b00:	71 f0       	breq	.+28     	; 0xb1e <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     b02:	ea 85       	ldd	r30, Y+10	; 0x0a
     b04:	fb 85       	ldd	r31, Y+11	; 0x0b
     b06:	20 81       	ld	r18, Z
     b08:	31 81       	ldd	r19, Z+1	; 0x01
     b0a:	8e 85       	ldd	r24, Y+14	; 0x0e
     b0c:	9f 85       	ldd	r25, Y+15	; 0x0f
     b0e:	80 95       	com	r24
     b10:	90 95       	com	r25
     b12:	82 23       	and	r24, r18
     b14:	93 23       	and	r25, r19
     b16:	ea 85       	ldd	r30, Y+10	; 0x0a
     b18:	fb 85       	ldd	r31, Y+11	; 0x0b
     b1a:	91 83       	std	Z+1, r25	; 0x01
     b1c:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     b1e:	0f 90       	pop	r0
     b20:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
     b22:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     b24:	88 85       	ldd	r24, Y+8	; 0x08
     b26:	99 85       	ldd	r25, Y+9	; 0x09
     b28:	90 70       	andi	r25, 0x00	; 0
     b2a:	99 87       	std	Y+9, r25	; 0x09
     b2c:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
     b2e:	88 85       	ldd	r24, Y+8	; 0x08
     b30:	99 85       	ldd	r25, Y+9	; 0x09
}
     b32:	63 96       	adiw	r28, 0x13	; 19
     b34:	0f b6       	in	r0, 0x3f	; 63
     b36:	f8 94       	cli
     b38:	de bf       	out	0x3e, r29	; 62
     b3a:	0f be       	out	0x3f, r0	; 63
     b3c:	cd bf       	out	0x3d, r28	; 61
     b3e:	cf 91       	pop	r28
     b40:	df 91       	pop	r29
     b42:	1f 91       	pop	r17
     b44:	0f 91       	pop	r16
     b46:	08 95       	ret

00000b48 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     b48:	df 93       	push	r29
     b4a:	cf 93       	push	r28
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	28 97       	sbiw	r28, 0x08	; 8
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	f8 94       	cli
     b56:	de bf       	out	0x3e, r29	; 62
     b58:	0f be       	out	0x3f, r0	; 63
     b5a:	cd bf       	out	0x3d, r28	; 61
     b5c:	9e 83       	std	Y+6, r25	; 0x06
     b5e:	8d 83       	std	Y+5, r24	; 0x05
     b60:	78 87       	std	Y+8, r23	; 0x08
     b62:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     b64:	8d 81       	ldd	r24, Y+5	; 0x05
     b66:	9e 81       	ldd	r25, Y+6	; 0x06
     b68:	9c 83       	std	Y+4, r25	; 0x04
     b6a:	8b 83       	std	Y+3, r24	; 0x03

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	f8 94       	cli
     b70:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     b72:	eb 81       	ldd	r30, Y+3	; 0x03
     b74:	fc 81       	ldd	r31, Y+4	; 0x04
     b76:	80 81       	ld	r24, Z
     b78:	91 81       	ldd	r25, Z+1	; 0x01
     b7a:	9a 83       	std	Y+2, r25	; 0x02
     b7c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     b7e:	eb 81       	ldd	r30, Y+3	; 0x03
     b80:	fc 81       	ldd	r31, Y+4	; 0x04
     b82:	20 81       	ld	r18, Z
     b84:	31 81       	ldd	r19, Z+1	; 0x01
     b86:	8f 81       	ldd	r24, Y+7	; 0x07
     b88:	98 85       	ldd	r25, Y+8	; 0x08
     b8a:	80 95       	com	r24
     b8c:	90 95       	com	r25
     b8e:	82 23       	and	r24, r18
     b90:	93 23       	and	r25, r19
     b92:	eb 81       	ldd	r30, Y+3	; 0x03
     b94:	fc 81       	ldd	r31, Y+4	; 0x04
     b96:	91 83       	std	Z+1, r25	; 0x01
     b98:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     b9a:	0f 90       	pop	r0
     b9c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ba2:	28 96       	adiw	r28, 0x08	; 8
     ba4:	0f b6       	in	r0, 0x3f	; 63
     ba6:	f8 94       	cli
     ba8:	de bf       	out	0x3e, r29	; 62
     baa:	0f be       	out	0x3f, r0	; 63
     bac:	cd bf       	out	0x3d, r28	; 61
     bae:	cf 91       	pop	r28
     bb0:	df 91       	pop	r29
     bb2:	08 95       	ret

00000bb4 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     bb4:	df 93       	push	r29
     bb6:	cf 93       	push	r28
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
     bbc:	27 97       	sbiw	r28, 0x07	; 7
     bbe:	0f b6       	in	r0, 0x3f	; 63
     bc0:	f8 94       	cli
     bc2:	de bf       	out	0x3e, r29	; 62
     bc4:	0f be       	out	0x3f, r0	; 63
     bc6:	cd bf       	out	0x3d, r28	; 61
     bc8:	9f 83       	std	Y+7, r25	; 0x07
     bca:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     bcc:	8e 81       	ldd	r24, Y+6	; 0x06
     bce:	9f 81       	ldd	r25, Y+7	; 0x07
     bd0:	9c 83       	std	Y+4, r25	; 0x04
     bd2:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     bd4:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     bd6:	eb 81       	ldd	r30, Y+3	; 0x03
     bd8:	fc 81       	ldd	r31, Y+4	; 0x04
     bda:	80 81       	ld	r24, Z
     bdc:	91 81       	ldd	r25, Z+1	; 0x01
     bde:	9a 83       	std	Y+2, r25	; 0x02
     be0:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     be2:	89 81       	ldd	r24, Y+1	; 0x01
     be4:	9a 81       	ldd	r25, Y+2	; 0x02
}
     be6:	27 96       	adiw	r28, 0x07	; 7
     be8:	0f b6       	in	r0, 0x3f	; 63
     bea:	f8 94       	cli
     bec:	de bf       	out	0x3e, r29	; 62
     bee:	0f be       	out	0x3f, r0	; 63
     bf0:	cd bf       	out	0x3d, r28	; 61
     bf2:	cf 91       	pop	r28
     bf4:	df 91       	pop	r29
     bf6:	08 95       	ret

00000bf8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     bf8:	df 93       	push	r29
     bfa:	cf 93       	push	r28
     bfc:	cd b7       	in	r28, 0x3d	; 61
     bfe:	de b7       	in	r29, 0x3e	; 62
     c00:	65 97       	sbiw	r28, 0x15	; 21
     c02:	0f b6       	in	r0, 0x3f	; 63
     c04:	f8 94       	cli
     c06:	de bf       	out	0x3e, r29	; 62
     c08:	0f be       	out	0x3f, r0	; 63
     c0a:	cd bf       	out	0x3d, r28	; 61
     c0c:	9b 8b       	std	Y+19, r25	; 0x13
     c0e:	8a 8b       	std	Y+18, r24	; 0x12
     c10:	7d 8b       	std	Y+21, r23	; 0x15
     c12:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     c14:	19 86       	std	Y+9, r1	; 0x09
     c16:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     c18:	8a 89       	ldd	r24, Y+18	; 0x12
     c1a:	9b 89       	ldd	r25, Y+19	; 0x13
     c1c:	9b 83       	std	Y+3, r25	; 0x03
     c1e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     c20:	19 82       	std	Y+1, r1	; 0x01

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     c22:	8a 81       	ldd	r24, Y+2	; 0x02
     c24:	9b 81       	ldd	r25, Y+3	; 0x03
     c26:	02 96       	adiw	r24, 0x02	; 2
     c28:	9b 87       	std	Y+11, r25	; 0x0b
     c2a:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c2c:	8a 85       	ldd	r24, Y+10	; 0x0a
     c2e:	9b 85       	ldd	r25, Y+11	; 0x0b
     c30:	03 96       	adiw	r24, 0x03	; 3
     c32:	9d 87       	std	Y+13, r25	; 0x0d
     c34:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     c36:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     c3a:	ea 85       	ldd	r30, Y+10	; 0x0a
     c3c:	fb 85       	ldd	r31, Y+11	; 0x0b
     c3e:	85 81       	ldd	r24, Z+5	; 0x05
     c40:	96 81       	ldd	r25, Z+6	; 0x06
     c42:	99 8b       	std	Y+17, r25	; 0x11
     c44:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     c46:	ea 81       	ldd	r30, Y+2	; 0x02
     c48:	fb 81       	ldd	r31, Y+3	; 0x03
     c4a:	20 81       	ld	r18, Z
     c4c:	31 81       	ldd	r19, Z+1	; 0x01
     c4e:	8c 89       	ldd	r24, Y+20	; 0x14
     c50:	9d 89       	ldd	r25, Y+21	; 0x15
     c52:	82 2b       	or	r24, r18
     c54:	93 2b       	or	r25, r19
     c56:	ea 81       	ldd	r30, Y+2	; 0x02
     c58:	fb 81       	ldd	r31, Y+3	; 0x03
     c5a:	91 83       	std	Z+1, r25	; 0x01
     c5c:	80 83       	st	Z, r24
     c5e:	59 c0       	rjmp	.+178    	; 0xd12 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     c60:	e8 89       	ldd	r30, Y+16	; 0x10
     c62:	f9 89       	ldd	r31, Y+17	; 0x11
     c64:	82 81       	ldd	r24, Z+2	; 0x02
     c66:	93 81       	ldd	r25, Z+3	; 0x03
     c68:	9f 87       	std	Y+15, r25	; 0x0f
     c6a:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     c6c:	e8 89       	ldd	r30, Y+16	; 0x10
     c6e:	f9 89       	ldd	r31, Y+17	; 0x11
     c70:	80 81       	ld	r24, Z
     c72:	91 81       	ldd	r25, Z+1	; 0x01
     c74:	9f 83       	std	Y+7, r25	; 0x07
     c76:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     c78:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     c7a:	8e 81       	ldd	r24, Y+6	; 0x06
     c7c:	9f 81       	ldd	r25, Y+7	; 0x07
     c7e:	80 70       	andi	r24, 0x00	; 0
     c80:	9d 83       	std	Y+5, r25	; 0x05
     c82:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     c84:	8e 81       	ldd	r24, Y+6	; 0x06
     c86:	9f 81       	ldd	r25, Y+7	; 0x07
     c88:	90 70       	andi	r25, 0x00	; 0
     c8a:	9f 83       	std	Y+7, r25	; 0x07
     c8c:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     c8e:	8c 81       	ldd	r24, Y+4	; 0x04
     c90:	9d 81       	ldd	r25, Y+5	; 0x05
     c92:	80 70       	andi	r24, 0x00	; 0
     c94:	94 70       	andi	r25, 0x04	; 4
     c96:	00 97       	sbiw	r24, 0x00	; 0
     c98:	69 f4       	brne	.+26     	; 0xcb4 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     c9a:	ea 81       	ldd	r30, Y+2	; 0x02
     c9c:	fb 81       	ldd	r31, Y+3	; 0x03
     c9e:	20 81       	ld	r18, Z
     ca0:	31 81       	ldd	r19, Z+1	; 0x01
     ca2:	8e 81       	ldd	r24, Y+6	; 0x06
     ca4:	9f 81       	ldd	r25, Y+7	; 0x07
     ca6:	82 23       	and	r24, r18
     ca8:	93 23       	and	r25, r19
     caa:	00 97       	sbiw	r24, 0x00	; 0
     cac:	91 f0       	breq	.+36     	; 0xcd2 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	89 83       	std	Y+1, r24	; 0x01
     cb2:	0f c0       	rjmp	.+30     	; 0xcd2 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     cb4:	ea 81       	ldd	r30, Y+2	; 0x02
     cb6:	fb 81       	ldd	r31, Y+3	; 0x03
     cb8:	20 81       	ld	r18, Z
     cba:	31 81       	ldd	r19, Z+1	; 0x01
     cbc:	8e 81       	ldd	r24, Y+6	; 0x06
     cbe:	9f 81       	ldd	r25, Y+7	; 0x07
     cc0:	28 23       	and	r18, r24
     cc2:	39 23       	and	r19, r25
     cc4:	8e 81       	ldd	r24, Y+6	; 0x06
     cc6:	9f 81       	ldd	r25, Y+7	; 0x07
     cc8:	28 17       	cp	r18, r24
     cca:	39 07       	cpc	r19, r25
     ccc:	11 f4       	brne	.+4      	; 0xcd2 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     cd2:	89 81       	ldd	r24, Y+1	; 0x01
     cd4:	88 23       	and	r24, r24
     cd6:	c9 f0       	breq	.+50     	; 0xd0a <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     cd8:	8c 81       	ldd	r24, Y+4	; 0x04
     cda:	9d 81       	ldd	r25, Y+5	; 0x05
     cdc:	80 70       	andi	r24, 0x00	; 0
     cde:	91 70       	andi	r25, 0x01	; 1
     ce0:	00 97       	sbiw	r24, 0x00	; 0
     ce2:	41 f0       	breq	.+16     	; 0xcf4 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     ce4:	88 85       	ldd	r24, Y+8	; 0x08
     ce6:	99 85       	ldd	r25, Y+9	; 0x09
     ce8:	2e 81       	ldd	r18, Y+6	; 0x06
     cea:	3f 81       	ldd	r19, Y+7	; 0x07
     cec:	82 2b       	or	r24, r18
     cee:	93 2b       	or	r25, r19
     cf0:	99 87       	std	Y+9, r25	; 0x09
     cf2:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     cf4:	ea 81       	ldd	r30, Y+2	; 0x02
     cf6:	fb 81       	ldd	r31, Y+3	; 0x03
     cf8:	80 81       	ld	r24, Z
     cfa:	91 81       	ldd	r25, Z+1	; 0x01
     cfc:	9c 01       	movw	r18, r24
     cfe:	32 60       	ori	r19, 0x02	; 2
     d00:	88 89       	ldd	r24, Y+16	; 0x10
     d02:	99 89       	ldd	r25, Y+17	; 0x11
     d04:	b9 01       	movw	r22, r18
     d06:	0e 94 02 19 	call	0x3204	; 0x3204 <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     d0a:	8e 85       	ldd	r24, Y+14	; 0x0e
     d0c:	9f 85       	ldd	r25, Y+15	; 0x0f
     d0e:	99 8b       	std	Y+17, r25	; 0x11
     d10:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     d12:	28 89       	ldd	r18, Y+16	; 0x10
     d14:	39 89       	ldd	r19, Y+17	; 0x11
     d16:	8c 85       	ldd	r24, Y+12	; 0x0c
     d18:	9d 85       	ldd	r25, Y+13	; 0x0d
     d1a:	28 17       	cp	r18, r24
     d1c:	39 07       	cpc	r19, r25
     d1e:	09 f0       	breq	.+2      	; 0xd22 <xEventGroupSetBits+0x12a>
     d20:	9f cf       	rjmp	.-194    	; 0xc60 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     d22:	ea 81       	ldd	r30, Y+2	; 0x02
     d24:	fb 81       	ldd	r31, Y+3	; 0x03
     d26:	20 81       	ld	r18, Z
     d28:	31 81       	ldd	r19, Z+1	; 0x01
     d2a:	88 85       	ldd	r24, Y+8	; 0x08
     d2c:	99 85       	ldd	r25, Y+9	; 0x09
     d2e:	80 95       	com	r24
     d30:	90 95       	com	r25
     d32:	82 23       	and	r24, r18
     d34:	93 23       	and	r25, r19
     d36:	ea 81       	ldd	r30, Y+2	; 0x02
     d38:	fb 81       	ldd	r31, Y+3	; 0x03
     d3a:	91 83       	std	Z+1, r25	; 0x01
     d3c:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     d3e:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     d42:	ea 81       	ldd	r30, Y+2	; 0x02
     d44:	fb 81       	ldd	r31, Y+3	; 0x03
     d46:	80 81       	ld	r24, Z
     d48:	91 81       	ldd	r25, Z+1	; 0x01
}
     d4a:	65 96       	adiw	r28, 0x15	; 21
     d4c:	0f b6       	in	r0, 0x3f	; 63
     d4e:	f8 94       	cli
     d50:	de bf       	out	0x3e, r29	; 62
     d52:	0f be       	out	0x3f, r0	; 63
     d54:	cd bf       	out	0x3d, r28	; 61
     d56:	cf 91       	pop	r28
     d58:	df 91       	pop	r29
     d5a:	08 95       	ret

00000d5c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     d5c:	df 93       	push	r29
     d5e:	cf 93       	push	r28
     d60:	00 d0       	rcall	.+0      	; 0xd62 <vEventGroupDelete+0x6>
     d62:	00 d0       	rcall	.+0      	; 0xd64 <vEventGroupDelete+0x8>
     d64:	00 d0       	rcall	.+0      	; 0xd66 <vEventGroupDelete+0xa>
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
     d6a:	9e 83       	std	Y+6, r25	; 0x06
     d6c:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
     d6e:	8d 81       	ldd	r24, Y+5	; 0x05
     d70:	9e 81       	ldd	r25, Y+6	; 0x06
     d72:	9c 83       	std	Y+4, r25	; 0x04
     d74:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     d76:	8b 81       	ldd	r24, Y+3	; 0x03
     d78:	9c 81       	ldd	r25, Y+4	; 0x04
     d7a:	02 96       	adiw	r24, 0x02	; 2
     d7c:	9a 83       	std	Y+2, r25	; 0x02
     d7e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     d80:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
     d84:	08 c0       	rjmp	.+16     	; 0xd96 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     d86:	e9 81       	ldd	r30, Y+1	; 0x01
     d88:	fa 81       	ldd	r31, Y+2	; 0x02
     d8a:	85 81       	ldd	r24, Z+5	; 0x05
     d8c:	96 81       	ldd	r25, Z+6	; 0x06
     d8e:	60 e0       	ldi	r22, 0x00	; 0
     d90:	72 e0       	ldi	r23, 0x02	; 2
     d92:	0e 94 02 19 	call	0x3204	; 0x3204 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     d96:	e9 81       	ldd	r30, Y+1	; 0x01
     d98:	fa 81       	ldd	r31, Y+2	; 0x02
     d9a:	80 81       	ld	r24, Z
     d9c:	88 23       	and	r24, r24
     d9e:	99 f7       	brne	.-26     	; 0xd86 <vEventGroupDelete+0x2a>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
     da0:	8b 81       	ldd	r24, Y+3	; 0x03
     da2:	9c 81       	ldd	r25, Y+4	; 0x04
     da4:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
	}
	( void ) xTaskResumeAll();
     da8:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
}
     dac:	26 96       	adiw	r28, 0x06	; 6
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	f8 94       	cli
     db2:	de bf       	out	0x3e, r29	; 62
     db4:	0f be       	out	0x3f, r0	; 63
     db6:	cd bf       	out	0x3d, r28	; 61
     db8:	cf 91       	pop	r28
     dba:	df 91       	pop	r29
     dbc:	08 95       	ret

00000dbe <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     dbe:	df 93       	push	r29
     dc0:	cf 93       	push	r28
     dc2:	00 d0       	rcall	.+0      	; 0xdc4 <vEventGroupSetBitsCallback+0x6>
     dc4:	00 d0       	rcall	.+0      	; 0xdc6 <vEventGroupSetBitsCallback+0x8>
     dc6:	00 d0       	rcall	.+0      	; 0xdc8 <vEventGroupSetBitsCallback+0xa>
     dc8:	cd b7       	in	r28, 0x3d	; 61
     dca:	de b7       	in	r29, 0x3e	; 62
     dcc:	9a 83       	std	Y+2, r25	; 0x02
     dce:	89 83       	std	Y+1, r24	; 0x01
     dd0:	4b 83       	std	Y+3, r20	; 0x03
     dd2:	5c 83       	std	Y+4, r21	; 0x04
     dd4:	6d 83       	std	Y+5, r22	; 0x05
     dd6:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     dd8:	2b 81       	ldd	r18, Y+3	; 0x03
     dda:	3c 81       	ldd	r19, Y+4	; 0x04
     ddc:	89 81       	ldd	r24, Y+1	; 0x01
     dde:	9a 81       	ldd	r25, Y+2	; 0x02
     de0:	b9 01       	movw	r22, r18
     de2:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xEventGroupSetBits>
}
     de6:	26 96       	adiw	r28, 0x06	; 6
     de8:	0f b6       	in	r0, 0x3f	; 63
     dea:	f8 94       	cli
     dec:	de bf       	out	0x3e, r29	; 62
     dee:	0f be       	out	0x3f, r0	; 63
     df0:	cd bf       	out	0x3d, r28	; 61
     df2:	cf 91       	pop	r28
     df4:	df 91       	pop	r29
     df6:	08 95       	ret

00000df8 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     df8:	df 93       	push	r29
     dfa:	cf 93       	push	r28
     dfc:	00 d0       	rcall	.+0      	; 0xdfe <vEventGroupClearBitsCallback+0x6>
     dfe:	00 d0       	rcall	.+0      	; 0xe00 <vEventGroupClearBitsCallback+0x8>
     e00:	00 d0       	rcall	.+0      	; 0xe02 <vEventGroupClearBitsCallback+0xa>
     e02:	cd b7       	in	r28, 0x3d	; 61
     e04:	de b7       	in	r29, 0x3e	; 62
     e06:	9a 83       	std	Y+2, r25	; 0x02
     e08:	89 83       	std	Y+1, r24	; 0x01
     e0a:	4b 83       	std	Y+3, r20	; 0x03
     e0c:	5c 83       	std	Y+4, r21	; 0x04
     e0e:	6d 83       	std	Y+5, r22	; 0x05
     e10:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     e12:	2b 81       	ldd	r18, Y+3	; 0x03
     e14:	3c 81       	ldd	r19, Y+4	; 0x04
     e16:	89 81       	ldd	r24, Y+1	; 0x01
     e18:	9a 81       	ldd	r25, Y+2	; 0x02
     e1a:	b9 01       	movw	r22, r18
     e1c:	0e 94 a4 05 	call	0xb48	; 0xb48 <xEventGroupClearBits>
}
     e20:	26 96       	adiw	r28, 0x06	; 6
     e22:	0f b6       	in	r0, 0x3f	; 63
     e24:	f8 94       	cli
     e26:	de bf       	out	0x3e, r29	; 62
     e28:	0f be       	out	0x3f, r0	; 63
     e2a:	cd bf       	out	0x3d, r28	; 61
     e2c:	cf 91       	pop	r28
     e2e:	df 91       	pop	r29
     e30:	08 95       	ret

00000e32 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     e32:	df 93       	push	r29
     e34:	cf 93       	push	r28
     e36:	00 d0       	rcall	.+0      	; 0xe38 <prvTestWaitCondition+0x6>
     e38:	00 d0       	rcall	.+0      	; 0xe3a <prvTestWaitCondition+0x8>
     e3a:	00 d0       	rcall	.+0      	; 0xe3c <prvTestWaitCondition+0xa>
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
     e40:	9b 83       	std	Y+3, r25	; 0x03
     e42:	8a 83       	std	Y+2, r24	; 0x02
     e44:	7d 83       	std	Y+5, r23	; 0x05
     e46:	6c 83       	std	Y+4, r22	; 0x04
     e48:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     e4a:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     e4c:	8e 81       	ldd	r24, Y+6	; 0x06
     e4e:	88 23       	and	r24, r24
     e50:	59 f4       	brne	.+22     	; 0xe68 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     e52:	8a 81       	ldd	r24, Y+2	; 0x02
     e54:	9b 81       	ldd	r25, Y+3	; 0x03
     e56:	2c 81       	ldd	r18, Y+4	; 0x04
     e58:	3d 81       	ldd	r19, Y+5	; 0x05
     e5a:	82 23       	and	r24, r18
     e5c:	93 23       	and	r25, r19
     e5e:	00 97       	sbiw	r24, 0x00	; 0
     e60:	81 f0       	breq	.+32     	; 0xe82 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     e62:	81 e0       	ldi	r24, 0x01	; 1
     e64:	89 83       	std	Y+1, r24	; 0x01
     e66:	0d c0       	rjmp	.+26     	; 0xe82 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e68:	2a 81       	ldd	r18, Y+2	; 0x02
     e6a:	3b 81       	ldd	r19, Y+3	; 0x03
     e6c:	8c 81       	ldd	r24, Y+4	; 0x04
     e6e:	9d 81       	ldd	r25, Y+5	; 0x05
     e70:	28 23       	and	r18, r24
     e72:	39 23       	and	r19, r25
     e74:	8c 81       	ldd	r24, Y+4	; 0x04
     e76:	9d 81       	ldd	r25, Y+5	; 0x05
     e78:	28 17       	cp	r18, r24
     e7a:	39 07       	cpc	r19, r25
     e7c:	11 f4       	brne	.+4      	; 0xe82 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     e82:	89 81       	ldd	r24, Y+1	; 0x01
}
     e84:	26 96       	adiw	r28, 0x06	; 6
     e86:	0f b6       	in	r0, 0x3f	; 63
     e88:	f8 94       	cli
     e8a:	de bf       	out	0x3e, r29	; 62
     e8c:	0f be       	out	0x3f, r0	; 63
     e8e:	cd bf       	out	0x3d, r28	; 61
     e90:	cf 91       	pop	r28
     e92:	df 91       	pop	r29
     e94:	08 95       	ret

00000e96 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e96:	df 93       	push	r29
     e98:	cf 93       	push	r28
     e9a:	00 d0       	rcall	.+0      	; 0xe9c <pvPortMalloc+0x6>
     e9c:	00 d0       	rcall	.+0      	; 0xe9e <pvPortMalloc+0x8>
     e9e:	cd b7       	in	r28, 0x3d	; 61
     ea0:	de b7       	in	r29, 0x3e	; 62
     ea2:	9c 83       	std	Y+4, r25	; 0x04
     ea4:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     ea6:	1a 82       	std	Y+2, r1	; 0x02
     ea8:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     eaa:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     eae:	80 91 ce 00 	lds	r24, 0x00CE
     eb2:	90 91 cf 00 	lds	r25, 0x00CF
     eb6:	00 97       	sbiw	r24, 0x00	; 0
     eb8:	31 f4       	brne	.+12     	; 0xec6 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     eba:	81 ed       	ldi	r24, 0xD1	; 209
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	90 93 cf 00 	sts	0x00CF, r25
     ec2:	80 93 ce 00 	sts	0x00CE, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     ec6:	80 91 cc 00 	lds	r24, 0x00CC
     eca:	90 91 cd 00 	lds	r25, 0x00CD
     ece:	2b 81       	ldd	r18, Y+3	; 0x03
     ed0:	3c 81       	ldd	r19, Y+4	; 0x04
     ed2:	82 0f       	add	r24, r18
     ed4:	93 1f       	adc	r25, r19
     ed6:	25 e0       	ldi	r18, 0x05	; 5
     ed8:	8b 3d       	cpi	r24, 0xDB	; 219
     eda:	92 07       	cpc	r25, r18
     edc:	38 f5       	brcc	.+78     	; 0xf2c <pvPortMalloc+0x96>
     ede:	20 91 cc 00 	lds	r18, 0x00CC
     ee2:	30 91 cd 00 	lds	r19, 0x00CD
     ee6:	8b 81       	ldd	r24, Y+3	; 0x03
     ee8:	9c 81       	ldd	r25, Y+4	; 0x04
     eea:	28 0f       	add	r18, r24
     eec:	39 1f       	adc	r19, r25
     eee:	80 91 cc 00 	lds	r24, 0x00CC
     ef2:	90 91 cd 00 	lds	r25, 0x00CD
     ef6:	82 17       	cp	r24, r18
     ef8:	93 07       	cpc	r25, r19
     efa:	c0 f4       	brcc	.+48     	; 0xf2c <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     efc:	20 91 ce 00 	lds	r18, 0x00CE
     f00:	30 91 cf 00 	lds	r19, 0x00CF
     f04:	80 91 cc 00 	lds	r24, 0x00CC
     f08:	90 91 cd 00 	lds	r25, 0x00CD
     f0c:	82 0f       	add	r24, r18
     f0e:	93 1f       	adc	r25, r19
     f10:	9a 83       	std	Y+2, r25	; 0x02
     f12:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     f14:	20 91 cc 00 	lds	r18, 0x00CC
     f18:	30 91 cd 00 	lds	r19, 0x00CD
     f1c:	8b 81       	ldd	r24, Y+3	; 0x03
     f1e:	9c 81       	ldd	r25, Y+4	; 0x04
     f20:	82 0f       	add	r24, r18
     f22:	93 1f       	adc	r25, r19
     f24:	90 93 cd 00 	sts	0x00CD, r25
     f28:	80 93 cc 00 	sts	0x00CC, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     f2c:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     f30:	89 81       	ldd	r24, Y+1	; 0x01
     f32:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f34:	0f 90       	pop	r0
     f36:	0f 90       	pop	r0
     f38:	0f 90       	pop	r0
     f3a:	0f 90       	pop	r0
     f3c:	cf 91       	pop	r28
     f3e:	df 91       	pop	r29
     f40:	08 95       	ret

00000f42 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f42:	df 93       	push	r29
     f44:	cf 93       	push	r28
     f46:	00 d0       	rcall	.+0      	; 0xf48 <vPortFree+0x6>
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
     f4c:	9a 83       	std	Y+2, r25	; 0x02
     f4e:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	cf 91       	pop	r28
     f56:	df 91       	pop	r29
     f58:	08 95       	ret

00000f5a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     f5a:	df 93       	push	r29
     f5c:	cf 93       	push	r28
     f5e:	cd b7       	in	r28, 0x3d	; 61
     f60:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     f62:	10 92 cd 00 	sts	0x00CD, r1
     f66:	10 92 cc 00 	sts	0x00CC, r1
}
     f6a:	cf 91       	pop	r28
     f6c:	df 91       	pop	r29
     f6e:	08 95       	ret

00000f70 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f70:	df 93       	push	r29
     f72:	cf 93       	push	r28
     f74:	cd b7       	in	r28, 0x3d	; 61
     f76:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     f78:	20 91 cc 00 	lds	r18, 0x00CC
     f7c:	30 91 cd 00 	lds	r19, 0x00CD
     f80:	8b ed       	ldi	r24, 0xDB	; 219
     f82:	95 e0       	ldi	r25, 0x05	; 5
     f84:	82 1b       	sub	r24, r18
     f86:	93 0b       	sbc	r25, r19
}
     f88:	cf 91       	pop	r28
     f8a:	df 91       	pop	r29
     f8c:	08 95       	ret

00000f8e <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
     f8e:	af 92       	push	r10
     f90:	bf 92       	push	r11
     f92:	cf 92       	push	r12
     f94:	df 92       	push	r13
     f96:	ef 92       	push	r14
     f98:	ff 92       	push	r15
     f9a:	0f 93       	push	r16
     f9c:	df 93       	push	r29
     f9e:	cf 93       	push	r28
     fa0:	00 d0       	rcall	.+0      	; 0xfa2 <vStartIntegerMathTasks+0x14>
     fa2:	0f 92       	push	r0
     fa4:	cd b7       	in	r28, 0x3d	; 61
     fa6:	de b7       	in	r29, 0x3e	; 62
     fa8:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
     faa:	1a 82       	std	Y+2, r1	; 0x02
     fac:	19 82       	std	Y+1, r1	; 0x01
     fae:	1b c0       	rjmp	.+54     	; 0xfe6 <vStartIntegerMathTasks+0x58>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
     fb0:	89 81       	ldd	r24, Y+1	; 0x01
     fb2:	9a 81       	ldd	r25, Y+2	; 0x02
     fb4:	fc 01       	movw	r30, r24
     fb6:	e4 55       	subi	r30, 0x54	; 84
     fb8:	f9 4f       	sbci	r31, 0xF9	; 249
     fba:	85 e0       	ldi	r24, 0x05	; 5
     fbc:	98 e0       	ldi	r25, 0x08	; 8
     fbe:	20 e7       	ldi	r18, 0x70	; 112
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	b9 01       	movw	r22, r18
     fc4:	45 e5       	ldi	r20, 0x55	; 85
     fc6:	50 e0       	ldi	r21, 0x00	; 0
     fc8:	9f 01       	movw	r18, r30
     fca:	0b 81       	ldd	r16, Y+3	; 0x03
     fcc:	ee 24       	eor	r14, r14
     fce:	ff 24       	eor	r15, r15
     fd0:	cc 24       	eor	r12, r12
     fd2:	dd 24       	eor	r13, r13
     fd4:	aa 24       	eor	r10, r10
     fd6:	bb 24       	eor	r11, r11
     fd8:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <xTaskGenericCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
     fdc:	89 81       	ldd	r24, Y+1	; 0x01
     fde:	9a 81       	ldd	r25, Y+2	; 0x02
     fe0:	01 96       	adiw	r24, 0x01	; 1
     fe2:	9a 83       	std	Y+2, r25	; 0x02
     fe4:	89 83       	std	Y+1, r24	; 0x01
     fe6:	89 81       	ldd	r24, Y+1	; 0x01
     fe8:	9a 81       	ldd	r25, Y+2	; 0x02
     fea:	18 16       	cp	r1, r24
     fec:	19 06       	cpc	r1, r25
     fee:	04 f7       	brge	.-64     	; 0xfb0 <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
     ff0:	0f 90       	pop	r0
     ff2:	0f 90       	pop	r0
     ff4:	0f 90       	pop	r0
     ff6:	cf 91       	pop	r28
     ff8:	df 91       	pop	r29
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	ef 90       	pop	r14
    1000:	df 90       	pop	r13
    1002:	cf 90       	pop	r12
    1004:	bf 90       	pop	r11
    1006:	af 90       	pop	r10
    1008:	08 95       	ret

0000100a <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    100a:	df 93       	push	r29
    100c:	cf 93       	push	r28
    100e:	cd b7       	in	r28, 0x3d	; 61
    1010:	de b7       	in	r29, 0x3e	; 62
    1012:	2a 97       	sbiw	r28, 0x0a	; 10
    1014:	0f b6       	in	r0, 0x3f	; 63
    1016:	f8 94       	cli
    1018:	de bf       	out	0x3e, r29	; 62
    101a:	0f be       	out	0x3f, r0	; 63
    101c:	cd bf       	out	0x3d, r28	; 61
    101e:	9a 87       	std	Y+10, r25	; 0x0a
    1020:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    1022:	1c 82       	std	Y+4, r1	; 0x04
    1024:	1b 82       	std	Y+3, r1	; 0x03
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1026:	89 85       	ldd	r24, Y+9	; 0x09
    1028:	9a 85       	ldd	r25, Y+10	; 0x0a
    102a:	9a 83       	std	Y+2, r25	; 0x02
    102c:	89 83       	std	Y+1, r24	; 0x01
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    102e:	8b e7       	ldi	r24, 0x7B	; 123
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	a0 e0       	ldi	r26, 0x00	; 0
    1034:	b0 e0       	ldi	r27, 0x00	; 0
    1036:	8d 83       	std	Y+5, r24	; 0x05
    1038:	9e 83       	std	Y+6, r25	; 0x06
    103a:	af 83       	std	Y+7, r26	; 0x07
    103c:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    103e:	8d 81       	ldd	r24, Y+5	; 0x05
    1040:	9e 81       	ldd	r25, Y+6	; 0x06
    1042:	af 81       	ldd	r26, Y+7	; 0x07
    1044:	b8 85       	ldd	r27, Y+8	; 0x08
    1046:	89 5b       	subi	r24, 0xB9	; 185
    1048:	9b 46       	sbci	r25, 0x6B	; 107
    104a:	ac 4f       	sbci	r26, 0xFC	; 252
    104c:	bf 4f       	sbci	r27, 0xFF	; 255
    104e:	8d 83       	std	Y+5, r24	; 0x05
    1050:	9e 83       	std	Y+6, r25	; 0x06
    1052:	af 83       	std	Y+7, r26	; 0x07
    1054:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    1056:	8d 81       	ldd	r24, Y+5	; 0x05
    1058:	9e 81       	ldd	r25, Y+6	; 0x06
    105a:	af 81       	ldd	r26, Y+7	; 0x07
    105c:	b8 85       	ldd	r27, Y+8	; 0x08
    105e:	2d ef       	ldi	r18, 0xFD	; 253
    1060:	3f ef       	ldi	r19, 0xFF	; 255
    1062:	4f ef       	ldi	r20, 0xFF	; 255
    1064:	5f ef       	ldi	r21, 0xFF	; 255
    1066:	bc 01       	movw	r22, r24
    1068:	cd 01       	movw	r24, r26
    106a:	0e 94 04 1d 	call	0x3a08	; 0x3a08 <__mulsi3>
    106e:	dc 01       	movw	r26, r24
    1070:	cb 01       	movw	r24, r22
    1072:	8d 83       	std	Y+5, r24	; 0x05
    1074:	9e 83       	std	Y+6, r25	; 0x06
    1076:	af 83       	std	Y+7, r26	; 0x07
    1078:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    107a:	8d 81       	ldd	r24, Y+5	; 0x05
    107c:	9e 81       	ldd	r25, Y+6	; 0x06
    107e:	af 81       	ldd	r26, Y+7	; 0x07
    1080:	b8 85       	ldd	r27, Y+8	; 0x08
    1082:	27 e0       	ldi	r18, 0x07	; 7
    1084:	30 e0       	ldi	r19, 0x00	; 0
    1086:	40 e0       	ldi	r20, 0x00	; 0
    1088:	50 e0       	ldi	r21, 0x00	; 0
    108a:	bc 01       	movw	r22, r24
    108c:	cd 01       	movw	r24, r26
    108e:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <__divmodsi4>
    1092:	da 01       	movw	r26, r20
    1094:	c9 01       	movw	r24, r18
    1096:	8d 83       	std	Y+5, r24	; 0x05
    1098:	9e 83       	std	Y+6, r25	; 0x06
    109a:	af 83       	std	Y+7, r26	; 0x07
    109c:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    109e:	8d 81       	ldd	r24, Y+5	; 0x05
    10a0:	9e 81       	ldd	r25, Y+6	; 0x06
    10a2:	af 81       	ldd	r26, Y+7	; 0x07
    10a4:	b8 85       	ldd	r27, Y+8	; 0x08
    10a6:	8b 31       	cpi	r24, 0x1B	; 27
    10a8:	27 e7       	ldi	r18, 0x77	; 119
    10aa:	92 07       	cpc	r25, r18
    10ac:	2e ef       	ldi	r18, 0xFE	; 254
    10ae:	a2 07       	cpc	r26, r18
    10b0:	2f ef       	ldi	r18, 0xFF	; 255
    10b2:	b2 07       	cpc	r27, r18
    10b4:	21 f0       	breq	.+8      	; 0x10be <vCompeteingIntMathTask+0xb4>
		{
			sError = pdTRUE;
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	9c 83       	std	Y+4, r25	; 0x04
    10bc:	8b 83       	std	Y+3, r24	; 0x03
		}

		if( sError == pdFALSE )
    10be:	8b 81       	ldd	r24, Y+3	; 0x03
    10c0:	9c 81       	ldd	r25, Y+4	; 0x04
    10c2:	00 97       	sbiw	r24, 0x00	; 0
    10c4:	09 f0       	breq	.+2      	; 0x10c8 <vCompeteingIntMathTask+0xbe>
    10c6:	b3 cf       	rjmp	.-154    	; 0x102e <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    10c8:	0f b6       	in	r0, 0x3f	; 63
    10ca:	f8 94       	cli
    10cc:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	80 83       	st	Z, r24
			portEXIT_CRITICAL();
    10d6:	0f 90       	pop	r0
    10d8:	0f be       	out	0x3f, r0	; 63
    10da:	a9 cf       	rjmp	.-174    	; 0x102e <vCompeteingIntMathTask+0x24>

000010dc <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
    10dc:	df 93       	push	r29
    10de:	cf 93       	push	r28
    10e0:	00 d0       	rcall	.+0      	; 0x10e2 <xAreIntegerMathsTaskStillRunning+0x6>
    10e2:	0f 92       	push	r0
    10e4:	cd b7       	in	r28, 0x3d	; 61
    10e6:	de b7       	in	r29, 0x3e	; 62
BaseType_t xReturn = pdTRUE;
    10e8:	81 e0       	ldi	r24, 0x01	; 1
    10ea:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    10ec:	1a 82       	std	Y+2, r1	; 0x02
    10ee:	19 82       	std	Y+1, r1	; 0x01
    10f0:	14 c0       	rjmp	.+40     	; 0x111a <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    10f2:	89 81       	ldd	r24, Y+1	; 0x01
    10f4:	9a 81       	ldd	r25, Y+2	; 0x02
    10f6:	fc 01       	movw	r30, r24
    10f8:	e4 55       	subi	r30, 0x54	; 84
    10fa:	f9 4f       	sbci	r31, 0xF9	; 249
    10fc:	80 81       	ld	r24, Z
    10fe:	88 23       	and	r24, r24
    1100:	09 f4       	brne	.+2      	; 0x1104 <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    1102:	1b 82       	std	Y+3, r1	; 0x03
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    1104:	89 81       	ldd	r24, Y+1	; 0x01
    1106:	9a 81       	ldd	r25, Y+2	; 0x02
    1108:	fc 01       	movw	r30, r24
    110a:	e4 55       	subi	r30, 0x54	; 84
    110c:	f9 4f       	sbci	r31, 0xF9	; 249
    110e:	10 82       	st	Z, r1
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    1110:	89 81       	ldd	r24, Y+1	; 0x01
    1112:	9a 81       	ldd	r25, Y+2	; 0x02
    1114:	01 96       	adiw	r24, 0x01	; 1
    1116:	9a 83       	std	Y+2, r25	; 0x02
    1118:	89 83       	std	Y+1, r24	; 0x01
    111a:	89 81       	ldd	r24, Y+1	; 0x01
    111c:	9a 81       	ldd	r25, Y+2	; 0x02
    111e:	18 16       	cp	r1, r24
    1120:	19 06       	cpc	r1, r25
    1122:	3c f7       	brge	.-50     	; 0x10f2 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    1124:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1126:	0f 90       	pop	r0
    1128:	0f 90       	pop	r0
    112a:	0f 90       	pop	r0
    112c:	cf 91       	pop	r28
    112e:	df 91       	pop	r29
    1130:	08 95       	ret

00001132 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1132:	df 93       	push	r29
    1134:	cf 93       	push	r28
    1136:	00 d0       	rcall	.+0      	; 0x1138 <vListInitialise+0x6>
    1138:	cd b7       	in	r28, 0x3d	; 61
    113a:	de b7       	in	r29, 0x3e	; 62
    113c:	9a 83       	std	Y+2, r25	; 0x02
    113e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1140:	89 81       	ldd	r24, Y+1	; 0x01
    1142:	9a 81       	ldd	r25, Y+2	; 0x02
    1144:	03 96       	adiw	r24, 0x03	; 3
    1146:	e9 81       	ldd	r30, Y+1	; 0x01
    1148:	fa 81       	ldd	r31, Y+2	; 0x02
    114a:	92 83       	std	Z+2, r25	; 0x02
    114c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    114e:	e9 81       	ldd	r30, Y+1	; 0x01
    1150:	fa 81       	ldd	r31, Y+2	; 0x02
    1152:	8f ef       	ldi	r24, 0xFF	; 255
    1154:	9f ef       	ldi	r25, 0xFF	; 255
    1156:	94 83       	std	Z+4, r25	; 0x04
    1158:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    115a:	89 81       	ldd	r24, Y+1	; 0x01
    115c:	9a 81       	ldd	r25, Y+2	; 0x02
    115e:	03 96       	adiw	r24, 0x03	; 3
    1160:	e9 81       	ldd	r30, Y+1	; 0x01
    1162:	fa 81       	ldd	r31, Y+2	; 0x02
    1164:	96 83       	std	Z+6, r25	; 0x06
    1166:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1168:	89 81       	ldd	r24, Y+1	; 0x01
    116a:	9a 81       	ldd	r25, Y+2	; 0x02
    116c:	03 96       	adiw	r24, 0x03	; 3
    116e:	e9 81       	ldd	r30, Y+1	; 0x01
    1170:	fa 81       	ldd	r31, Y+2	; 0x02
    1172:	90 87       	std	Z+8, r25	; 0x08
    1174:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1176:	e9 81       	ldd	r30, Y+1	; 0x01
    1178:	fa 81       	ldd	r31, Y+2	; 0x02
    117a:	10 82       	st	Z, r1
}
    117c:	0f 90       	pop	r0
    117e:	0f 90       	pop	r0
    1180:	cf 91       	pop	r28
    1182:	df 91       	pop	r29
    1184:	08 95       	ret

00001186 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1186:	df 93       	push	r29
    1188:	cf 93       	push	r28
    118a:	00 d0       	rcall	.+0      	; 0x118c <vListInitialiseItem+0x6>
    118c:	cd b7       	in	r28, 0x3d	; 61
    118e:	de b7       	in	r29, 0x3e	; 62
    1190:	9a 83       	std	Y+2, r25	; 0x02
    1192:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1194:	e9 81       	ldd	r30, Y+1	; 0x01
    1196:	fa 81       	ldd	r31, Y+2	; 0x02
    1198:	11 86       	std	Z+9, r1	; 0x09
    119a:	10 86       	std	Z+8, r1	; 0x08
}
    119c:	0f 90       	pop	r0
    119e:	0f 90       	pop	r0
    11a0:	cf 91       	pop	r28
    11a2:	df 91       	pop	r29
    11a4:	08 95       	ret

000011a6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    11a6:	df 93       	push	r29
    11a8:	cf 93       	push	r28
    11aa:	00 d0       	rcall	.+0      	; 0x11ac <vListInsertEnd+0x6>
    11ac:	00 d0       	rcall	.+0      	; 0x11ae <vListInsertEnd+0x8>
    11ae:	00 d0       	rcall	.+0      	; 0x11b0 <vListInsertEnd+0xa>
    11b0:	cd b7       	in	r28, 0x3d	; 61
    11b2:	de b7       	in	r29, 0x3e	; 62
    11b4:	9c 83       	std	Y+4, r25	; 0x04
    11b6:	8b 83       	std	Y+3, r24	; 0x03
    11b8:	7e 83       	std	Y+6, r23	; 0x06
    11ba:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    11bc:	eb 81       	ldd	r30, Y+3	; 0x03
    11be:	fc 81       	ldd	r31, Y+4	; 0x04
    11c0:	81 81       	ldd	r24, Z+1	; 0x01
    11c2:	92 81       	ldd	r25, Z+2	; 0x02
    11c4:	9a 83       	std	Y+2, r25	; 0x02
    11c6:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    11c8:	ed 81       	ldd	r30, Y+5	; 0x05
    11ca:	fe 81       	ldd	r31, Y+6	; 0x06
    11cc:	89 81       	ldd	r24, Y+1	; 0x01
    11ce:	9a 81       	ldd	r25, Y+2	; 0x02
    11d0:	93 83       	std	Z+3, r25	; 0x03
    11d2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    11d4:	e9 81       	ldd	r30, Y+1	; 0x01
    11d6:	fa 81       	ldd	r31, Y+2	; 0x02
    11d8:	84 81       	ldd	r24, Z+4	; 0x04
    11da:	95 81       	ldd	r25, Z+5	; 0x05
    11dc:	ed 81       	ldd	r30, Y+5	; 0x05
    11de:	fe 81       	ldd	r31, Y+6	; 0x06
    11e0:	95 83       	std	Z+5, r25	; 0x05
    11e2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    11e4:	e9 81       	ldd	r30, Y+1	; 0x01
    11e6:	fa 81       	ldd	r31, Y+2	; 0x02
    11e8:	04 80       	ldd	r0, Z+4	; 0x04
    11ea:	f5 81       	ldd	r31, Z+5	; 0x05
    11ec:	e0 2d       	mov	r30, r0
    11ee:	8d 81       	ldd	r24, Y+5	; 0x05
    11f0:	9e 81       	ldd	r25, Y+6	; 0x06
    11f2:	93 83       	std	Z+3, r25	; 0x03
    11f4:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    11f6:	e9 81       	ldd	r30, Y+1	; 0x01
    11f8:	fa 81       	ldd	r31, Y+2	; 0x02
    11fa:	8d 81       	ldd	r24, Y+5	; 0x05
    11fc:	9e 81       	ldd	r25, Y+6	; 0x06
    11fe:	95 83       	std	Z+5, r25	; 0x05
    1200:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1202:	ed 81       	ldd	r30, Y+5	; 0x05
    1204:	fe 81       	ldd	r31, Y+6	; 0x06
    1206:	8b 81       	ldd	r24, Y+3	; 0x03
    1208:	9c 81       	ldd	r25, Y+4	; 0x04
    120a:	91 87       	std	Z+9, r25	; 0x09
    120c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    120e:	eb 81       	ldd	r30, Y+3	; 0x03
    1210:	fc 81       	ldd	r31, Y+4	; 0x04
    1212:	80 81       	ld	r24, Z
    1214:	8f 5f       	subi	r24, 0xFF	; 255
    1216:	eb 81       	ldd	r30, Y+3	; 0x03
    1218:	fc 81       	ldd	r31, Y+4	; 0x04
    121a:	80 83       	st	Z, r24
}
    121c:	26 96       	adiw	r28, 0x06	; 6
    121e:	0f b6       	in	r0, 0x3f	; 63
    1220:	f8 94       	cli
    1222:	de bf       	out	0x3e, r29	; 62
    1224:	0f be       	out	0x3f, r0	; 63
    1226:	cd bf       	out	0x3d, r28	; 61
    1228:	cf 91       	pop	r28
    122a:	df 91       	pop	r29
    122c:	08 95       	ret

0000122e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    122e:	df 93       	push	r29
    1230:	cf 93       	push	r28
    1232:	cd b7       	in	r28, 0x3d	; 61
    1234:	de b7       	in	r29, 0x3e	; 62
    1236:	28 97       	sbiw	r28, 0x08	; 8
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	de bf       	out	0x3e, r29	; 62
    123e:	0f be       	out	0x3f, r0	; 63
    1240:	cd bf       	out	0x3d, r28	; 61
    1242:	9e 83       	std	Y+6, r25	; 0x06
    1244:	8d 83       	std	Y+5, r24	; 0x05
    1246:	78 87       	std	Y+8, r23	; 0x08
    1248:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    124a:	ef 81       	ldd	r30, Y+7	; 0x07
    124c:	f8 85       	ldd	r31, Y+8	; 0x08
    124e:	80 81       	ld	r24, Z
    1250:	91 81       	ldd	r25, Z+1	; 0x01
    1252:	9a 83       	std	Y+2, r25	; 0x02
    1254:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1256:	89 81       	ldd	r24, Y+1	; 0x01
    1258:	9a 81       	ldd	r25, Y+2	; 0x02
    125a:	2f ef       	ldi	r18, 0xFF	; 255
    125c:	8f 3f       	cpi	r24, 0xFF	; 255
    125e:	92 07       	cpc	r25, r18
    1260:	39 f4       	brne	.+14     	; 0x1270 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1262:	ed 81       	ldd	r30, Y+5	; 0x05
    1264:	fe 81       	ldd	r31, Y+6	; 0x06
    1266:	87 81       	ldd	r24, Z+7	; 0x07
    1268:	90 85       	ldd	r25, Z+8	; 0x08
    126a:	9c 83       	std	Y+4, r25	; 0x04
    126c:	8b 83       	std	Y+3, r24	; 0x03
    126e:	18 c0       	rjmp	.+48     	; 0x12a0 <vListInsert+0x72>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1270:	8d 81       	ldd	r24, Y+5	; 0x05
    1272:	9e 81       	ldd	r25, Y+6	; 0x06
    1274:	03 96       	adiw	r24, 0x03	; 3
    1276:	9c 83       	std	Y+4, r25	; 0x04
    1278:	8b 83       	std	Y+3, r24	; 0x03
    127a:	06 c0       	rjmp	.+12     	; 0x1288 <vListInsert+0x5a>
    127c:	eb 81       	ldd	r30, Y+3	; 0x03
    127e:	fc 81       	ldd	r31, Y+4	; 0x04
    1280:	82 81       	ldd	r24, Z+2	; 0x02
    1282:	93 81       	ldd	r25, Z+3	; 0x03
    1284:	9c 83       	std	Y+4, r25	; 0x04
    1286:	8b 83       	std	Y+3, r24	; 0x03
    1288:	eb 81       	ldd	r30, Y+3	; 0x03
    128a:	fc 81       	ldd	r31, Y+4	; 0x04
    128c:	02 80       	ldd	r0, Z+2	; 0x02
    128e:	f3 81       	ldd	r31, Z+3	; 0x03
    1290:	e0 2d       	mov	r30, r0
    1292:	20 81       	ld	r18, Z
    1294:	31 81       	ldd	r19, Z+1	; 0x01
    1296:	89 81       	ldd	r24, Y+1	; 0x01
    1298:	9a 81       	ldd	r25, Y+2	; 0x02
    129a:	82 17       	cp	r24, r18
    129c:	93 07       	cpc	r25, r19
    129e:	70 f7       	brcc	.-36     	; 0x127c <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    12a0:	eb 81       	ldd	r30, Y+3	; 0x03
    12a2:	fc 81       	ldd	r31, Y+4	; 0x04
    12a4:	82 81       	ldd	r24, Z+2	; 0x02
    12a6:	93 81       	ldd	r25, Z+3	; 0x03
    12a8:	ef 81       	ldd	r30, Y+7	; 0x07
    12aa:	f8 85       	ldd	r31, Y+8	; 0x08
    12ac:	93 83       	std	Z+3, r25	; 0x03
    12ae:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    12b0:	ef 81       	ldd	r30, Y+7	; 0x07
    12b2:	f8 85       	ldd	r31, Y+8	; 0x08
    12b4:	02 80       	ldd	r0, Z+2	; 0x02
    12b6:	f3 81       	ldd	r31, Z+3	; 0x03
    12b8:	e0 2d       	mov	r30, r0
    12ba:	8f 81       	ldd	r24, Y+7	; 0x07
    12bc:	98 85       	ldd	r25, Y+8	; 0x08
    12be:	95 83       	std	Z+5, r25	; 0x05
    12c0:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    12c2:	ef 81       	ldd	r30, Y+7	; 0x07
    12c4:	f8 85       	ldd	r31, Y+8	; 0x08
    12c6:	8b 81       	ldd	r24, Y+3	; 0x03
    12c8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ca:	95 83       	std	Z+5, r25	; 0x05
    12cc:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    12ce:	eb 81       	ldd	r30, Y+3	; 0x03
    12d0:	fc 81       	ldd	r31, Y+4	; 0x04
    12d2:	8f 81       	ldd	r24, Y+7	; 0x07
    12d4:	98 85       	ldd	r25, Y+8	; 0x08
    12d6:	93 83       	std	Z+3, r25	; 0x03
    12d8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    12da:	ef 81       	ldd	r30, Y+7	; 0x07
    12dc:	f8 85       	ldd	r31, Y+8	; 0x08
    12de:	8d 81       	ldd	r24, Y+5	; 0x05
    12e0:	9e 81       	ldd	r25, Y+6	; 0x06
    12e2:	91 87       	std	Z+9, r25	; 0x09
    12e4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    12e6:	ed 81       	ldd	r30, Y+5	; 0x05
    12e8:	fe 81       	ldd	r31, Y+6	; 0x06
    12ea:	80 81       	ld	r24, Z
    12ec:	8f 5f       	subi	r24, 0xFF	; 255
    12ee:	ed 81       	ldd	r30, Y+5	; 0x05
    12f0:	fe 81       	ldd	r31, Y+6	; 0x06
    12f2:	80 83       	st	Z, r24
}
    12f4:	28 96       	adiw	r28, 0x08	; 8
    12f6:	0f b6       	in	r0, 0x3f	; 63
    12f8:	f8 94       	cli
    12fa:	de bf       	out	0x3e, r29	; 62
    12fc:	0f be       	out	0x3f, r0	; 63
    12fe:	cd bf       	out	0x3d, r28	; 61
    1300:	cf 91       	pop	r28
    1302:	df 91       	pop	r29
    1304:	08 95       	ret

00001306 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1306:	df 93       	push	r29
    1308:	cf 93       	push	r28
    130a:	00 d0       	rcall	.+0      	; 0x130c <uxListRemove+0x6>
    130c:	00 d0       	rcall	.+0      	; 0x130e <uxListRemove+0x8>
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	9c 83       	std	Y+4, r25	; 0x04
    1314:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1316:	eb 81       	ldd	r30, Y+3	; 0x03
    1318:	fc 81       	ldd	r31, Y+4	; 0x04
    131a:	80 85       	ldd	r24, Z+8	; 0x08
    131c:	91 85       	ldd	r25, Z+9	; 0x09
    131e:	9a 83       	std	Y+2, r25	; 0x02
    1320:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1322:	eb 81       	ldd	r30, Y+3	; 0x03
    1324:	fc 81       	ldd	r31, Y+4	; 0x04
    1326:	a2 81       	ldd	r26, Z+2	; 0x02
    1328:	b3 81       	ldd	r27, Z+3	; 0x03
    132a:	eb 81       	ldd	r30, Y+3	; 0x03
    132c:	fc 81       	ldd	r31, Y+4	; 0x04
    132e:	84 81       	ldd	r24, Z+4	; 0x04
    1330:	95 81       	ldd	r25, Z+5	; 0x05
    1332:	15 96       	adiw	r26, 0x05	; 5
    1334:	9c 93       	st	X, r25
    1336:	8e 93       	st	-X, r24
    1338:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    133a:	eb 81       	ldd	r30, Y+3	; 0x03
    133c:	fc 81       	ldd	r31, Y+4	; 0x04
    133e:	a4 81       	ldd	r26, Z+4	; 0x04
    1340:	b5 81       	ldd	r27, Z+5	; 0x05
    1342:	eb 81       	ldd	r30, Y+3	; 0x03
    1344:	fc 81       	ldd	r31, Y+4	; 0x04
    1346:	82 81       	ldd	r24, Z+2	; 0x02
    1348:	93 81       	ldd	r25, Z+3	; 0x03
    134a:	13 96       	adiw	r26, 0x03	; 3
    134c:	9c 93       	st	X, r25
    134e:	8e 93       	st	-X, r24
    1350:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1352:	e9 81       	ldd	r30, Y+1	; 0x01
    1354:	fa 81       	ldd	r31, Y+2	; 0x02
    1356:	21 81       	ldd	r18, Z+1	; 0x01
    1358:	32 81       	ldd	r19, Z+2	; 0x02
    135a:	8b 81       	ldd	r24, Y+3	; 0x03
    135c:	9c 81       	ldd	r25, Y+4	; 0x04
    135e:	28 17       	cp	r18, r24
    1360:	39 07       	cpc	r19, r25
    1362:	41 f4       	brne	.+16     	; 0x1374 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1364:	eb 81       	ldd	r30, Y+3	; 0x03
    1366:	fc 81       	ldd	r31, Y+4	; 0x04
    1368:	84 81       	ldd	r24, Z+4	; 0x04
    136a:	95 81       	ldd	r25, Z+5	; 0x05
    136c:	e9 81       	ldd	r30, Y+1	; 0x01
    136e:	fa 81       	ldd	r31, Y+2	; 0x02
    1370:	92 83       	std	Z+2, r25	; 0x02
    1372:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1374:	eb 81       	ldd	r30, Y+3	; 0x03
    1376:	fc 81       	ldd	r31, Y+4	; 0x04
    1378:	11 86       	std	Z+9, r1	; 0x09
    137a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    137c:	e9 81       	ldd	r30, Y+1	; 0x01
    137e:	fa 81       	ldd	r31, Y+2	; 0x02
    1380:	80 81       	ld	r24, Z
    1382:	81 50       	subi	r24, 0x01	; 1
    1384:	e9 81       	ldd	r30, Y+1	; 0x01
    1386:	fa 81       	ldd	r31, Y+2	; 0x02
    1388:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    138a:	e9 81       	ldd	r30, Y+1	; 0x01
    138c:	fa 81       	ldd	r31, Y+2	; 0x02
    138e:	80 81       	ld	r24, Z
}
    1390:	0f 90       	pop	r0
    1392:	0f 90       	pop	r0
    1394:	0f 90       	pop	r0
    1396:	0f 90       	pop	r0
    1398:	cf 91       	pop	r28
    139a:	df 91       	pop	r29
    139c:	08 95       	ret

0000139e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    139e:	df 93       	push	r29
    13a0:	cf 93       	push	r28
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
    13a6:	28 97       	sbiw	r28, 0x08	; 8
    13a8:	0f b6       	in	r0, 0x3f	; 63
    13aa:	f8 94       	cli
    13ac:	de bf       	out	0x3e, r29	; 62
    13ae:	0f be       	out	0x3f, r0	; 63
    13b0:	cd bf       	out	0x3d, r28	; 61
    13b2:	9c 83       	std	Y+4, r25	; 0x04
    13b4:	8b 83       	std	Y+3, r24	; 0x03
    13b6:	7e 83       	std	Y+6, r23	; 0x06
    13b8:	6d 83       	std	Y+5, r22	; 0x05
    13ba:	58 87       	std	Y+8, r21	; 0x08
    13bc:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    13be:	eb 81       	ldd	r30, Y+3	; 0x03
    13c0:	fc 81       	ldd	r31, Y+4	; 0x04
    13c2:	81 e1       	ldi	r24, 0x11	; 17
    13c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    13c6:	8b 81       	ldd	r24, Y+3	; 0x03
    13c8:	9c 81       	ldd	r25, Y+4	; 0x04
    13ca:	01 97       	sbiw	r24, 0x01	; 1
    13cc:	9c 83       	std	Y+4, r25	; 0x04
    13ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    13d0:	eb 81       	ldd	r30, Y+3	; 0x03
    13d2:	fc 81       	ldd	r31, Y+4	; 0x04
    13d4:	82 e2       	ldi	r24, 0x22	; 34
    13d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    13d8:	8b 81       	ldd	r24, Y+3	; 0x03
    13da:	9c 81       	ldd	r25, Y+4	; 0x04
    13dc:	01 97       	sbiw	r24, 0x01	; 1
    13de:	9c 83       	std	Y+4, r25	; 0x04
    13e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    13e2:	eb 81       	ldd	r30, Y+3	; 0x03
    13e4:	fc 81       	ldd	r31, Y+4	; 0x04
    13e6:	83 e3       	ldi	r24, 0x33	; 51
    13e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ea:	8b 81       	ldd	r24, Y+3	; 0x03
    13ec:	9c 81       	ldd	r25, Y+4	; 0x04
    13ee:	01 97       	sbiw	r24, 0x01	; 1
    13f0:	9c 83       	std	Y+4, r25	; 0x04
    13f2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    13f4:	8d 81       	ldd	r24, Y+5	; 0x05
    13f6:	9e 81       	ldd	r25, Y+6	; 0x06
    13f8:	9a 83       	std	Y+2, r25	; 0x02
    13fa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    13fc:	89 81       	ldd	r24, Y+1	; 0x01
    13fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1400:	fc 81       	ldd	r31, Y+4	; 0x04
    1402:	80 83       	st	Z, r24
	pxTopOfStack--;
    1404:	8b 81       	ldd	r24, Y+3	; 0x03
    1406:	9c 81       	ldd	r25, Y+4	; 0x04
    1408:	01 97       	sbiw	r24, 0x01	; 1
    140a:	9c 83       	std	Y+4, r25	; 0x04
    140c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    140e:	89 81       	ldd	r24, Y+1	; 0x01
    1410:	9a 81       	ldd	r25, Y+2	; 0x02
    1412:	89 2f       	mov	r24, r25
    1414:	99 27       	eor	r25, r25
    1416:	9a 83       	std	Y+2, r25	; 0x02
    1418:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    141a:	89 81       	ldd	r24, Y+1	; 0x01
    141c:	eb 81       	ldd	r30, Y+3	; 0x03
    141e:	fc 81       	ldd	r31, Y+4	; 0x04
    1420:	80 83       	st	Z, r24
	pxTopOfStack--;
    1422:	8b 81       	ldd	r24, Y+3	; 0x03
    1424:	9c 81       	ldd	r25, Y+4	; 0x04
    1426:	01 97       	sbiw	r24, 0x01	; 1
    1428:	9c 83       	std	Y+4, r25	; 0x04
    142a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    142c:	eb 81       	ldd	r30, Y+3	; 0x03
    142e:	fc 81       	ldd	r31, Y+4	; 0x04
    1430:	10 82       	st	Z, r1
	pxTopOfStack--;
    1432:	8b 81       	ldd	r24, Y+3	; 0x03
    1434:	9c 81       	ldd	r25, Y+4	; 0x04
    1436:	01 97       	sbiw	r24, 0x01	; 1
    1438:	9c 83       	std	Y+4, r25	; 0x04
    143a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    143c:	eb 81       	ldd	r30, Y+3	; 0x03
    143e:	fc 81       	ldd	r31, Y+4	; 0x04
    1440:	80 e8       	ldi	r24, 0x80	; 128
    1442:	80 83       	st	Z, r24
	pxTopOfStack--;
    1444:	8b 81       	ldd	r24, Y+3	; 0x03
    1446:	9c 81       	ldd	r25, Y+4	; 0x04
    1448:	01 97       	sbiw	r24, 0x01	; 1
    144a:	9c 83       	std	Y+4, r25	; 0x04
    144c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    144e:	eb 81       	ldd	r30, Y+3	; 0x03
    1450:	fc 81       	ldd	r31, Y+4	; 0x04
    1452:	10 82       	st	Z, r1
	pxTopOfStack--;
    1454:	8b 81       	ldd	r24, Y+3	; 0x03
    1456:	9c 81       	ldd	r25, Y+4	; 0x04
    1458:	01 97       	sbiw	r24, 0x01	; 1
    145a:	9c 83       	std	Y+4, r25	; 0x04
    145c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    145e:	eb 81       	ldd	r30, Y+3	; 0x03
    1460:	fc 81       	ldd	r31, Y+4	; 0x04
    1462:	82 e0       	ldi	r24, 0x02	; 2
    1464:	80 83       	st	Z, r24
	pxTopOfStack--;
    1466:	8b 81       	ldd	r24, Y+3	; 0x03
    1468:	9c 81       	ldd	r25, Y+4	; 0x04
    146a:	01 97       	sbiw	r24, 0x01	; 1
    146c:	9c 83       	std	Y+4, r25	; 0x04
    146e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1470:	eb 81       	ldd	r30, Y+3	; 0x03
    1472:	fc 81       	ldd	r31, Y+4	; 0x04
    1474:	83 e0       	ldi	r24, 0x03	; 3
    1476:	80 83       	st	Z, r24
	pxTopOfStack--;
    1478:	8b 81       	ldd	r24, Y+3	; 0x03
    147a:	9c 81       	ldd	r25, Y+4	; 0x04
    147c:	01 97       	sbiw	r24, 0x01	; 1
    147e:	9c 83       	std	Y+4, r25	; 0x04
    1480:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1482:	eb 81       	ldd	r30, Y+3	; 0x03
    1484:	fc 81       	ldd	r31, Y+4	; 0x04
    1486:	84 e0       	ldi	r24, 0x04	; 4
    1488:	80 83       	st	Z, r24
	pxTopOfStack--;
    148a:	8b 81       	ldd	r24, Y+3	; 0x03
    148c:	9c 81       	ldd	r25, Y+4	; 0x04
    148e:	01 97       	sbiw	r24, 0x01	; 1
    1490:	9c 83       	std	Y+4, r25	; 0x04
    1492:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1494:	eb 81       	ldd	r30, Y+3	; 0x03
    1496:	fc 81       	ldd	r31, Y+4	; 0x04
    1498:	85 e0       	ldi	r24, 0x05	; 5
    149a:	80 83       	st	Z, r24
	pxTopOfStack--;
    149c:	8b 81       	ldd	r24, Y+3	; 0x03
    149e:	9c 81       	ldd	r25, Y+4	; 0x04
    14a0:	01 97       	sbiw	r24, 0x01	; 1
    14a2:	9c 83       	std	Y+4, r25	; 0x04
    14a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    14a6:	eb 81       	ldd	r30, Y+3	; 0x03
    14a8:	fc 81       	ldd	r31, Y+4	; 0x04
    14aa:	86 e0       	ldi	r24, 0x06	; 6
    14ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ae:	8b 81       	ldd	r24, Y+3	; 0x03
    14b0:	9c 81       	ldd	r25, Y+4	; 0x04
    14b2:	01 97       	sbiw	r24, 0x01	; 1
    14b4:	9c 83       	std	Y+4, r25	; 0x04
    14b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    14b8:	eb 81       	ldd	r30, Y+3	; 0x03
    14ba:	fc 81       	ldd	r31, Y+4	; 0x04
    14bc:	87 e0       	ldi	r24, 0x07	; 7
    14be:	80 83       	st	Z, r24
	pxTopOfStack--;
    14c0:	8b 81       	ldd	r24, Y+3	; 0x03
    14c2:	9c 81       	ldd	r25, Y+4	; 0x04
    14c4:	01 97       	sbiw	r24, 0x01	; 1
    14c6:	9c 83       	std	Y+4, r25	; 0x04
    14c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    14ca:	eb 81       	ldd	r30, Y+3	; 0x03
    14cc:	fc 81       	ldd	r31, Y+4	; 0x04
    14ce:	88 e0       	ldi	r24, 0x08	; 8
    14d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    14d2:	8b 81       	ldd	r24, Y+3	; 0x03
    14d4:	9c 81       	ldd	r25, Y+4	; 0x04
    14d6:	01 97       	sbiw	r24, 0x01	; 1
    14d8:	9c 83       	std	Y+4, r25	; 0x04
    14da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    14dc:	eb 81       	ldd	r30, Y+3	; 0x03
    14de:	fc 81       	ldd	r31, Y+4	; 0x04
    14e0:	89 e0       	ldi	r24, 0x09	; 9
    14e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    14e4:	8b 81       	ldd	r24, Y+3	; 0x03
    14e6:	9c 81       	ldd	r25, Y+4	; 0x04
    14e8:	01 97       	sbiw	r24, 0x01	; 1
    14ea:	9c 83       	std	Y+4, r25	; 0x04
    14ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    14ee:	eb 81       	ldd	r30, Y+3	; 0x03
    14f0:	fc 81       	ldd	r31, Y+4	; 0x04
    14f2:	80 e1       	ldi	r24, 0x10	; 16
    14f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    14f6:	8b 81       	ldd	r24, Y+3	; 0x03
    14f8:	9c 81       	ldd	r25, Y+4	; 0x04
    14fa:	01 97       	sbiw	r24, 0x01	; 1
    14fc:	9c 83       	std	Y+4, r25	; 0x04
    14fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1500:	eb 81       	ldd	r30, Y+3	; 0x03
    1502:	fc 81       	ldd	r31, Y+4	; 0x04
    1504:	81 e1       	ldi	r24, 0x11	; 17
    1506:	80 83       	st	Z, r24
	pxTopOfStack--;
    1508:	8b 81       	ldd	r24, Y+3	; 0x03
    150a:	9c 81       	ldd	r25, Y+4	; 0x04
    150c:	01 97       	sbiw	r24, 0x01	; 1
    150e:	9c 83       	std	Y+4, r25	; 0x04
    1510:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1512:	eb 81       	ldd	r30, Y+3	; 0x03
    1514:	fc 81       	ldd	r31, Y+4	; 0x04
    1516:	82 e1       	ldi	r24, 0x12	; 18
    1518:	80 83       	st	Z, r24
	pxTopOfStack--;
    151a:	8b 81       	ldd	r24, Y+3	; 0x03
    151c:	9c 81       	ldd	r25, Y+4	; 0x04
    151e:	01 97       	sbiw	r24, 0x01	; 1
    1520:	9c 83       	std	Y+4, r25	; 0x04
    1522:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1524:	eb 81       	ldd	r30, Y+3	; 0x03
    1526:	fc 81       	ldd	r31, Y+4	; 0x04
    1528:	83 e1       	ldi	r24, 0x13	; 19
    152a:	80 83       	st	Z, r24
	pxTopOfStack--;
    152c:	8b 81       	ldd	r24, Y+3	; 0x03
    152e:	9c 81       	ldd	r25, Y+4	; 0x04
    1530:	01 97       	sbiw	r24, 0x01	; 1
    1532:	9c 83       	std	Y+4, r25	; 0x04
    1534:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1536:	eb 81       	ldd	r30, Y+3	; 0x03
    1538:	fc 81       	ldd	r31, Y+4	; 0x04
    153a:	84 e1       	ldi	r24, 0x14	; 20
    153c:	80 83       	st	Z, r24
	pxTopOfStack--;
    153e:	8b 81       	ldd	r24, Y+3	; 0x03
    1540:	9c 81       	ldd	r25, Y+4	; 0x04
    1542:	01 97       	sbiw	r24, 0x01	; 1
    1544:	9c 83       	std	Y+4, r25	; 0x04
    1546:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1548:	eb 81       	ldd	r30, Y+3	; 0x03
    154a:	fc 81       	ldd	r31, Y+4	; 0x04
    154c:	85 e1       	ldi	r24, 0x15	; 21
    154e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1550:	8b 81       	ldd	r24, Y+3	; 0x03
    1552:	9c 81       	ldd	r25, Y+4	; 0x04
    1554:	01 97       	sbiw	r24, 0x01	; 1
    1556:	9c 83       	std	Y+4, r25	; 0x04
    1558:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    155a:	eb 81       	ldd	r30, Y+3	; 0x03
    155c:	fc 81       	ldd	r31, Y+4	; 0x04
    155e:	86 e1       	ldi	r24, 0x16	; 22
    1560:	80 83       	st	Z, r24
	pxTopOfStack--;
    1562:	8b 81       	ldd	r24, Y+3	; 0x03
    1564:	9c 81       	ldd	r25, Y+4	; 0x04
    1566:	01 97       	sbiw	r24, 0x01	; 1
    1568:	9c 83       	std	Y+4, r25	; 0x04
    156a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    156c:	eb 81       	ldd	r30, Y+3	; 0x03
    156e:	fc 81       	ldd	r31, Y+4	; 0x04
    1570:	87 e1       	ldi	r24, 0x17	; 23
    1572:	80 83       	st	Z, r24
	pxTopOfStack--;
    1574:	8b 81       	ldd	r24, Y+3	; 0x03
    1576:	9c 81       	ldd	r25, Y+4	; 0x04
    1578:	01 97       	sbiw	r24, 0x01	; 1
    157a:	9c 83       	std	Y+4, r25	; 0x04
    157c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    157e:	eb 81       	ldd	r30, Y+3	; 0x03
    1580:	fc 81       	ldd	r31, Y+4	; 0x04
    1582:	88 e1       	ldi	r24, 0x18	; 24
    1584:	80 83       	st	Z, r24
	pxTopOfStack--;
    1586:	8b 81       	ldd	r24, Y+3	; 0x03
    1588:	9c 81       	ldd	r25, Y+4	; 0x04
    158a:	01 97       	sbiw	r24, 0x01	; 1
    158c:	9c 83       	std	Y+4, r25	; 0x04
    158e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1590:	eb 81       	ldd	r30, Y+3	; 0x03
    1592:	fc 81       	ldd	r31, Y+4	; 0x04
    1594:	89 e1       	ldi	r24, 0x19	; 25
    1596:	80 83       	st	Z, r24
	pxTopOfStack--;
    1598:	8b 81       	ldd	r24, Y+3	; 0x03
    159a:	9c 81       	ldd	r25, Y+4	; 0x04
    159c:	01 97       	sbiw	r24, 0x01	; 1
    159e:	9c 83       	std	Y+4, r25	; 0x04
    15a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	80 e2       	ldi	r24, 0x20	; 32
    15a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15aa:	8b 81       	ldd	r24, Y+3	; 0x03
    15ac:	9c 81       	ldd	r25, Y+4	; 0x04
    15ae:	01 97       	sbiw	r24, 0x01	; 1
    15b0:	9c 83       	std	Y+4, r25	; 0x04
    15b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    15b4:	eb 81       	ldd	r30, Y+3	; 0x03
    15b6:	fc 81       	ldd	r31, Y+4	; 0x04
    15b8:	81 e2       	ldi	r24, 0x21	; 33
    15ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    15bc:	8b 81       	ldd	r24, Y+3	; 0x03
    15be:	9c 81       	ldd	r25, Y+4	; 0x04
    15c0:	01 97       	sbiw	r24, 0x01	; 1
    15c2:	9c 83       	std	Y+4, r25	; 0x04
    15c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    15c6:	eb 81       	ldd	r30, Y+3	; 0x03
    15c8:	fc 81       	ldd	r31, Y+4	; 0x04
    15ca:	82 e2       	ldi	r24, 0x22	; 34
    15cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ce:	8b 81       	ldd	r24, Y+3	; 0x03
    15d0:	9c 81       	ldd	r25, Y+4	; 0x04
    15d2:	01 97       	sbiw	r24, 0x01	; 1
    15d4:	9c 83       	std	Y+4, r25	; 0x04
    15d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    15d8:	eb 81       	ldd	r30, Y+3	; 0x03
    15da:	fc 81       	ldd	r31, Y+4	; 0x04
    15dc:	83 e2       	ldi	r24, 0x23	; 35
    15de:	80 83       	st	Z, r24
	pxTopOfStack--;
    15e0:	8b 81       	ldd	r24, Y+3	; 0x03
    15e2:	9c 81       	ldd	r25, Y+4	; 0x04
    15e4:	01 97       	sbiw	r24, 0x01	; 1
    15e6:	9c 83       	std	Y+4, r25	; 0x04
    15e8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    15ea:	8f 81       	ldd	r24, Y+7	; 0x07
    15ec:	98 85       	ldd	r25, Y+8	; 0x08
    15ee:	9a 83       	std	Y+2, r25	; 0x02
    15f0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	eb 81       	ldd	r30, Y+3	; 0x03
    15f6:	fc 81       	ldd	r31, Y+4	; 0x04
    15f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15fa:	8b 81       	ldd	r24, Y+3	; 0x03
    15fc:	9c 81       	ldd	r25, Y+4	; 0x04
    15fe:	01 97       	sbiw	r24, 0x01	; 1
    1600:	9c 83       	std	Y+4, r25	; 0x04
    1602:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1604:	89 81       	ldd	r24, Y+1	; 0x01
    1606:	9a 81       	ldd	r25, Y+2	; 0x02
    1608:	89 2f       	mov	r24, r25
    160a:	99 27       	eor	r25, r25
    160c:	9a 83       	std	Y+2, r25	; 0x02
    160e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1610:	89 81       	ldd	r24, Y+1	; 0x01
    1612:	eb 81       	ldd	r30, Y+3	; 0x03
    1614:	fc 81       	ldd	r31, Y+4	; 0x04
    1616:	80 83       	st	Z, r24
	pxTopOfStack--;
    1618:	8b 81       	ldd	r24, Y+3	; 0x03
    161a:	9c 81       	ldd	r25, Y+4	; 0x04
    161c:	01 97       	sbiw	r24, 0x01	; 1
    161e:	9c 83       	std	Y+4, r25	; 0x04
    1620:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1622:	eb 81       	ldd	r30, Y+3	; 0x03
    1624:	fc 81       	ldd	r31, Y+4	; 0x04
    1626:	86 e2       	ldi	r24, 0x26	; 38
    1628:	80 83       	st	Z, r24
	pxTopOfStack--;
    162a:	8b 81       	ldd	r24, Y+3	; 0x03
    162c:	9c 81       	ldd	r25, Y+4	; 0x04
    162e:	01 97       	sbiw	r24, 0x01	; 1
    1630:	9c 83       	std	Y+4, r25	; 0x04
    1632:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1634:	eb 81       	ldd	r30, Y+3	; 0x03
    1636:	fc 81       	ldd	r31, Y+4	; 0x04
    1638:	87 e2       	ldi	r24, 0x27	; 39
    163a:	80 83       	st	Z, r24
	pxTopOfStack--;
    163c:	8b 81       	ldd	r24, Y+3	; 0x03
    163e:	9c 81       	ldd	r25, Y+4	; 0x04
    1640:	01 97       	sbiw	r24, 0x01	; 1
    1642:	9c 83       	std	Y+4, r25	; 0x04
    1644:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1646:	eb 81       	ldd	r30, Y+3	; 0x03
    1648:	fc 81       	ldd	r31, Y+4	; 0x04
    164a:	88 e2       	ldi	r24, 0x28	; 40
    164c:	80 83       	st	Z, r24
	pxTopOfStack--;
    164e:	8b 81       	ldd	r24, Y+3	; 0x03
    1650:	9c 81       	ldd	r25, Y+4	; 0x04
    1652:	01 97       	sbiw	r24, 0x01	; 1
    1654:	9c 83       	std	Y+4, r25	; 0x04
    1656:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1658:	eb 81       	ldd	r30, Y+3	; 0x03
    165a:	fc 81       	ldd	r31, Y+4	; 0x04
    165c:	89 e2       	ldi	r24, 0x29	; 41
    165e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1660:	8b 81       	ldd	r24, Y+3	; 0x03
    1662:	9c 81       	ldd	r25, Y+4	; 0x04
    1664:	01 97       	sbiw	r24, 0x01	; 1
    1666:	9c 83       	std	Y+4, r25	; 0x04
    1668:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    166a:	eb 81       	ldd	r30, Y+3	; 0x03
    166c:	fc 81       	ldd	r31, Y+4	; 0x04
    166e:	80 e3       	ldi	r24, 0x30	; 48
    1670:	80 83       	st	Z, r24
	pxTopOfStack--;
    1672:	8b 81       	ldd	r24, Y+3	; 0x03
    1674:	9c 81       	ldd	r25, Y+4	; 0x04
    1676:	01 97       	sbiw	r24, 0x01	; 1
    1678:	9c 83       	std	Y+4, r25	; 0x04
    167a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    167c:	eb 81       	ldd	r30, Y+3	; 0x03
    167e:	fc 81       	ldd	r31, Y+4	; 0x04
    1680:	81 e3       	ldi	r24, 0x31	; 49
    1682:	80 83       	st	Z, r24
	pxTopOfStack--;
    1684:	8b 81       	ldd	r24, Y+3	; 0x03
    1686:	9c 81       	ldd	r25, Y+4	; 0x04
    1688:	01 97       	sbiw	r24, 0x01	; 1
    168a:	9c 83       	std	Y+4, r25	; 0x04
    168c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    168e:	8b 81       	ldd	r24, Y+3	; 0x03
    1690:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1692:	28 96       	adiw	r28, 0x08	; 8
    1694:	0f b6       	in	r0, 0x3f	; 63
    1696:	f8 94       	cli
    1698:	de bf       	out	0x3e, r29	; 62
    169a:	0f be       	out	0x3f, r0	; 63
    169c:	cd bf       	out	0x3d, r28	; 61
    169e:	cf 91       	pop	r28
    16a0:	df 91       	pop	r29
    16a2:	08 95       	ret

000016a4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    16a4:	df 93       	push	r29
    16a6:	cf 93       	push	r28
    16a8:	cd b7       	in	r28, 0x3d	; 61
    16aa:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    16ac:	0e 94 44 0c 	call	0x1888	; 0x1888 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    16b0:	a0 91 ad 06 	lds	r26, 0x06AD
    16b4:	b0 91 ae 06 	lds	r27, 0x06AE
    16b8:	cd 91       	ld	r28, X+
    16ba:	cd bf       	out	0x3d, r28	; 61
    16bc:	dd 91       	ld	r29, X+
    16be:	de bf       	out	0x3e, r29	; 62
    16c0:	ff 91       	pop	r31
    16c2:	ef 91       	pop	r30
    16c4:	df 91       	pop	r29
    16c6:	cf 91       	pop	r28
    16c8:	bf 91       	pop	r27
    16ca:	af 91       	pop	r26
    16cc:	9f 91       	pop	r25
    16ce:	8f 91       	pop	r24
    16d0:	7f 91       	pop	r23
    16d2:	6f 91       	pop	r22
    16d4:	5f 91       	pop	r21
    16d6:	4f 91       	pop	r20
    16d8:	3f 91       	pop	r19
    16da:	2f 91       	pop	r18
    16dc:	1f 91       	pop	r17
    16de:	0f 91       	pop	r16
    16e0:	ff 90       	pop	r15
    16e2:	ef 90       	pop	r14
    16e4:	df 90       	pop	r13
    16e6:	cf 90       	pop	r12
    16e8:	bf 90       	pop	r11
    16ea:	af 90       	pop	r10
    16ec:	9f 90       	pop	r9
    16ee:	8f 90       	pop	r8
    16f0:	7f 90       	pop	r7
    16f2:	6f 90       	pop	r6
    16f4:	5f 90       	pop	r5
    16f6:	4f 90       	pop	r4
    16f8:	3f 90       	pop	r3
    16fa:	2f 90       	pop	r2
    16fc:	1f 90       	pop	r1
    16fe:	0f 90       	pop	r0
    1700:	0f be       	out	0x3f, r0	; 63
    1702:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1704:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1706:	81 e0       	ldi	r24, 0x01	; 1
}
    1708:	cf 91       	pop	r28
    170a:	df 91       	pop	r29
    170c:	08 95       	ret

0000170e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    170e:	df 93       	push	r29
    1710:	cf 93       	push	r28
    1712:	cd b7       	in	r28, 0x3d	; 61
    1714:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1716:	cf 91       	pop	r28
    1718:	df 91       	pop	r29
    171a:	08 95       	ret

0000171c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    171c:	0f 92       	push	r0
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	0f 92       	push	r0
    1724:	1f 92       	push	r1
    1726:	11 24       	eor	r1, r1
    1728:	2f 92       	push	r2
    172a:	3f 92       	push	r3
    172c:	4f 92       	push	r4
    172e:	5f 92       	push	r5
    1730:	6f 92       	push	r6
    1732:	7f 92       	push	r7
    1734:	8f 92       	push	r8
    1736:	9f 92       	push	r9
    1738:	af 92       	push	r10
    173a:	bf 92       	push	r11
    173c:	cf 92       	push	r12
    173e:	df 92       	push	r13
    1740:	ef 92       	push	r14
    1742:	ff 92       	push	r15
    1744:	0f 93       	push	r16
    1746:	1f 93       	push	r17
    1748:	2f 93       	push	r18
    174a:	3f 93       	push	r19
    174c:	4f 93       	push	r20
    174e:	5f 93       	push	r21
    1750:	6f 93       	push	r22
    1752:	7f 93       	push	r23
    1754:	8f 93       	push	r24
    1756:	9f 93       	push	r25
    1758:	af 93       	push	r26
    175a:	bf 93       	push	r27
    175c:	cf 93       	push	r28
    175e:	df 93       	push	r29
    1760:	ef 93       	push	r30
    1762:	ff 93       	push	r31
    1764:	a0 91 ad 06 	lds	r26, 0x06AD
    1768:	b0 91 ae 06 	lds	r27, 0x06AE
    176c:	0d b6       	in	r0, 0x3d	; 61
    176e:	0d 92       	st	X+, r0
    1770:	0e b6       	in	r0, 0x3e	; 62
    1772:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1774:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1778:	a0 91 ad 06 	lds	r26, 0x06AD
    177c:	b0 91 ae 06 	lds	r27, 0x06AE
    1780:	cd 91       	ld	r28, X+
    1782:	cd bf       	out	0x3d, r28	; 61
    1784:	dd 91       	ld	r29, X+
    1786:	de bf       	out	0x3e, r29	; 62
    1788:	ff 91       	pop	r31
    178a:	ef 91       	pop	r30
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	bf 91       	pop	r27
    1792:	af 91       	pop	r26
    1794:	9f 91       	pop	r25
    1796:	8f 91       	pop	r24
    1798:	7f 91       	pop	r23
    179a:	6f 91       	pop	r22
    179c:	5f 91       	pop	r21
    179e:	4f 91       	pop	r20
    17a0:	3f 91       	pop	r19
    17a2:	2f 91       	pop	r18
    17a4:	1f 91       	pop	r17
    17a6:	0f 91       	pop	r16
    17a8:	ff 90       	pop	r15
    17aa:	ef 90       	pop	r14
    17ac:	df 90       	pop	r13
    17ae:	cf 90       	pop	r12
    17b0:	bf 90       	pop	r11
    17b2:	af 90       	pop	r10
    17b4:	9f 90       	pop	r9
    17b6:	8f 90       	pop	r8
    17b8:	7f 90       	pop	r7
    17ba:	6f 90       	pop	r6
    17bc:	5f 90       	pop	r5
    17be:	4f 90       	pop	r4
    17c0:	3f 90       	pop	r3
    17c2:	2f 90       	pop	r2
    17c4:	1f 90       	pop	r1
    17c6:	0f 90       	pop	r0
    17c8:	0f be       	out	0x3f, r0	; 63
    17ca:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17cc:	08 95       	ret

000017ce <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17ce:	0f 92       	push	r0
    17d0:	0f b6       	in	r0, 0x3f	; 63
    17d2:	f8 94       	cli
    17d4:	0f 92       	push	r0
    17d6:	1f 92       	push	r1
    17d8:	11 24       	eor	r1, r1
    17da:	2f 92       	push	r2
    17dc:	3f 92       	push	r3
    17de:	4f 92       	push	r4
    17e0:	5f 92       	push	r5
    17e2:	6f 92       	push	r6
    17e4:	7f 92       	push	r7
    17e6:	8f 92       	push	r8
    17e8:	9f 92       	push	r9
    17ea:	af 92       	push	r10
    17ec:	bf 92       	push	r11
    17ee:	cf 92       	push	r12
    17f0:	df 92       	push	r13
    17f2:	ef 92       	push	r14
    17f4:	ff 92       	push	r15
    17f6:	0f 93       	push	r16
    17f8:	1f 93       	push	r17
    17fa:	2f 93       	push	r18
    17fc:	3f 93       	push	r19
    17fe:	4f 93       	push	r20
    1800:	5f 93       	push	r21
    1802:	6f 93       	push	r22
    1804:	7f 93       	push	r23
    1806:	8f 93       	push	r24
    1808:	9f 93       	push	r25
    180a:	af 93       	push	r26
    180c:	bf 93       	push	r27
    180e:	cf 93       	push	r28
    1810:	df 93       	push	r29
    1812:	ef 93       	push	r30
    1814:	ff 93       	push	r31
    1816:	a0 91 ad 06 	lds	r26, 0x06AD
    181a:	b0 91 ae 06 	lds	r27, 0x06AE
    181e:	0d b6       	in	r0, 0x3d	; 61
    1820:	0d 92       	st	X+, r0
    1822:	0e b6       	in	r0, 0x3e	; 62
    1824:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1826:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <xTaskIncrementTick>
    182a:	88 23       	and	r24, r24
    182c:	11 f0       	breq	.+4      	; 0x1832 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    182e:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1832:	a0 91 ad 06 	lds	r26, 0x06AD
    1836:	b0 91 ae 06 	lds	r27, 0x06AE
    183a:	cd 91       	ld	r28, X+
    183c:	cd bf       	out	0x3d, r28	; 61
    183e:	dd 91       	ld	r29, X+
    1840:	de bf       	out	0x3e, r29	; 62
    1842:	ff 91       	pop	r31
    1844:	ef 91       	pop	r30
    1846:	df 91       	pop	r29
    1848:	cf 91       	pop	r28
    184a:	bf 91       	pop	r27
    184c:	af 91       	pop	r26
    184e:	9f 91       	pop	r25
    1850:	8f 91       	pop	r24
    1852:	7f 91       	pop	r23
    1854:	6f 91       	pop	r22
    1856:	5f 91       	pop	r21
    1858:	4f 91       	pop	r20
    185a:	3f 91       	pop	r19
    185c:	2f 91       	pop	r18
    185e:	1f 91       	pop	r17
    1860:	0f 91       	pop	r16
    1862:	ff 90       	pop	r15
    1864:	ef 90       	pop	r14
    1866:	df 90       	pop	r13
    1868:	cf 90       	pop	r12
    186a:	bf 90       	pop	r11
    186c:	af 90       	pop	r10
    186e:	9f 90       	pop	r9
    1870:	8f 90       	pop	r8
    1872:	7f 90       	pop	r7
    1874:	6f 90       	pop	r6
    1876:	5f 90       	pop	r5
    1878:	4f 90       	pop	r4
    187a:	3f 90       	pop	r3
    187c:	2f 90       	pop	r2
    187e:	1f 90       	pop	r1
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63
    1884:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1886:	08 95       	ret

00001888 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1888:	df 93       	push	r29
    188a:	cf 93       	push	r28
    188c:	00 d0       	rcall	.+0      	; 0x188e <prvSetupTimerInterrupt+0x6>
    188e:	00 d0       	rcall	.+0      	; 0x1890 <prvSetupTimerInterrupt+0x8>
    1890:	00 d0       	rcall	.+0      	; 0x1892 <prvSetupTimerInterrupt+0xa>
    1892:	cd b7       	in	r28, 0x3d	; 61
    1894:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1896:	80 e4       	ldi	r24, 0x40	; 64
    1898:	9f e1       	ldi	r25, 0x1F	; 31
    189a:	a0 e0       	ldi	r26, 0x00	; 0
    189c:	b0 e0       	ldi	r27, 0x00	; 0
    189e:	8b 83       	std	Y+3, r24	; 0x03
    18a0:	9c 83       	std	Y+4, r25	; 0x04
    18a2:	ad 83       	std	Y+5, r26	; 0x05
    18a4:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    18a6:	8b 81       	ldd	r24, Y+3	; 0x03
    18a8:	9c 81       	ldd	r25, Y+4	; 0x04
    18aa:	ad 81       	ldd	r26, Y+5	; 0x05
    18ac:	be 81       	ldd	r27, Y+6	; 0x06
    18ae:	68 94       	set
    18b0:	15 f8       	bld	r1, 5
    18b2:	b6 95       	lsr	r27
    18b4:	a7 95       	ror	r26
    18b6:	97 95       	ror	r25
    18b8:	87 95       	ror	r24
    18ba:	16 94       	lsr	r1
    18bc:	d1 f7       	brne	.-12     	; 0x18b2 <prvSetupTimerInterrupt+0x2a>
    18be:	8b 83       	std	Y+3, r24	; 0x03
    18c0:	9c 83       	std	Y+4, r25	; 0x04
    18c2:	ad 83       	std	Y+5, r26	; 0x05
    18c4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    18c6:	8b 81       	ldd	r24, Y+3	; 0x03
    18c8:	9c 81       	ldd	r25, Y+4	; 0x04
    18ca:	ad 81       	ldd	r26, Y+5	; 0x05
    18cc:	be 81       	ldd	r27, Y+6	; 0x06
    18ce:	01 97       	sbiw	r24, 0x01	; 1
    18d0:	a1 09       	sbc	r26, r1
    18d2:	b1 09       	sbc	r27, r1
    18d4:	8b 83       	std	Y+3, r24	; 0x03
    18d6:	9c 83       	std	Y+4, r25	; 0x04
    18d8:	ad 83       	std	Y+5, r26	; 0x05
    18da:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    18dc:	8b 81       	ldd	r24, Y+3	; 0x03
    18de:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    18e0:	8b 81       	ldd	r24, Y+3	; 0x03
    18e2:	9c 81       	ldd	r25, Y+4	; 0x04
    18e4:	ad 81       	ldd	r26, Y+5	; 0x05
    18e6:	be 81       	ldd	r27, Y+6	; 0x06
    18e8:	89 2f       	mov	r24, r25
    18ea:	9a 2f       	mov	r25, r26
    18ec:	ab 2f       	mov	r26, r27
    18ee:	bb 27       	eor	r27, r27
    18f0:	8b 83       	std	Y+3, r24	; 0x03
    18f2:	9c 83       	std	Y+4, r25	; 0x04
    18f4:	ad 83       	std	Y+5, r26	; 0x05
    18f6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    18f8:	8b 81       	ldd	r24, Y+3	; 0x03
    18fa:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    18fc:	eb e4       	ldi	r30, 0x4B	; 75
    18fe:	f0 e0       	ldi	r31, 0x00	; 0
    1900:	8a 81       	ldd	r24, Y+2	; 0x02
    1902:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1904:	ea e4       	ldi	r30, 0x4A	; 74
    1906:	f0 e0       	ldi	r31, 0x00	; 0
    1908:	89 81       	ldd	r24, Y+1	; 0x01
    190a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    190c:	8b e0       	ldi	r24, 0x0B	; 11
    190e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1910:	ee e4       	ldi	r30, 0x4E	; 78
    1912:	f0 e0       	ldi	r31, 0x00	; 0
    1914:	89 81       	ldd	r24, Y+1	; 0x01
    1916:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1918:	e9 e5       	ldi	r30, 0x59	; 89
    191a:	f0 e0       	ldi	r31, 0x00	; 0
    191c:	80 81       	ld	r24, Z
    191e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1920:	89 81       	ldd	r24, Y+1	; 0x01
    1922:	80 61       	ori	r24, 0x10	; 16
    1924:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1926:	e9 e5       	ldi	r30, 0x59	; 89
    1928:	f0 e0       	ldi	r31, 0x00	; 0
    192a:	89 81       	ldd	r24, Y+1	; 0x01
    192c:	80 83       	st	Z, r24
}
    192e:	26 96       	adiw	r28, 0x06	; 6
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	f8 94       	cli
    1934:	de bf       	out	0x3e, r29	; 62
    1936:	0f be       	out	0x3f, r0	; 63
    1938:	cd bf       	out	0x3d, r28	; 61
    193a:	cf 91       	pop	r28
    193c:	df 91       	pop	r29
    193e:	08 95       	ret

00001940 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1940:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <vPortYieldFromTick>
		asm volatile ( "reti" );
    1944:	18 95       	reti

00001946 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1946:	df 93       	push	r29
    1948:	cf 93       	push	r28
    194a:	00 d0       	rcall	.+0      	; 0x194c <xQueueGenericReset+0x6>
    194c:	00 d0       	rcall	.+0      	; 0x194e <xQueueGenericReset+0x8>
    194e:	0f 92       	push	r0
    1950:	cd b7       	in	r28, 0x3d	; 61
    1952:	de b7       	in	r29, 0x3e	; 62
    1954:	9c 83       	std	Y+4, r25	; 0x04
    1956:	8b 83       	std	Y+3, r24	; 0x03
    1958:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    195a:	8b 81       	ldd	r24, Y+3	; 0x03
    195c:	9c 81       	ldd	r25, Y+4	; 0x04
    195e:	9a 83       	std	Y+2, r25	; 0x02
    1960:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1968:	e9 81       	ldd	r30, Y+1	; 0x01
    196a:	fa 81       	ldd	r31, Y+2	; 0x02
    196c:	40 81       	ld	r20, Z
    196e:	51 81       	ldd	r21, Z+1	; 0x01
    1970:	e9 81       	ldd	r30, Y+1	; 0x01
    1972:	fa 81       	ldd	r31, Y+2	; 0x02
    1974:	83 8d       	ldd	r24, Z+27	; 0x1b
    1976:	28 2f       	mov	r18, r24
    1978:	30 e0       	ldi	r19, 0x00	; 0
    197a:	e9 81       	ldd	r30, Y+1	; 0x01
    197c:	fa 81       	ldd	r31, Y+2	; 0x02
    197e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1980:	88 2f       	mov	r24, r24
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	bc 01       	movw	r22, r24
    1986:	26 9f       	mul	r18, r22
    1988:	c0 01       	movw	r24, r0
    198a:	27 9f       	mul	r18, r23
    198c:	90 0d       	add	r25, r0
    198e:	36 9f       	mul	r19, r22
    1990:	90 0d       	add	r25, r0
    1992:	11 24       	eor	r1, r1
    1994:	84 0f       	add	r24, r20
    1996:	95 1f       	adc	r25, r21
    1998:	e9 81       	ldd	r30, Y+1	; 0x01
    199a:	fa 81       	ldd	r31, Y+2	; 0x02
    199c:	93 83       	std	Z+3, r25	; 0x03
    199e:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    19a0:	e9 81       	ldd	r30, Y+1	; 0x01
    19a2:	fa 81       	ldd	r31, Y+2	; 0x02
    19a4:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    19a6:	e9 81       	ldd	r30, Y+1	; 0x01
    19a8:	fa 81       	ldd	r31, Y+2	; 0x02
    19aa:	80 81       	ld	r24, Z
    19ac:	91 81       	ldd	r25, Z+1	; 0x01
    19ae:	e9 81       	ldd	r30, Y+1	; 0x01
    19b0:	fa 81       	ldd	r31, Y+2	; 0x02
    19b2:	95 83       	std	Z+5, r25	; 0x05
    19b4:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    19b6:	e9 81       	ldd	r30, Y+1	; 0x01
    19b8:	fa 81       	ldd	r31, Y+2	; 0x02
    19ba:	40 81       	ld	r20, Z
    19bc:	51 81       	ldd	r21, Z+1	; 0x01
    19be:	e9 81       	ldd	r30, Y+1	; 0x01
    19c0:	fa 81       	ldd	r31, Y+2	; 0x02
    19c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    19c4:	88 2f       	mov	r24, r24
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	9c 01       	movw	r18, r24
    19ca:	21 50       	subi	r18, 0x01	; 1
    19cc:	30 40       	sbci	r19, 0x00	; 0
    19ce:	e9 81       	ldd	r30, Y+1	; 0x01
    19d0:	fa 81       	ldd	r31, Y+2	; 0x02
    19d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    19d4:	88 2f       	mov	r24, r24
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	bc 01       	movw	r22, r24
    19da:	26 9f       	mul	r18, r22
    19dc:	c0 01       	movw	r24, r0
    19de:	27 9f       	mul	r18, r23
    19e0:	90 0d       	add	r25, r0
    19e2:	36 9f       	mul	r19, r22
    19e4:	90 0d       	add	r25, r0
    19e6:	11 24       	eor	r1, r1
    19e8:	84 0f       	add	r24, r20
    19ea:	95 1f       	adc	r25, r21
    19ec:	e9 81       	ldd	r30, Y+1	; 0x01
    19ee:	fa 81       	ldd	r31, Y+2	; 0x02
    19f0:	97 83       	std	Z+7, r25	; 0x07
    19f2:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    19f4:	e9 81       	ldd	r30, Y+1	; 0x01
    19f6:	fa 81       	ldd	r31, Y+2	; 0x02
    19f8:	8f ef       	ldi	r24, 0xFF	; 255
    19fa:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    19fc:	e9 81       	ldd	r30, Y+1	; 0x01
    19fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1a00:	8f ef       	ldi	r24, 0xFF	; 255
    1a02:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1a04:	8d 81       	ldd	r24, Y+5	; 0x05
    1a06:	88 23       	and	r24, r24
    1a08:	79 f4       	brne	.+30     	; 0x1a28 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a0e:	80 85       	ldd	r24, Z+8	; 0x08
    1a10:	88 23       	and	r24, r24
    1a12:	a1 f0       	breq	.+40     	; 0x1a3c <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a14:	89 81       	ldd	r24, Y+1	; 0x01
    1a16:	9a 81       	ldd	r25, Y+2	; 0x02
    1a18:	08 96       	adiw	r24, 0x08	; 8
    1a1a:	0e 94 97 18 	call	0x312e	; 0x312e <xTaskRemoveFromEventList>
    1a1e:	81 30       	cpi	r24, 0x01	; 1
    1a20:	69 f4       	brne	.+26     	; 0x1a3c <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1a22:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1a26:	0a c0       	rjmp	.+20     	; 0x1a3c <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1a28:	89 81       	ldd	r24, Y+1	; 0x01
    1a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a2c:	08 96       	adiw	r24, 0x08	; 8
    1a2e:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1a32:	89 81       	ldd	r24, Y+1	; 0x01
    1a34:	9a 81       	ldd	r25, Y+2	; 0x02
    1a36:	41 96       	adiw	r24, 0x11	; 17
    1a38:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1a3c:	0f 90       	pop	r0
    1a3e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1a40:	81 e0       	ldi	r24, 0x01	; 1
}
    1a42:	0f 90       	pop	r0
    1a44:	0f 90       	pop	r0
    1a46:	0f 90       	pop	r0
    1a48:	0f 90       	pop	r0
    1a4a:	0f 90       	pop	r0
    1a4c:	cf 91       	pop	r28
    1a4e:	df 91       	pop	r29
    1a50:	08 95       	ret

00001a52 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1a52:	df 93       	push	r29
    1a54:	cf 93       	push	r28
    1a56:	cd b7       	in	r28, 0x3d	; 61
    1a58:	de b7       	in	r29, 0x3e	; 62
    1a5a:	29 97       	sbiw	r28, 0x09	; 9
    1a5c:	0f b6       	in	r0, 0x3f	; 63
    1a5e:	f8 94       	cli
    1a60:	de bf       	out	0x3e, r29	; 62
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	cd bf       	out	0x3d, r28	; 61
    1a66:	8f 83       	std	Y+7, r24	; 0x07
    1a68:	68 87       	std	Y+8, r22	; 0x08
    1a6a:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1a6c:	1a 82       	std	Y+2, r1	; 0x02
    1a6e:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1a70:	8f 81       	ldd	r24, Y+7	; 0x07
    1a72:	88 23       	and	r24, r24
    1a74:	09 f4       	brne	.+2      	; 0x1a78 <xQueueGenericCreate+0x26>
    1a76:	3f c0       	rjmp	.+126    	; 0x1af6 <xQueueGenericCreate+0xa4>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1a78:	8f e1       	ldi	r24, 0x1F	; 31
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
    1a7c:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    1a80:	9e 83       	std	Y+6, r25	; 0x06
    1a82:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1a84:	8d 81       	ldd	r24, Y+5	; 0x05
    1a86:	9e 81       	ldd	r25, Y+6	; 0x06
    1a88:	00 97       	sbiw	r24, 0x00	; 0
    1a8a:	a9 f1       	breq	.+106    	; 0x1af6 <xQueueGenericCreate+0xa4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a8c:	8f 81       	ldd	r24, Y+7	; 0x07
    1a8e:	28 2f       	mov	r18, r24
    1a90:	30 e0       	ldi	r19, 0x00	; 0
    1a92:	88 85       	ldd	r24, Y+8	; 0x08
    1a94:	88 2f       	mov	r24, r24
    1a96:	90 e0       	ldi	r25, 0x00	; 0
    1a98:	ac 01       	movw	r20, r24
    1a9a:	24 9f       	mul	r18, r20
    1a9c:	c0 01       	movw	r24, r0
    1a9e:	25 9f       	mul	r18, r21
    1aa0:	90 0d       	add	r25, r0
    1aa2:	34 9f       	mul	r19, r20
    1aa4:	90 0d       	add	r25, r0
    1aa6:	11 24       	eor	r1, r1
    1aa8:	01 96       	adiw	r24, 0x01	; 1
    1aaa:	9c 83       	std	Y+4, r25	; 0x04
    1aac:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1aae:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab2:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    1ab6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ab8:	fe 81       	ldd	r31, Y+6	; 0x06
    1aba:	91 83       	std	Z+1, r25	; 0x01
    1abc:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1abe:	ed 81       	ldd	r30, Y+5	; 0x05
    1ac0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ac2:	80 81       	ld	r24, Z
    1ac4:	91 81       	ldd	r25, Z+1	; 0x01
    1ac6:	00 97       	sbiw	r24, 0x00	; 0
    1ac8:	91 f0       	breq	.+36     	; 0x1aee <xQueueGenericCreate+0x9c>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1aca:	ed 81       	ldd	r30, Y+5	; 0x05
    1acc:	fe 81       	ldd	r31, Y+6	; 0x06
    1ace:	8f 81       	ldd	r24, Y+7	; 0x07
    1ad0:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1ad2:	ed 81       	ldd	r30, Y+5	; 0x05
    1ad4:	fe 81       	ldd	r31, Y+6	; 0x06
    1ad6:	88 85       	ldd	r24, Y+8	; 0x08
    1ad8:	84 8f       	std	Z+28, r24	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1ada:	8d 81       	ldd	r24, Y+5	; 0x05
    1adc:	9e 81       	ldd	r25, Y+6	; 0x06
    1ade:	61 e0       	ldi	r22, 0x01	; 1
    1ae0:	0e 94 a3 0c 	call	0x1946	; 0x1946 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1ae4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ae8:	9a 83       	std	Y+2, r25	; 0x02
    1aea:	89 83       	std	Y+1, r24	; 0x01
    1aec:	04 c0       	rjmp	.+8      	; 0x1af6 <xQueueGenericCreate+0xa4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1aee:	8d 81       	ldd	r24, Y+5	; 0x05
    1af0:	9e 81       	ldd	r25, Y+6	; 0x06
    1af2:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    1af6:	89 81       	ldd	r24, Y+1	; 0x01
    1af8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1afa:	29 96       	adiw	r28, 0x09	; 9
    1afc:	0f b6       	in	r0, 0x3f	; 63
    1afe:	f8 94       	cli
    1b00:	de bf       	out	0x3e, r29	; 62
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	cd bf       	out	0x3d, r28	; 61
    1b06:	cf 91       	pop	r28
    1b08:	df 91       	pop	r29
    1b0a:	08 95       	ret

00001b0c <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    1b0c:	df 93       	push	r29
    1b0e:	cf 93       	push	r28
    1b10:	00 d0       	rcall	.+0      	; 0x1b12 <xQueueCreateCountingSemaphore+0x6>
    1b12:	00 d0       	rcall	.+0      	; 0x1b14 <xQueueCreateCountingSemaphore+0x8>
    1b14:	cd b7       	in	r28, 0x3d	; 61
    1b16:	de b7       	in	r29, 0x3e	; 62
    1b18:	8b 83       	std	Y+3, r24	; 0x03
    1b1a:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    1b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b1e:	60 e0       	ldi	r22, 0x00	; 0
    1b20:	42 e0       	ldi	r20, 0x02	; 2
    1b22:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <xQueueGenericCreate>
    1b26:	9a 83       	std	Y+2, r25	; 0x02
    1b28:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    1b2a:	89 81       	ldd	r24, Y+1	; 0x01
    1b2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2e:	00 97       	sbiw	r24, 0x00	; 0
    1b30:	21 f0       	breq	.+8      	; 0x1b3a <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    1b32:	e9 81       	ldd	r30, Y+1	; 0x01
    1b34:	fa 81       	ldd	r31, Y+2	; 0x02
    1b36:	8c 81       	ldd	r24, Y+4	; 0x04
    1b38:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
    1b3a:	89 81       	ldd	r24, Y+1	; 0x01
    1b3c:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1b3e:	0f 90       	pop	r0
    1b40:	0f 90       	pop	r0
    1b42:	0f 90       	pop	r0
    1b44:	0f 90       	pop	r0
    1b46:	cf 91       	pop	r28
    1b48:	df 91       	pop	r29
    1b4a:	08 95       	ret

00001b4c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1b4c:	df 93       	push	r29
    1b4e:	cf 93       	push	r28
    1b50:	cd b7       	in	r28, 0x3d	; 61
    1b52:	de b7       	in	r29, 0x3e	; 62
    1b54:	2f 97       	sbiw	r28, 0x0f	; 15
    1b56:	0f b6       	in	r0, 0x3f	; 63
    1b58:	f8 94       	cli
    1b5a:	de bf       	out	0x3e, r29	; 62
    1b5c:	0f be       	out	0x3f, r0	; 63
    1b5e:	cd bf       	out	0x3d, r28	; 61
    1b60:	99 87       	std	Y+9, r25	; 0x09
    1b62:	88 87       	std	Y+8, r24	; 0x08
    1b64:	7b 87       	std	Y+11, r23	; 0x0b
    1b66:	6a 87       	std	Y+10, r22	; 0x0a
    1b68:	5d 87       	std	Y+13, r21	; 0x0d
    1b6a:	4c 87       	std	Y+12, r20	; 0x0c
    1b6c:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1b6e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1b70:	88 85       	ldd	r24, Y+8	; 0x08
    1b72:	99 85       	ldd	r25, Y+9	; 0x09
    1b74:	9a 83       	std	Y+2, r25	; 0x02
    1b76:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1b78:	0f b6       	in	r0, 0x3f	; 63
    1b7a:	f8 94       	cli
    1b7c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1b7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b80:	fa 81       	ldd	r31, Y+2	; 0x02
    1b82:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b84:	e9 81       	ldd	r30, Y+1	; 0x01
    1b86:	fa 81       	ldd	r31, Y+2	; 0x02
    1b88:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b8a:	98 17       	cp	r25, r24
    1b8c:	18 f0       	brcs	.+6      	; 0x1b94 <xQueueGenericSend+0x48>
    1b8e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b90:	82 30       	cpi	r24, 0x02	; 2
    1b92:	11 f5       	brne	.+68     	; 0x1bd8 <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b94:	89 81       	ldd	r24, Y+1	; 0x01
    1b96:	9a 81       	ldd	r25, Y+2	; 0x02
    1b98:	2a 85       	ldd	r18, Y+10	; 0x0a
    1b9a:	3b 85       	ldd	r19, Y+11	; 0x0b
    1b9c:	b9 01       	movw	r22, r18
    1b9e:	4e 85       	ldd	r20, Y+14	; 0x0e
    1ba0:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <prvCopyDataToQueue>
    1ba4:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ba6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ba8:	fa 81       	ldd	r31, Y+2	; 0x02
    1baa:	81 89       	ldd	r24, Z+17	; 0x11
    1bac:	88 23       	and	r24, r24
    1bae:	51 f0       	breq	.+20     	; 0x1bc4 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1bb0:	89 81       	ldd	r24, Y+1	; 0x01
    1bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb4:	41 96       	adiw	r24, 0x11	; 17
    1bb6:	0e 94 97 18 	call	0x312e	; 0x312e <xTaskRemoveFromEventList>
    1bba:	81 30       	cpi	r24, 0x01	; 1
    1bbc:	41 f4       	brne	.+16     	; 0x1bce <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1bbe:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1bc2:	05 c0       	rjmp	.+10     	; 0x1bce <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc6:	88 23       	and	r24, r24
    1bc8:	11 f0       	breq	.+4      	; 0x1bce <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1bca:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1bce:	0f 90       	pop	r0
    1bd0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1bd2:	81 e0       	ldi	r24, 0x01	; 1
    1bd4:	8f 87       	std	Y+15, r24	; 0x0f
    1bd6:	5c c0       	rjmp	.+184    	; 0x1c90 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1bd8:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bda:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bdc:	00 97       	sbiw	r24, 0x00	; 0
    1bde:	21 f4       	brne	.+8      	; 0x1be8 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1be4:	1f 86       	std	Y+15, r1	; 0x0f
    1be6:	54 c0       	rjmp	.+168    	; 0x1c90 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1be8:	8c 81       	ldd	r24, Y+4	; 0x04
    1bea:	88 23       	and	r24, r24
    1bec:	31 f4       	brne	.+12     	; 0x1bfa <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1bee:	ce 01       	movw	r24, r28
    1bf0:	05 96       	adiw	r24, 0x05	; 5
    1bf2:	0e 94 67 19 	call	0x32ce	; 0x32ce <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1bf6:	81 e0       	ldi	r24, 0x01	; 1
    1bf8:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1bfa:	0f 90       	pop	r0
    1bfc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1bfe:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c02:	0f b6       	in	r0, 0x3f	; 63
    1c04:	f8 94       	cli
    1c06:	0f 92       	push	r0
    1c08:	e9 81       	ldd	r30, Y+1	; 0x01
    1c0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c10:	19 f4       	brne	.+6      	; 0x1c18 <xQueueGenericSend+0xcc>
    1c12:	e9 81       	ldd	r30, Y+1	; 0x01
    1c14:	fa 81       	ldd	r31, Y+2	; 0x02
    1c16:	15 8e       	std	Z+29, r1	; 0x1d
    1c18:	e9 81       	ldd	r30, Y+1	; 0x01
    1c1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c20:	19 f4       	brne	.+6      	; 0x1c28 <xQueueGenericSend+0xdc>
    1c22:	e9 81       	ldd	r30, Y+1	; 0x01
    1c24:	fa 81       	ldd	r31, Y+2	; 0x02
    1c26:	16 8e       	std	Z+30, r1	; 0x1e
    1c28:	0f 90       	pop	r0
    1c2a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c2c:	ce 01       	movw	r24, r28
    1c2e:	05 96       	adiw	r24, 0x05	; 5
    1c30:	9e 01       	movw	r18, r28
    1c32:	24 5f       	subi	r18, 0xF4	; 244
    1c34:	3f 4f       	sbci	r19, 0xFF	; 255
    1c36:	b9 01       	movw	r22, r18
    1c38:	0e 94 80 19 	call	0x3300	; 0x3300 <xTaskCheckForTimeOut>
    1c3c:	88 23       	and	r24, r24
    1c3e:	09 f5       	brne	.+66     	; 0x1c82 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1c40:	89 81       	ldd	r24, Y+1	; 0x01
    1c42:	9a 81       	ldd	r25, Y+2	; 0x02
    1c44:	0e 94 f2 11 	call	0x23e4	; 0x23e4 <prvIsQueueFull>
    1c48:	88 23       	and	r24, r24
    1c4a:	a1 f0       	breq	.+40     	; 0x1c74 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1c4c:	89 81       	ldd	r24, Y+1	; 0x01
    1c4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c50:	08 96       	adiw	r24, 0x08	; 8
    1c52:	2c 85       	ldd	r18, Y+12	; 0x0c
    1c54:	3d 85       	ldd	r19, Y+13	; 0x0d
    1c56:	b9 01       	movw	r22, r18
    1c58:	0e 94 1f 18 	call	0x303e	; 0x303e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1c5c:	89 81       	ldd	r24, Y+1	; 0x01
    1c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c60:	0e 94 69 11 	call	0x22d2	; 0x22d2 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1c64:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
    1c68:	88 23       	and	r24, r24
    1c6a:	09 f0       	breq	.+2      	; 0x1c6e <xQueueGenericSend+0x122>
    1c6c:	85 cf       	rjmp	.-246    	; 0x1b78 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1c6e:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1c72:	82 cf       	rjmp	.-252    	; 0x1b78 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c74:	89 81       	ldd	r24, Y+1	; 0x01
    1c76:	9a 81       	ldd	r25, Y+2	; 0x02
    1c78:	0e 94 69 11 	call	0x22d2	; 0x22d2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c7c:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
    1c80:	7b cf       	rjmp	.-266    	; 0x1b78 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	9a 81       	ldd	r25, Y+2	; 0x02
    1c86:	0e 94 69 11 	call	0x22d2	; 0x22d2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c8a:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1c8e:	1f 86       	std	Y+15, r1	; 0x0f
    1c90:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    1c92:	2f 96       	adiw	r28, 0x0f	; 15
    1c94:	0f b6       	in	r0, 0x3f	; 63
    1c96:	f8 94       	cli
    1c98:	de bf       	out	0x3e, r29	; 62
    1c9a:	0f be       	out	0x3f, r0	; 63
    1c9c:	cd bf       	out	0x3d, r28	; 61
    1c9e:	cf 91       	pop	r28
    1ca0:	df 91       	pop	r29
    1ca2:	08 95       	ret

00001ca4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1ca4:	df 93       	push	r29
    1ca6:	cf 93       	push	r28
    1ca8:	cd b7       	in	r28, 0x3d	; 61
    1caa:	de b7       	in	r29, 0x3e	; 62
    1cac:	2b 97       	sbiw	r28, 0x0b	; 11
    1cae:	0f b6       	in	r0, 0x3f	; 63
    1cb0:	f8 94       	cli
    1cb2:	de bf       	out	0x3e, r29	; 62
    1cb4:	0f be       	out	0x3f, r0	; 63
    1cb6:	cd bf       	out	0x3d, r28	; 61
    1cb8:	9e 83       	std	Y+6, r25	; 0x06
    1cba:	8d 83       	std	Y+5, r24	; 0x05
    1cbc:	78 87       	std	Y+8, r23	; 0x08
    1cbe:	6f 83       	std	Y+7, r22	; 0x07
    1cc0:	5a 87       	std	Y+10, r21	; 0x0a
    1cc2:	49 87       	std	Y+9, r20	; 0x09
    1cc4:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1cc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1cc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cca:	9a 83       	std	Y+2, r25	; 0x02
    1ccc:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1cce:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1cd0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cd2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cd4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    1cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cda:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cdc:	98 17       	cp	r25, r24
    1cde:	18 f0       	brcs	.+6      	; 0x1ce6 <xQueueGenericSendFromISR+0x42>
    1ce0:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ce2:	82 30       	cpi	r24, 0x02	; 2
    1ce4:	b1 f5       	brne	.+108    	; 0x1d52 <xQueueGenericSendFromISR+0xae>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1ce6:	89 81       	ldd	r24, Y+1	; 0x01
    1ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    1cea:	2f 81       	ldd	r18, Y+7	; 0x07
    1cec:	38 85       	ldd	r19, Y+8	; 0x08
    1cee:	b9 01       	movw	r22, r18
    1cf0:	4b 85       	ldd	r20, Y+11	; 0x0b
    1cf2:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <prvCopyDataToQueue>
    1cf6:	88 23       	and	r24, r24
    1cf8:	41 f0       	breq	.+16     	; 0x1d0a <xQueueGenericSendFromISR+0x66>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1cfa:	89 85       	ldd	r24, Y+9	; 0x09
    1cfc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cfe:	00 97       	sbiw	r24, 0x00	; 0
    1d00:	21 f0       	breq	.+8      	; 0x1d0a <xQueueGenericSendFromISR+0x66>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1d02:	e9 85       	ldd	r30, Y+9	; 0x09
    1d04:	fa 85       	ldd	r31, Y+10	; 0x0a
    1d06:	81 e0       	ldi	r24, 0x01	; 1
    1d08:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1d0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d0e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d10:	8f 3f       	cpi	r24, 0xFF	; 255
    1d12:	a9 f4       	brne	.+42     	; 0x1d3e <xQueueGenericSendFromISR+0x9a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d14:	e9 81       	ldd	r30, Y+1	; 0x01
    1d16:	fa 81       	ldd	r31, Y+2	; 0x02
    1d18:	81 89       	ldd	r24, Z+17	; 0x11
    1d1a:	88 23       	and	r24, r24
    1d1c:	b9 f0       	breq	.+46     	; 0x1d4c <xQueueGenericSendFromISR+0xa8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d1e:	89 81       	ldd	r24, Y+1	; 0x01
    1d20:	9a 81       	ldd	r25, Y+2	; 0x02
    1d22:	41 96       	adiw	r24, 0x11	; 17
    1d24:	0e 94 97 18 	call	0x312e	; 0x312e <xTaskRemoveFromEventList>
    1d28:	88 23       	and	r24, r24
    1d2a:	81 f0       	breq	.+32     	; 0x1d4c <xQueueGenericSendFromISR+0xa8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1d2c:	89 85       	ldd	r24, Y+9	; 0x09
    1d2e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d30:	00 97       	sbiw	r24, 0x00	; 0
    1d32:	61 f0       	breq	.+24     	; 0x1d4c <xQueueGenericSendFromISR+0xa8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1d34:	e9 85       	ldd	r30, Y+9	; 0x09
    1d36:	fa 85       	ldd	r31, Y+10	; 0x0a
    1d38:	81 e0       	ldi	r24, 0x01	; 1
    1d3a:	80 83       	st	Z, r24
    1d3c:	07 c0       	rjmp	.+14     	; 0x1d4c <xQueueGenericSendFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1d3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d40:	fa 81       	ldd	r31, Y+2	; 0x02
    1d42:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d44:	8f 5f       	subi	r24, 0xFF	; 255
    1d46:	e9 81       	ldd	r30, Y+1	; 0x01
    1d48:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1d4c:	81 e0       	ldi	r24, 0x01	; 1
    1d4e:	8c 83       	std	Y+4, r24	; 0x04
    1d50:	01 c0       	rjmp	.+2      	; 0x1d54 <xQueueGenericSendFromISR+0xb0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1d52:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1d54:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1d56:	2b 96       	adiw	r28, 0x0b	; 11
    1d58:	0f b6       	in	r0, 0x3f	; 63
    1d5a:	f8 94       	cli
    1d5c:	de bf       	out	0x3e, r29	; 62
    1d5e:	0f be       	out	0x3f, r0	; 63
    1d60:	cd bf       	out	0x3d, r28	; 61
    1d62:	cf 91       	pop	r28
    1d64:	df 91       	pop	r29
    1d66:	08 95       	ret

00001d68 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1d68:	df 93       	push	r29
    1d6a:	cf 93       	push	r28
    1d6c:	cd b7       	in	r28, 0x3d	; 61
    1d6e:	de b7       	in	r29, 0x3e	; 62
    1d70:	60 97       	sbiw	r28, 0x10	; 16
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	de bf       	out	0x3e, r29	; 62
    1d78:	0f be       	out	0x3f, r0	; 63
    1d7a:	cd bf       	out	0x3d, r28	; 61
    1d7c:	9a 87       	std	Y+10, r25	; 0x0a
    1d7e:	89 87       	std	Y+9, r24	; 0x09
    1d80:	7c 87       	std	Y+12, r23	; 0x0c
    1d82:	6b 87       	std	Y+11, r22	; 0x0b
    1d84:	5e 87       	std	Y+14, r21	; 0x0e
    1d86:	4d 87       	std	Y+13, r20	; 0x0d
    1d88:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    1d8a:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d8c:	89 85       	ldd	r24, Y+9	; 0x09
    1d8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d90:	9a 83       	std	Y+2, r25	; 0x02
    1d92:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1da0:	88 23       	and	r24, r24
    1da2:	09 f4       	brne	.+2      	; 0x1da6 <xQueueGenericReceive+0x3e>
    1da4:	3f c0       	rjmp	.+126    	; 0x1e24 <xQueueGenericReceive+0xbc>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1da6:	e9 81       	ldd	r30, Y+1	; 0x01
    1da8:	fa 81       	ldd	r31, Y+2	; 0x02
    1daa:	86 81       	ldd	r24, Z+6	; 0x06
    1dac:	97 81       	ldd	r25, Z+7	; 0x07
    1dae:	9c 83       	std	Y+4, r25	; 0x04
    1db0:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1db2:	89 81       	ldd	r24, Y+1	; 0x01
    1db4:	9a 81       	ldd	r25, Y+2	; 0x02
    1db6:	2b 85       	ldd	r18, Y+11	; 0x0b
    1db8:	3c 85       	ldd	r19, Y+12	; 0x0c
    1dba:	b9 01       	movw	r22, r18
    1dbc:	0e 94 22 11 	call	0x2244	; 0x2244 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1dc0:	8f 85       	ldd	r24, Y+15	; 0x0f
    1dc2:	88 23       	and	r24, r24
    1dc4:	b1 f4       	brne	.+44     	; 0x1df2 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1dc6:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dca:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dcc:	81 50       	subi	r24, 0x01	; 1
    1dce:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd2:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1dd4:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd6:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd8:	80 85       	ldd	r24, Z+8	; 0x08
    1dda:	88 23       	and	r24, r24
    1ddc:	f1 f0       	breq	.+60     	; 0x1e1a <xQueueGenericReceive+0xb2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1dde:	89 81       	ldd	r24, Y+1	; 0x01
    1de0:	9a 81       	ldd	r25, Y+2	; 0x02
    1de2:	08 96       	adiw	r24, 0x08	; 8
    1de4:	0e 94 97 18 	call	0x312e	; 0x312e <xTaskRemoveFromEventList>
    1de8:	81 30       	cpi	r24, 0x01	; 1
    1dea:	b9 f4       	brne	.+46     	; 0x1e1a <xQueueGenericReceive+0xb2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1dec:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1df0:	14 c0       	rjmp	.+40     	; 0x1e1a <xQueueGenericReceive+0xb2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1df2:	e9 81       	ldd	r30, Y+1	; 0x01
    1df4:	fa 81       	ldd	r31, Y+2	; 0x02
    1df6:	8b 81       	ldd	r24, Y+3	; 0x03
    1df8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dfa:	97 83       	std	Z+7, r25	; 0x07
    1dfc:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    1e00:	fa 81       	ldd	r31, Y+2	; 0x02
    1e02:	81 89       	ldd	r24, Z+17	; 0x11
    1e04:	88 23       	and	r24, r24
    1e06:	49 f0       	breq	.+18     	; 0x1e1a <xQueueGenericReceive+0xb2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e08:	89 81       	ldd	r24, Y+1	; 0x01
    1e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e0c:	41 96       	adiw	r24, 0x11	; 17
    1e0e:	0e 94 97 18 	call	0x312e	; 0x312e <xTaskRemoveFromEventList>
    1e12:	88 23       	and	r24, r24
    1e14:	11 f0       	breq	.+4      	; 0x1e1a <xQueueGenericReceive+0xb2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1e16:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1e1a:	0f 90       	pop	r0
    1e1c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e1e:	81 e0       	ldi	r24, 0x01	; 1
    1e20:	88 8b       	std	Y+16, r24	; 0x10
    1e22:	5c c0       	rjmp	.+184    	; 0x1edc <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e24:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e26:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e28:	00 97       	sbiw	r24, 0x00	; 0
    1e2a:	21 f4       	brne	.+8      	; 0x1e34 <xQueueGenericReceive+0xcc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e2c:	0f 90       	pop	r0
    1e2e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e30:	18 8a       	std	Y+16, r1	; 0x10
    1e32:	54 c0       	rjmp	.+168    	; 0x1edc <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e34:	8d 81       	ldd	r24, Y+5	; 0x05
    1e36:	88 23       	and	r24, r24
    1e38:	31 f4       	brne	.+12     	; 0x1e46 <xQueueGenericReceive+0xde>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e3a:	ce 01       	movw	r24, r28
    1e3c:	06 96       	adiw	r24, 0x06	; 6
    1e3e:	0e 94 67 19 	call	0x32ce	; 0x32ce <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e42:	81 e0       	ldi	r24, 0x01	; 1
    1e44:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e46:	0f 90       	pop	r0
    1e48:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e4a:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e4e:	0f b6       	in	r0, 0x3f	; 63
    1e50:	f8 94       	cli
    1e52:	0f 92       	push	r0
    1e54:	e9 81       	ldd	r30, Y+1	; 0x01
    1e56:	fa 81       	ldd	r31, Y+2	; 0x02
    1e58:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1e5c:	19 f4       	brne	.+6      	; 0x1e64 <xQueueGenericReceive+0xfc>
    1e5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e60:	fa 81       	ldd	r31, Y+2	; 0x02
    1e62:	15 8e       	std	Z+29, r1	; 0x1d
    1e64:	e9 81       	ldd	r30, Y+1	; 0x01
    1e66:	fa 81       	ldd	r31, Y+2	; 0x02
    1e68:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e6a:	8f 3f       	cpi	r24, 0xFF	; 255
    1e6c:	19 f4       	brne	.+6      	; 0x1e74 <xQueueGenericReceive+0x10c>
    1e6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e70:	fa 81       	ldd	r31, Y+2	; 0x02
    1e72:	16 8e       	std	Z+30, r1	; 0x1e
    1e74:	0f 90       	pop	r0
    1e76:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e78:	ce 01       	movw	r24, r28
    1e7a:	06 96       	adiw	r24, 0x06	; 6
    1e7c:	9e 01       	movw	r18, r28
    1e7e:	23 5f       	subi	r18, 0xF3	; 243
    1e80:	3f 4f       	sbci	r19, 0xFF	; 255
    1e82:	b9 01       	movw	r22, r18
    1e84:	0e 94 80 19 	call	0x3300	; 0x3300 <xTaskCheckForTimeOut>
    1e88:	88 23       	and	r24, r24
    1e8a:	09 f5       	brne	.+66     	; 0x1ece <xQueueGenericReceive+0x166>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e8c:	89 81       	ldd	r24, Y+1	; 0x01
    1e8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1e90:	0e 94 bd 11 	call	0x237a	; 0x237a <prvIsQueueEmpty>
    1e94:	88 23       	and	r24, r24
    1e96:	a1 f0       	breq	.+40     	; 0x1ec0 <xQueueGenericReceive+0x158>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e98:	89 81       	ldd	r24, Y+1	; 0x01
    1e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9c:	41 96       	adiw	r24, 0x11	; 17
    1e9e:	2d 85       	ldd	r18, Y+13	; 0x0d
    1ea0:	3e 85       	ldd	r19, Y+14	; 0x0e
    1ea2:	b9 01       	movw	r22, r18
    1ea4:	0e 94 1f 18 	call	0x303e	; 0x303e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ea8:	89 81       	ldd	r24, Y+1	; 0x01
    1eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1eac:	0e 94 69 11 	call	0x22d2	; 0x22d2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1eb0:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
    1eb4:	88 23       	and	r24, r24
    1eb6:	09 f0       	breq	.+2      	; 0x1eba <xQueueGenericReceive+0x152>
    1eb8:	6d cf       	rjmp	.-294    	; 0x1d94 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1eba:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    1ebe:	6a cf       	rjmp	.-300    	; 0x1d94 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ec0:	89 81       	ldd	r24, Y+1	; 0x01
    1ec2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ec4:	0e 94 69 11 	call	0x22d2	; 0x22d2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ec8:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
    1ecc:	63 cf       	rjmp	.-314    	; 0x1d94 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1ece:	89 81       	ldd	r24, Y+1	; 0x01
    1ed0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ed2:	0e 94 69 11 	call	0x22d2	; 0x22d2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ed6:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1eda:	18 8a       	std	Y+16, r1	; 0x10
    1edc:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    1ede:	60 96       	adiw	r28, 0x10	; 16
    1ee0:	0f b6       	in	r0, 0x3f	; 63
    1ee2:	f8 94       	cli
    1ee4:	de bf       	out	0x3e, r29	; 62
    1ee6:	0f be       	out	0x3f, r0	; 63
    1ee8:	cd bf       	out	0x3d, r28	; 61
    1eea:	cf 91       	pop	r28
    1eec:	df 91       	pop	r29
    1eee:	08 95       	ret

00001ef0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1ef0:	df 93       	push	r29
    1ef2:	cf 93       	push	r28
    1ef4:	cd b7       	in	r28, 0x3d	; 61
    1ef6:	de b7       	in	r29, 0x3e	; 62
    1ef8:	2a 97       	sbiw	r28, 0x0a	; 10
    1efa:	0f b6       	in	r0, 0x3f	; 63
    1efc:	f8 94       	cli
    1efe:	de bf       	out	0x3e, r29	; 62
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	cd bf       	out	0x3d, r28	; 61
    1f04:	9e 83       	std	Y+6, r25	; 0x06
    1f06:	8d 83       	std	Y+5, r24	; 0x05
    1f08:	78 87       	std	Y+8, r23	; 0x08
    1f0a:	6f 83       	std	Y+7, r22	; 0x07
    1f0c:	5a 87       	std	Y+10, r21	; 0x0a
    1f0e:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1f10:	8d 81       	ldd	r24, Y+5	; 0x05
    1f12:	9e 81       	ldd	r25, Y+6	; 0x06
    1f14:	9a 83       	std	Y+2, r25	; 0x02
    1f16:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f18:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f20:	88 23       	and	r24, r24
    1f22:	91 f1       	breq	.+100    	; 0x1f88 <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f24:	89 81       	ldd	r24, Y+1	; 0x01
    1f26:	9a 81       	ldd	r25, Y+2	; 0x02
    1f28:	2f 81       	ldd	r18, Y+7	; 0x07
    1f2a:	38 85       	ldd	r19, Y+8	; 0x08
    1f2c:	b9 01       	movw	r22, r18
    1f2e:	0e 94 22 11 	call	0x2244	; 0x2244 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1f32:	e9 81       	ldd	r30, Y+1	; 0x01
    1f34:	fa 81       	ldd	r31, Y+2	; 0x02
    1f36:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f38:	81 50       	subi	r24, 0x01	; 1
    1f3a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f3e:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1f40:	e9 81       	ldd	r30, Y+1	; 0x01
    1f42:	fa 81       	ldd	r31, Y+2	; 0x02
    1f44:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f46:	8f 3f       	cpi	r24, 0xFF	; 255
    1f48:	a9 f4       	brne	.+42     	; 0x1f74 <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f4e:	80 85       	ldd	r24, Z+8	; 0x08
    1f50:	88 23       	and	r24, r24
    1f52:	b9 f0       	breq	.+46     	; 0x1f82 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f54:	89 81       	ldd	r24, Y+1	; 0x01
    1f56:	9a 81       	ldd	r25, Y+2	; 0x02
    1f58:	08 96       	adiw	r24, 0x08	; 8
    1f5a:	0e 94 97 18 	call	0x312e	; 0x312e <xTaskRemoveFromEventList>
    1f5e:	88 23       	and	r24, r24
    1f60:	81 f0       	breq	.+32     	; 0x1f82 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1f62:	89 85       	ldd	r24, Y+9	; 0x09
    1f64:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f66:	00 97       	sbiw	r24, 0x00	; 0
    1f68:	61 f0       	breq	.+24     	; 0x1f82 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1f6a:	e9 85       	ldd	r30, Y+9	; 0x09
    1f6c:	fa 85       	ldd	r31, Y+10	; 0x0a
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	80 83       	st	Z, r24
    1f72:	07 c0       	rjmp	.+14     	; 0x1f82 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1f74:	e9 81       	ldd	r30, Y+1	; 0x01
    1f76:	fa 81       	ldd	r31, Y+2	; 0x02
    1f78:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f7a:	8f 5f       	subi	r24, 0xFF	; 255
    1f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f80:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1f82:	81 e0       	ldi	r24, 0x01	; 1
    1f84:	8c 83       	std	Y+4, r24	; 0x04
    1f86:	01 c0       	rjmp	.+2      	; 0x1f8a <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    1f88:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f8a:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1f8c:	2a 96       	adiw	r28, 0x0a	; 10
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	de bf       	out	0x3e, r29	; 62
    1f94:	0f be       	out	0x3f, r0	; 63
    1f96:	cd bf       	out	0x3d, r28	; 61
    1f98:	cf 91       	pop	r28
    1f9a:	df 91       	pop	r29
    1f9c:	08 95       	ret

00001f9e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1f9e:	df 93       	push	r29
    1fa0:	cf 93       	push	r28
    1fa2:	cd b7       	in	r28, 0x3d	; 61
    1fa4:	de b7       	in	r29, 0x3e	; 62
    1fa6:	2a 97       	sbiw	r28, 0x0a	; 10
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	de bf       	out	0x3e, r29	; 62
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	cd bf       	out	0x3d, r28	; 61
    1fb2:	98 87       	std	Y+8, r25	; 0x08
    1fb4:	8f 83       	std	Y+7, r24	; 0x07
    1fb6:	7a 87       	std	Y+10, r23	; 0x0a
    1fb8:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1fba:	8f 81       	ldd	r24, Y+7	; 0x07
    1fbc:	98 85       	ldd	r25, Y+8	; 0x08
    1fbe:	9a 83       	std	Y+2, r25	; 0x02
    1fc0:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fc2:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1fc4:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc6:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fca:	88 23       	and	r24, r24
    1fcc:	b1 f0       	breq	.+44     	; 0x1ffa <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1fce:	e9 81       	ldd	r30, Y+1	; 0x01
    1fd0:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd2:	86 81       	ldd	r24, Z+6	; 0x06
    1fd4:	97 81       	ldd	r25, Z+7	; 0x07
    1fd6:	9c 83       	std	Y+4, r25	; 0x04
    1fd8:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1fda:	89 81       	ldd	r24, Y+1	; 0x01
    1fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1fde:	29 85       	ldd	r18, Y+9	; 0x09
    1fe0:	3a 85       	ldd	r19, Y+10	; 0x0a
    1fe2:	b9 01       	movw	r22, r18
    1fe4:	0e 94 22 11 	call	0x2244	; 0x2244 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fea:	fa 81       	ldd	r31, Y+2	; 0x02
    1fec:	8b 81       	ldd	r24, Y+3	; 0x03
    1fee:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff0:	97 83       	std	Z+7, r25	; 0x07
    1ff2:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1ff4:	81 e0       	ldi	r24, 0x01	; 1
    1ff6:	8e 83       	std	Y+6, r24	; 0x06
    1ff8:	01 c0       	rjmp	.+2      	; 0x1ffc <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1ffa:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1ffc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1ffe:	2a 96       	adiw	r28, 0x0a	; 10
    2000:	0f b6       	in	r0, 0x3f	; 63
    2002:	f8 94       	cli
    2004:	de bf       	out	0x3e, r29	; 62
    2006:	0f be       	out	0x3f, r0	; 63
    2008:	cd bf       	out	0x3d, r28	; 61
    200a:	cf 91       	pop	r28
    200c:	df 91       	pop	r29
    200e:	08 95       	ret

00002010 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2010:	df 93       	push	r29
    2012:	cf 93       	push	r28
    2014:	00 d0       	rcall	.+0      	; 0x2016 <uxQueueMessagesWaiting+0x6>
    2016:	0f 92       	push	r0
    2018:	cd b7       	in	r28, 0x3d	; 61
    201a:	de b7       	in	r29, 0x3e	; 62
    201c:	9b 83       	std	Y+3, r25	; 0x03
    201e:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2020:	0f b6       	in	r0, 0x3f	; 63
    2022:	f8 94       	cli
    2024:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2026:	ea 81       	ldd	r30, Y+2	; 0x02
    2028:	fb 81       	ldd	r31, Y+3	; 0x03
    202a:	82 8d       	ldd	r24, Z+26	; 0x1a
    202c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    202e:	0f 90       	pop	r0
    2030:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2032:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2034:	0f 90       	pop	r0
    2036:	0f 90       	pop	r0
    2038:	0f 90       	pop	r0
    203a:	cf 91       	pop	r28
    203c:	df 91       	pop	r29
    203e:	08 95       	ret

00002040 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2040:	df 93       	push	r29
    2042:	cf 93       	push	r28
    2044:	00 d0       	rcall	.+0      	; 0x2046 <uxQueueSpacesAvailable+0x6>
    2046:	00 d0       	rcall	.+0      	; 0x2048 <uxQueueSpacesAvailable+0x8>
    2048:	0f 92       	push	r0
    204a:	cd b7       	in	r28, 0x3d	; 61
    204c:	de b7       	in	r29, 0x3e	; 62
    204e:	9d 83       	std	Y+5, r25	; 0x05
    2050:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2052:	8c 81       	ldd	r24, Y+4	; 0x04
    2054:	9d 81       	ldd	r25, Y+5	; 0x05
    2056:	9a 83       	std	Y+2, r25	; 0x02
    2058:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    205a:	0f b6       	in	r0, 0x3f	; 63
    205c:	f8 94       	cli
    205e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2060:	e9 81       	ldd	r30, Y+1	; 0x01
    2062:	fa 81       	ldd	r31, Y+2	; 0x02
    2064:	93 8d       	ldd	r25, Z+27	; 0x1b
    2066:	e9 81       	ldd	r30, Y+1	; 0x01
    2068:	fa 81       	ldd	r31, Y+2	; 0x02
    206a:	82 8d       	ldd	r24, Z+26	; 0x1a
    206c:	29 2f       	mov	r18, r25
    206e:	28 1b       	sub	r18, r24
    2070:	82 2f       	mov	r24, r18
    2072:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2074:	0f 90       	pop	r0
    2076:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2078:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    207a:	0f 90       	pop	r0
    207c:	0f 90       	pop	r0
    207e:	0f 90       	pop	r0
    2080:	0f 90       	pop	r0
    2082:	0f 90       	pop	r0
    2084:	cf 91       	pop	r28
    2086:	df 91       	pop	r29
    2088:	08 95       	ret

0000208a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    208a:	df 93       	push	r29
    208c:	cf 93       	push	r28
    208e:	00 d0       	rcall	.+0      	; 0x2090 <uxQueueMessagesWaitingFromISR+0x6>
    2090:	0f 92       	push	r0
    2092:	cd b7       	in	r28, 0x3d	; 61
    2094:	de b7       	in	r29, 0x3e	; 62
    2096:	9b 83       	std	Y+3, r25	; 0x03
    2098:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    209a:	ea 81       	ldd	r30, Y+2	; 0x02
    209c:	fb 81       	ldd	r31, Y+3	; 0x03
    209e:	82 8d       	ldd	r24, Z+26	; 0x1a
    20a0:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    20a2:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    20a4:	0f 90       	pop	r0
    20a6:	0f 90       	pop	r0
    20a8:	0f 90       	pop	r0
    20aa:	cf 91       	pop	r28
    20ac:	df 91       	pop	r29
    20ae:	08 95       	ret

000020b0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    20b0:	df 93       	push	r29
    20b2:	cf 93       	push	r28
    20b4:	00 d0       	rcall	.+0      	; 0x20b6 <vQueueDelete+0x6>
    20b6:	00 d0       	rcall	.+0      	; 0x20b8 <vQueueDelete+0x8>
    20b8:	cd b7       	in	r28, 0x3d	; 61
    20ba:	de b7       	in	r29, 0x3e	; 62
    20bc:	9c 83       	std	Y+4, r25	; 0x04
    20be:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    20c0:	8b 81       	ldd	r24, Y+3	; 0x03
    20c2:	9c 81       	ldd	r25, Y+4	; 0x04
    20c4:	9a 83       	std	Y+2, r25	; 0x02
    20c6:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    20c8:	e9 81       	ldd	r30, Y+1	; 0x01
    20ca:	fa 81       	ldd	r31, Y+2	; 0x02
    20cc:	80 81       	ld	r24, Z
    20ce:	91 81       	ldd	r25, Z+1	; 0x01
    20d0:	00 97       	sbiw	r24, 0x00	; 0
    20d2:	31 f0       	breq	.+12     	; 0x20e0 <vQueueDelete+0x30>
	{
		vPortFree( pxQueue->pcHead );
    20d4:	e9 81       	ldd	r30, Y+1	; 0x01
    20d6:	fa 81       	ldd	r31, Y+2	; 0x02
    20d8:	80 81       	ld	r24, Z
    20da:	91 81       	ldd	r25, Z+1	; 0x01
    20dc:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
	}
	vPortFree( pxQueue );
    20e0:	89 81       	ldd	r24, Y+1	; 0x01
    20e2:	9a 81       	ldd	r25, Y+2	; 0x02
    20e4:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
}
    20e8:	0f 90       	pop	r0
    20ea:	0f 90       	pop	r0
    20ec:	0f 90       	pop	r0
    20ee:	0f 90       	pop	r0
    20f0:	cf 91       	pop	r28
    20f2:	df 91       	pop	r29
    20f4:	08 95       	ret

000020f6 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    20f6:	df 93       	push	r29
    20f8:	cf 93       	push	r28
    20fa:	00 d0       	rcall	.+0      	; 0x20fc <prvCopyDataToQueue+0x6>
    20fc:	00 d0       	rcall	.+0      	; 0x20fe <prvCopyDataToQueue+0x8>
    20fe:	00 d0       	rcall	.+0      	; 0x2100 <prvCopyDataToQueue+0xa>
    2100:	cd b7       	in	r28, 0x3d	; 61
    2102:	de b7       	in	r29, 0x3e	; 62
    2104:	9b 83       	std	Y+3, r25	; 0x03
    2106:	8a 83       	std	Y+2, r24	; 0x02
    2108:	7d 83       	std	Y+5, r23	; 0x05
    210a:	6c 83       	std	Y+4, r22	; 0x04
    210c:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    210e:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2110:	ea 81       	ldd	r30, Y+2	; 0x02
    2112:	fb 81       	ldd	r31, Y+3	; 0x03
    2114:	84 8d       	ldd	r24, Z+28	; 0x1c
    2116:	88 23       	and	r24, r24
    2118:	09 f4       	brne	.+2      	; 0x211c <prvCopyDataToQueue+0x26>
    211a:	83 c0       	rjmp	.+262    	; 0x2222 <prvCopyDataToQueue+0x12c>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    211c:	8e 81       	ldd	r24, Y+6	; 0x06
    211e:	88 23       	and	r24, r24
    2120:	99 f5       	brne	.+102    	; 0x2188 <prvCopyDataToQueue+0x92>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2122:	ea 81       	ldd	r30, Y+2	; 0x02
    2124:	fb 81       	ldd	r31, Y+3	; 0x03
    2126:	64 81       	ldd	r22, Z+4	; 0x04
    2128:	75 81       	ldd	r23, Z+5	; 0x05
    212a:	ea 81       	ldd	r30, Y+2	; 0x02
    212c:	fb 81       	ldd	r31, Y+3	; 0x03
    212e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2130:	48 2f       	mov	r20, r24
    2132:	50 e0       	ldi	r21, 0x00	; 0
    2134:	2c 81       	ldd	r18, Y+4	; 0x04
    2136:	3d 81       	ldd	r19, Y+5	; 0x05
    2138:	cb 01       	movw	r24, r22
    213a:	b9 01       	movw	r22, r18
    213c:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2140:	ea 81       	ldd	r30, Y+2	; 0x02
    2142:	fb 81       	ldd	r31, Y+3	; 0x03
    2144:	24 81       	ldd	r18, Z+4	; 0x04
    2146:	35 81       	ldd	r19, Z+5	; 0x05
    2148:	ea 81       	ldd	r30, Y+2	; 0x02
    214a:	fb 81       	ldd	r31, Y+3	; 0x03
    214c:	84 8d       	ldd	r24, Z+28	; 0x1c
    214e:	88 2f       	mov	r24, r24
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	82 0f       	add	r24, r18
    2154:	93 1f       	adc	r25, r19
    2156:	ea 81       	ldd	r30, Y+2	; 0x02
    2158:	fb 81       	ldd	r31, Y+3	; 0x03
    215a:	95 83       	std	Z+5, r25	; 0x05
    215c:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    215e:	ea 81       	ldd	r30, Y+2	; 0x02
    2160:	fb 81       	ldd	r31, Y+3	; 0x03
    2162:	24 81       	ldd	r18, Z+4	; 0x04
    2164:	35 81       	ldd	r19, Z+5	; 0x05
    2166:	ea 81       	ldd	r30, Y+2	; 0x02
    2168:	fb 81       	ldd	r31, Y+3	; 0x03
    216a:	82 81       	ldd	r24, Z+2	; 0x02
    216c:	93 81       	ldd	r25, Z+3	; 0x03
    216e:	28 17       	cp	r18, r24
    2170:	39 07       	cpc	r19, r25
    2172:	08 f4       	brcc	.+2      	; 0x2176 <prvCopyDataToQueue+0x80>
    2174:	56 c0       	rjmp	.+172    	; 0x2222 <prvCopyDataToQueue+0x12c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2176:	ea 81       	ldd	r30, Y+2	; 0x02
    2178:	fb 81       	ldd	r31, Y+3	; 0x03
    217a:	80 81       	ld	r24, Z
    217c:	91 81       	ldd	r25, Z+1	; 0x01
    217e:	ea 81       	ldd	r30, Y+2	; 0x02
    2180:	fb 81       	ldd	r31, Y+3	; 0x03
    2182:	95 83       	std	Z+5, r25	; 0x05
    2184:	84 83       	std	Z+4, r24	; 0x04
    2186:	4d c0       	rjmp	.+154    	; 0x2222 <prvCopyDataToQueue+0x12c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2188:	ea 81       	ldd	r30, Y+2	; 0x02
    218a:	fb 81       	ldd	r31, Y+3	; 0x03
    218c:	66 81       	ldd	r22, Z+6	; 0x06
    218e:	77 81       	ldd	r23, Z+7	; 0x07
    2190:	ea 81       	ldd	r30, Y+2	; 0x02
    2192:	fb 81       	ldd	r31, Y+3	; 0x03
    2194:	84 8d       	ldd	r24, Z+28	; 0x1c
    2196:	48 2f       	mov	r20, r24
    2198:	50 e0       	ldi	r21, 0x00	; 0
    219a:	2c 81       	ldd	r18, Y+4	; 0x04
    219c:	3d 81       	ldd	r19, Y+5	; 0x05
    219e:	cb 01       	movw	r24, r22
    21a0:	b9 01       	movw	r22, r18
    21a2:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    21a6:	ea 81       	ldd	r30, Y+2	; 0x02
    21a8:	fb 81       	ldd	r31, Y+3	; 0x03
    21aa:	26 81       	ldd	r18, Z+6	; 0x06
    21ac:	37 81       	ldd	r19, Z+7	; 0x07
    21ae:	ea 81       	ldd	r30, Y+2	; 0x02
    21b0:	fb 81       	ldd	r31, Y+3	; 0x03
    21b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    21b4:	88 2f       	mov	r24, r24
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	90 95       	com	r25
    21ba:	81 95       	neg	r24
    21bc:	9f 4f       	sbci	r25, 0xFF	; 255
    21be:	82 0f       	add	r24, r18
    21c0:	93 1f       	adc	r25, r19
    21c2:	ea 81       	ldd	r30, Y+2	; 0x02
    21c4:	fb 81       	ldd	r31, Y+3	; 0x03
    21c6:	97 83       	std	Z+7, r25	; 0x07
    21c8:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    21ca:	ea 81       	ldd	r30, Y+2	; 0x02
    21cc:	fb 81       	ldd	r31, Y+3	; 0x03
    21ce:	26 81       	ldd	r18, Z+6	; 0x06
    21d0:	37 81       	ldd	r19, Z+7	; 0x07
    21d2:	ea 81       	ldd	r30, Y+2	; 0x02
    21d4:	fb 81       	ldd	r31, Y+3	; 0x03
    21d6:	80 81       	ld	r24, Z
    21d8:	91 81       	ldd	r25, Z+1	; 0x01
    21da:	28 17       	cp	r18, r24
    21dc:	39 07       	cpc	r19, r25
    21de:	90 f4       	brcc	.+36     	; 0x2204 <prvCopyDataToQueue+0x10e>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    21e0:	ea 81       	ldd	r30, Y+2	; 0x02
    21e2:	fb 81       	ldd	r31, Y+3	; 0x03
    21e4:	22 81       	ldd	r18, Z+2	; 0x02
    21e6:	33 81       	ldd	r19, Z+3	; 0x03
    21e8:	ea 81       	ldd	r30, Y+2	; 0x02
    21ea:	fb 81       	ldd	r31, Y+3	; 0x03
    21ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    21ee:	88 2f       	mov	r24, r24
    21f0:	90 e0       	ldi	r25, 0x00	; 0
    21f2:	90 95       	com	r25
    21f4:	81 95       	neg	r24
    21f6:	9f 4f       	sbci	r25, 0xFF	; 255
    21f8:	82 0f       	add	r24, r18
    21fa:	93 1f       	adc	r25, r19
    21fc:	ea 81       	ldd	r30, Y+2	; 0x02
    21fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2200:	97 83       	std	Z+7, r25	; 0x07
    2202:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2204:	8e 81       	ldd	r24, Y+6	; 0x06
    2206:	82 30       	cpi	r24, 0x02	; 2
    2208:	61 f4       	brne	.+24     	; 0x2222 <prvCopyDataToQueue+0x12c>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    220a:	ea 81       	ldd	r30, Y+2	; 0x02
    220c:	fb 81       	ldd	r31, Y+3	; 0x03
    220e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2210:	88 23       	and	r24, r24
    2212:	39 f0       	breq	.+14     	; 0x2222 <prvCopyDataToQueue+0x12c>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    2214:	ea 81       	ldd	r30, Y+2	; 0x02
    2216:	fb 81       	ldd	r31, Y+3	; 0x03
    2218:	82 8d       	ldd	r24, Z+26	; 0x1a
    221a:	81 50       	subi	r24, 0x01	; 1
    221c:	ea 81       	ldd	r30, Y+2	; 0x02
    221e:	fb 81       	ldd	r31, Y+3	; 0x03
    2220:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2222:	ea 81       	ldd	r30, Y+2	; 0x02
    2224:	fb 81       	ldd	r31, Y+3	; 0x03
    2226:	82 8d       	ldd	r24, Z+26	; 0x1a
    2228:	8f 5f       	subi	r24, 0xFF	; 255
    222a:	ea 81       	ldd	r30, Y+2	; 0x02
    222c:	fb 81       	ldd	r31, Y+3	; 0x03
    222e:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2230:	89 81       	ldd	r24, Y+1	; 0x01
}
    2232:	26 96       	adiw	r28, 0x06	; 6
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	f8 94       	cli
    2238:	de bf       	out	0x3e, r29	; 62
    223a:	0f be       	out	0x3f, r0	; 63
    223c:	cd bf       	out	0x3d, r28	; 61
    223e:	cf 91       	pop	r28
    2240:	df 91       	pop	r29
    2242:	08 95       	ret

00002244 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2244:	df 93       	push	r29
    2246:	cf 93       	push	r28
    2248:	00 d0       	rcall	.+0      	; 0x224a <prvCopyDataFromQueue+0x6>
    224a:	00 d0       	rcall	.+0      	; 0x224c <prvCopyDataFromQueue+0x8>
    224c:	cd b7       	in	r28, 0x3d	; 61
    224e:	de b7       	in	r29, 0x3e	; 62
    2250:	9a 83       	std	Y+2, r25	; 0x02
    2252:	89 83       	std	Y+1, r24	; 0x01
    2254:	7c 83       	std	Y+4, r23	; 0x04
    2256:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2258:	e9 81       	ldd	r30, Y+1	; 0x01
    225a:	fa 81       	ldd	r31, Y+2	; 0x02
    225c:	84 8d       	ldd	r24, Z+28	; 0x1c
    225e:	88 23       	and	r24, r24
    2260:	89 f1       	breq	.+98     	; 0x22c4 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2262:	e9 81       	ldd	r30, Y+1	; 0x01
    2264:	fa 81       	ldd	r31, Y+2	; 0x02
    2266:	26 81       	ldd	r18, Z+6	; 0x06
    2268:	37 81       	ldd	r19, Z+7	; 0x07
    226a:	e9 81       	ldd	r30, Y+1	; 0x01
    226c:	fa 81       	ldd	r31, Y+2	; 0x02
    226e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2270:	88 2f       	mov	r24, r24
    2272:	90 e0       	ldi	r25, 0x00	; 0
    2274:	82 0f       	add	r24, r18
    2276:	93 1f       	adc	r25, r19
    2278:	e9 81       	ldd	r30, Y+1	; 0x01
    227a:	fa 81       	ldd	r31, Y+2	; 0x02
    227c:	97 83       	std	Z+7, r25	; 0x07
    227e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2280:	e9 81       	ldd	r30, Y+1	; 0x01
    2282:	fa 81       	ldd	r31, Y+2	; 0x02
    2284:	26 81       	ldd	r18, Z+6	; 0x06
    2286:	37 81       	ldd	r19, Z+7	; 0x07
    2288:	e9 81       	ldd	r30, Y+1	; 0x01
    228a:	fa 81       	ldd	r31, Y+2	; 0x02
    228c:	82 81       	ldd	r24, Z+2	; 0x02
    228e:	93 81       	ldd	r25, Z+3	; 0x03
    2290:	28 17       	cp	r18, r24
    2292:	39 07       	cpc	r19, r25
    2294:	40 f0       	brcs	.+16     	; 0x22a6 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2296:	e9 81       	ldd	r30, Y+1	; 0x01
    2298:	fa 81       	ldd	r31, Y+2	; 0x02
    229a:	80 81       	ld	r24, Z
    229c:	91 81       	ldd	r25, Z+1	; 0x01
    229e:	e9 81       	ldd	r30, Y+1	; 0x01
    22a0:	fa 81       	ldd	r31, Y+2	; 0x02
    22a2:	97 83       	std	Z+7, r25	; 0x07
    22a4:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    22a6:	e9 81       	ldd	r30, Y+1	; 0x01
    22a8:	fa 81       	ldd	r31, Y+2	; 0x02
    22aa:	46 81       	ldd	r20, Z+6	; 0x06
    22ac:	57 81       	ldd	r21, Z+7	; 0x07
    22ae:	e9 81       	ldd	r30, Y+1	; 0x01
    22b0:	fa 81       	ldd	r31, Y+2	; 0x02
    22b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    22b4:	28 2f       	mov	r18, r24
    22b6:	30 e0       	ldi	r19, 0x00	; 0
    22b8:	8b 81       	ldd	r24, Y+3	; 0x03
    22ba:	9c 81       	ldd	r25, Y+4	; 0x04
    22bc:	ba 01       	movw	r22, r20
    22be:	a9 01       	movw	r20, r18
    22c0:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <memcpy>
	}
}
    22c4:	0f 90       	pop	r0
    22c6:	0f 90       	pop	r0
    22c8:	0f 90       	pop	r0
    22ca:	0f 90       	pop	r0
    22cc:	cf 91       	pop	r28
    22ce:	df 91       	pop	r29
    22d0:	08 95       	ret

000022d2 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    22d2:	df 93       	push	r29
    22d4:	cf 93       	push	r28
    22d6:	00 d0       	rcall	.+0      	; 0x22d8 <prvUnlockQueue+0x6>
    22d8:	cd b7       	in	r28, 0x3d	; 61
    22da:	de b7       	in	r29, 0x3e	; 62
    22dc:	9a 83       	std	Y+2, r25	; 0x02
    22de:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    22e0:	0f b6       	in	r0, 0x3f	; 63
    22e2:	f8 94       	cli
    22e4:	0f 92       	push	r0
    22e6:	15 c0       	rjmp	.+42     	; 0x2312 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22e8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ea:	fa 81       	ldd	r31, Y+2	; 0x02
    22ec:	81 89       	ldd	r24, Z+17	; 0x11
    22ee:	88 23       	and	r24, r24
    22f0:	a9 f0       	breq	.+42     	; 0x231c <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22f2:	89 81       	ldd	r24, Y+1	; 0x01
    22f4:	9a 81       	ldd	r25, Y+2	; 0x02
    22f6:	41 96       	adiw	r24, 0x11	; 17
    22f8:	0e 94 97 18 	call	0x312e	; 0x312e <xTaskRemoveFromEventList>
    22fc:	88 23       	and	r24, r24
    22fe:	11 f0       	breq	.+4      	; 0x2304 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2300:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2304:	e9 81       	ldd	r30, Y+1	; 0x01
    2306:	fa 81       	ldd	r31, Y+2	; 0x02
    2308:	86 8d       	ldd	r24, Z+30	; 0x1e
    230a:	81 50       	subi	r24, 0x01	; 1
    230c:	e9 81       	ldd	r30, Y+1	; 0x01
    230e:	fa 81       	ldd	r31, Y+2	; 0x02
    2310:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2312:	e9 81       	ldd	r30, Y+1	; 0x01
    2314:	fa 81       	ldd	r31, Y+2	; 0x02
    2316:	86 8d       	ldd	r24, Z+30	; 0x1e
    2318:	18 16       	cp	r1, r24
    231a:	34 f3       	brlt	.-52     	; 0x22e8 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    231c:	e9 81       	ldd	r30, Y+1	; 0x01
    231e:	fa 81       	ldd	r31, Y+2	; 0x02
    2320:	8f ef       	ldi	r24, 0xFF	; 255
    2322:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2324:	0f 90       	pop	r0
    2326:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2328:	0f b6       	in	r0, 0x3f	; 63
    232a:	f8 94       	cli
    232c:	0f 92       	push	r0
    232e:	15 c0       	rjmp	.+42     	; 0x235a <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2330:	e9 81       	ldd	r30, Y+1	; 0x01
    2332:	fa 81       	ldd	r31, Y+2	; 0x02
    2334:	80 85       	ldd	r24, Z+8	; 0x08
    2336:	88 23       	and	r24, r24
    2338:	a9 f0       	breq	.+42     	; 0x2364 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    233a:	89 81       	ldd	r24, Y+1	; 0x01
    233c:	9a 81       	ldd	r25, Y+2	; 0x02
    233e:	08 96       	adiw	r24, 0x08	; 8
    2340:	0e 94 97 18 	call	0x312e	; 0x312e <xTaskRemoveFromEventList>
    2344:	88 23       	and	r24, r24
    2346:	11 f0       	breq	.+4      	; 0x234c <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2348:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    234c:	e9 81       	ldd	r30, Y+1	; 0x01
    234e:	fa 81       	ldd	r31, Y+2	; 0x02
    2350:	85 8d       	ldd	r24, Z+29	; 0x1d
    2352:	81 50       	subi	r24, 0x01	; 1
    2354:	e9 81       	ldd	r30, Y+1	; 0x01
    2356:	fa 81       	ldd	r31, Y+2	; 0x02
    2358:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    235a:	e9 81       	ldd	r30, Y+1	; 0x01
    235c:	fa 81       	ldd	r31, Y+2	; 0x02
    235e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2360:	18 16       	cp	r1, r24
    2362:	34 f3       	brlt	.-52     	; 0x2330 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2364:	e9 81       	ldd	r30, Y+1	; 0x01
    2366:	fa 81       	ldd	r31, Y+2	; 0x02
    2368:	8f ef       	ldi	r24, 0xFF	; 255
    236a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    236c:	0f 90       	pop	r0
    236e:	0f be       	out	0x3f, r0	; 63
}
    2370:	0f 90       	pop	r0
    2372:	0f 90       	pop	r0
    2374:	cf 91       	pop	r28
    2376:	df 91       	pop	r29
    2378:	08 95       	ret

0000237a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    237a:	df 93       	push	r29
    237c:	cf 93       	push	r28
    237e:	00 d0       	rcall	.+0      	; 0x2380 <prvIsQueueEmpty+0x6>
    2380:	0f 92       	push	r0
    2382:	cd b7       	in	r28, 0x3d	; 61
    2384:	de b7       	in	r29, 0x3e	; 62
    2386:	9b 83       	std	Y+3, r25	; 0x03
    2388:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    238a:	0f b6       	in	r0, 0x3f	; 63
    238c:	f8 94       	cli
    238e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2390:	ea 81       	ldd	r30, Y+2	; 0x02
    2392:	fb 81       	ldd	r31, Y+3	; 0x03
    2394:	82 8d       	ldd	r24, Z+26	; 0x1a
    2396:	88 23       	and	r24, r24
    2398:	19 f4       	brne	.+6      	; 0x23a0 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    239a:	81 e0       	ldi	r24, 0x01	; 1
    239c:	89 83       	std	Y+1, r24	; 0x01
    239e:	01 c0       	rjmp	.+2      	; 0x23a2 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    23a0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    23a2:	0f 90       	pop	r0
    23a4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    23a8:	0f 90       	pop	r0
    23aa:	0f 90       	pop	r0
    23ac:	0f 90       	pop	r0
    23ae:	cf 91       	pop	r28
    23b0:	df 91       	pop	r29
    23b2:	08 95       	ret

000023b4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    23b4:	df 93       	push	r29
    23b6:	cf 93       	push	r28
    23b8:	00 d0       	rcall	.+0      	; 0x23ba <xQueueIsQueueEmptyFromISR+0x6>
    23ba:	0f 92       	push	r0
    23bc:	cd b7       	in	r28, 0x3d	; 61
    23be:	de b7       	in	r29, 0x3e	; 62
    23c0:	9b 83       	std	Y+3, r25	; 0x03
    23c2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    23c4:	ea 81       	ldd	r30, Y+2	; 0x02
    23c6:	fb 81       	ldd	r31, Y+3	; 0x03
    23c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    23ca:	88 23       	and	r24, r24
    23cc:	19 f4       	brne	.+6      	; 0x23d4 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    23ce:	81 e0       	ldi	r24, 0x01	; 1
    23d0:	89 83       	std	Y+1, r24	; 0x01
    23d2:	01 c0       	rjmp	.+2      	; 0x23d6 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    23d4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    23d6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    23d8:	0f 90       	pop	r0
    23da:	0f 90       	pop	r0
    23dc:	0f 90       	pop	r0
    23de:	cf 91       	pop	r28
    23e0:	df 91       	pop	r29
    23e2:	08 95       	ret

000023e4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    23e4:	df 93       	push	r29
    23e6:	cf 93       	push	r28
    23e8:	00 d0       	rcall	.+0      	; 0x23ea <prvIsQueueFull+0x6>
    23ea:	0f 92       	push	r0
    23ec:	cd b7       	in	r28, 0x3d	; 61
    23ee:	de b7       	in	r29, 0x3e	; 62
    23f0:	9b 83       	std	Y+3, r25	; 0x03
    23f2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    23f4:	0f b6       	in	r0, 0x3f	; 63
    23f6:	f8 94       	cli
    23f8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    23fa:	ea 81       	ldd	r30, Y+2	; 0x02
    23fc:	fb 81       	ldd	r31, Y+3	; 0x03
    23fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    2400:	ea 81       	ldd	r30, Y+2	; 0x02
    2402:	fb 81       	ldd	r31, Y+3	; 0x03
    2404:	83 8d       	ldd	r24, Z+27	; 0x1b
    2406:	98 17       	cp	r25, r24
    2408:	19 f4       	brne	.+6      	; 0x2410 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    240a:	81 e0       	ldi	r24, 0x01	; 1
    240c:	89 83       	std	Y+1, r24	; 0x01
    240e:	01 c0       	rjmp	.+2      	; 0x2412 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2410:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2412:	0f 90       	pop	r0
    2414:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2416:	89 81       	ldd	r24, Y+1	; 0x01
}
    2418:	0f 90       	pop	r0
    241a:	0f 90       	pop	r0
    241c:	0f 90       	pop	r0
    241e:	cf 91       	pop	r28
    2420:	df 91       	pop	r29
    2422:	08 95       	ret

00002424 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2424:	df 93       	push	r29
    2426:	cf 93       	push	r28
    2428:	00 d0       	rcall	.+0      	; 0x242a <xQueueIsQueueFullFromISR+0x6>
    242a:	0f 92       	push	r0
    242c:	cd b7       	in	r28, 0x3d	; 61
    242e:	de b7       	in	r29, 0x3e	; 62
    2430:	9b 83       	std	Y+3, r25	; 0x03
    2432:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    2434:	ea 81       	ldd	r30, Y+2	; 0x02
    2436:	fb 81       	ldd	r31, Y+3	; 0x03
    2438:	92 8d       	ldd	r25, Z+26	; 0x1a
    243a:	ea 81       	ldd	r30, Y+2	; 0x02
    243c:	fb 81       	ldd	r31, Y+3	; 0x03
    243e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2440:	98 17       	cp	r25, r24
    2442:	19 f4       	brne	.+6      	; 0x244a <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    2444:	81 e0       	ldi	r24, 0x01	; 1
    2446:	89 83       	std	Y+1, r24	; 0x01
    2448:	01 c0       	rjmp	.+2      	; 0x244c <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    244a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    244c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    244e:	0f 90       	pop	r0
    2450:	0f 90       	pop	r0
    2452:	0f 90       	pop	r0
    2454:	cf 91       	pop	r28
    2456:	df 91       	pop	r29
    2458:	08 95       	ret

0000245a <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    245a:	df 93       	push	r29
    245c:	cf 93       	push	r28
    245e:	cd b7       	in	r28, 0x3d	; 61
    2460:	de b7       	in	r29, 0x3e	; 62
    2462:	2a 97       	sbiw	r28, 0x0a	; 10
    2464:	0f b6       	in	r0, 0x3f	; 63
    2466:	f8 94       	cli
    2468:	de bf       	out	0x3e, r29	; 62
    246a:	0f be       	out	0x3f, r0	; 63
    246c:	cd bf       	out	0x3d, r28	; 61
    246e:	9d 83       	std	Y+5, r25	; 0x05
    2470:	8c 83       	std	Y+4, r24	; 0x04
    2472:	7f 83       	std	Y+7, r23	; 0x07
    2474:	6e 83       	std	Y+6, r22	; 0x06
    2476:	59 87       	std	Y+9, r21	; 0x09
    2478:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    247a:	8c 81       	ldd	r24, Y+4	; 0x04
    247c:	9d 81       	ldd	r25, Y+5	; 0x05
    247e:	9a 83       	std	Y+2, r25	; 0x02
    2480:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2482:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2484:	89 81       	ldd	r24, Y+1	; 0x01
    2486:	9a 81       	ldd	r25, Y+2	; 0x02
    2488:	0e 94 f2 11 	call	0x23e4	; 0x23e4 <prvIsQueueFull>
    248c:	88 23       	and	r24, r24
    248e:	a9 f0       	breq	.+42     	; 0x24ba <xQueueCRSend+0x60>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2490:	88 85       	ldd	r24, Y+8	; 0x08
    2492:	99 85       	ldd	r25, Y+9	; 0x09
    2494:	00 97       	sbiw	r24, 0x00	; 0
    2496:	71 f0       	breq	.+28     	; 0x24b4 <xQueueCRSend+0x5a>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2498:	89 81       	ldd	r24, Y+1	; 0x01
    249a:	9a 81       	ldd	r25, Y+2	; 0x02
    249c:	9c 01       	movw	r18, r24
    249e:	28 5f       	subi	r18, 0xF8	; 248
    24a0:	3f 4f       	sbci	r19, 0xFF	; 255
    24a2:	88 85       	ldd	r24, Y+8	; 0x08
    24a4:	99 85       	ldd	r25, Y+9	; 0x09
    24a6:	b9 01       	movw	r22, r18
    24a8:	0e 94 c7 01 	call	0x38e	; 0x38e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    24ac:	78 94       	sei
					return errQUEUE_BLOCKED;
    24ae:	8c ef       	ldi	r24, 0xFC	; 252
    24b0:	8a 87       	std	Y+10, r24	; 0x0a
    24b2:	2a c0       	rjmp	.+84     	; 0x2508 <xQueueCRSend+0xae>
				}
				else
				{
					portENABLE_INTERRUPTS();
    24b4:	78 94       	sei
					return errQUEUE_FULL;
    24b6:	1a 86       	std	Y+10, r1	; 0x0a
    24b8:	27 c0       	rjmp	.+78     	; 0x2508 <xQueueCRSend+0xae>
				}
			}
		}
		portENABLE_INTERRUPTS();
    24ba:	78 94       	sei

		portDISABLE_INTERRUPTS();
    24bc:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    24be:	e9 81       	ldd	r30, Y+1	; 0x01
    24c0:	fa 81       	ldd	r31, Y+2	; 0x02
    24c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    24c4:	e9 81       	ldd	r30, Y+1	; 0x01
    24c6:	fa 81       	ldd	r31, Y+2	; 0x02
    24c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    24ca:	98 17       	cp	r25, r24
    24cc:	c8 f4       	brcc	.+50     	; 0x2500 <xQueueCRSend+0xa6>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    24ce:	89 81       	ldd	r24, Y+1	; 0x01
    24d0:	9a 81       	ldd	r25, Y+2	; 0x02
    24d2:	2e 81       	ldd	r18, Y+6	; 0x06
    24d4:	3f 81       	ldd	r19, Y+7	; 0x07
    24d6:	b9 01       	movw	r22, r18
    24d8:	40 e0       	ldi	r20, 0x00	; 0
    24da:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <prvCopyDataToQueue>
				xReturn = pdPASS;
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24e2:	e9 81       	ldd	r30, Y+1	; 0x01
    24e4:	fa 81       	ldd	r31, Y+2	; 0x02
    24e6:	81 89       	ldd	r24, Z+17	; 0x11
    24e8:	88 23       	and	r24, r24
    24ea:	59 f0       	breq	.+22     	; 0x2502 <xQueueCRSend+0xa8>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24ec:	89 81       	ldd	r24, Y+1	; 0x01
    24ee:	9a 81       	ldd	r25, Y+2	; 0x02
    24f0:	41 96       	adiw	r24, 0x11	; 17
    24f2:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <xCoRoutineRemoveFromEventList>
    24f6:	88 23       	and	r24, r24
    24f8:	21 f0       	breq	.+8      	; 0x2502 <xQueueCRSend+0xa8>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    24fa:	8b ef       	ldi	r24, 0xFB	; 251
    24fc:	8b 83       	std	Y+3, r24	; 0x03
    24fe:	01 c0       	rjmp	.+2      	; 0x2502 <xQueueCRSend+0xa8>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    2500:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    2502:	78 94       	sei

		return xReturn;
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
    2506:	8a 87       	std	Y+10, r24	; 0x0a
    2508:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    250a:	2a 96       	adiw	r28, 0x0a	; 10
    250c:	0f b6       	in	r0, 0x3f	; 63
    250e:	f8 94       	cli
    2510:	de bf       	out	0x3e, r29	; 62
    2512:	0f be       	out	0x3f, r0	; 63
    2514:	cd bf       	out	0x3d, r28	; 61
    2516:	cf 91       	pop	r28
    2518:	df 91       	pop	r29
    251a:	08 95       	ret

0000251c <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    251c:	df 93       	push	r29
    251e:	cf 93       	push	r28
    2520:	cd b7       	in	r28, 0x3d	; 61
    2522:	de b7       	in	r29, 0x3e	; 62
    2524:	2a 97       	sbiw	r28, 0x0a	; 10
    2526:	0f b6       	in	r0, 0x3f	; 63
    2528:	f8 94       	cli
    252a:	de bf       	out	0x3e, r29	; 62
    252c:	0f be       	out	0x3f, r0	; 63
    252e:	cd bf       	out	0x3d, r28	; 61
    2530:	9d 83       	std	Y+5, r25	; 0x05
    2532:	8c 83       	std	Y+4, r24	; 0x04
    2534:	7f 83       	std	Y+7, r23	; 0x07
    2536:	6e 83       	std	Y+6, r22	; 0x06
    2538:	59 87       	std	Y+9, r21	; 0x09
    253a:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    253c:	8c 81       	ldd	r24, Y+4	; 0x04
    253e:	9d 81       	ldd	r25, Y+5	; 0x05
    2540:	9a 83       	std	Y+2, r25	; 0x02
    2542:	89 83       	std	Y+1, r24	; 0x01

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    2544:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2546:	e9 81       	ldd	r30, Y+1	; 0x01
    2548:	fa 81       	ldd	r31, Y+2	; 0x02
    254a:	82 8d       	ldd	r24, Z+26	; 0x1a
    254c:	88 23       	and	r24, r24
    254e:	a9 f4       	brne	.+42     	; 0x257a <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    2550:	88 85       	ldd	r24, Y+8	; 0x08
    2552:	99 85       	ldd	r25, Y+9	; 0x09
    2554:	00 97       	sbiw	r24, 0x00	; 0
    2556:	71 f0       	breq	.+28     	; 0x2574 <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2558:	89 81       	ldd	r24, Y+1	; 0x01
    255a:	9a 81       	ldd	r25, Y+2	; 0x02
    255c:	9c 01       	movw	r18, r24
    255e:	2f 5e       	subi	r18, 0xEF	; 239
    2560:	3f 4f       	sbci	r19, 0xFF	; 255
    2562:	88 85       	ldd	r24, Y+8	; 0x08
    2564:	99 85       	ldd	r25, Y+9	; 0x09
    2566:	b9 01       	movw	r22, r18
    2568:	0e 94 c7 01 	call	0x38e	; 0x38e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    256c:	78 94       	sei
					return errQUEUE_BLOCKED;
    256e:	8c ef       	ldi	r24, 0xFC	; 252
    2570:	8a 87       	std	Y+10, r24	; 0x0a
    2572:	58 c0       	rjmp	.+176    	; 0x2624 <xQueueCRReceive+0x108>
				}
				else
				{
					portENABLE_INTERRUPTS();
    2574:	78 94       	sei
					return errQUEUE_FULL;
    2576:	1a 86       	std	Y+10, r1	; 0x0a
    2578:	55 c0       	rjmp	.+170    	; 0x2624 <xQueueCRReceive+0x108>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    257a:	78 94       	sei

		portDISABLE_INTERRUPTS();
    257c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    257e:	e9 81       	ldd	r30, Y+1	; 0x01
    2580:	fa 81       	ldd	r31, Y+2	; 0x02
    2582:	82 8d       	ldd	r24, Z+26	; 0x1a
    2584:	88 23       	and	r24, r24
    2586:	09 f4       	brne	.+2      	; 0x258a <xQueueCRReceive+0x6e>
    2588:	49 c0       	rjmp	.+146    	; 0x261c <xQueueCRReceive+0x100>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    258a:	e9 81       	ldd	r30, Y+1	; 0x01
    258c:	fa 81       	ldd	r31, Y+2	; 0x02
    258e:	26 81       	ldd	r18, Z+6	; 0x06
    2590:	37 81       	ldd	r19, Z+7	; 0x07
    2592:	e9 81       	ldd	r30, Y+1	; 0x01
    2594:	fa 81       	ldd	r31, Y+2	; 0x02
    2596:	84 8d       	ldd	r24, Z+28	; 0x1c
    2598:	88 2f       	mov	r24, r24
    259a:	90 e0       	ldi	r25, 0x00	; 0
    259c:	82 0f       	add	r24, r18
    259e:	93 1f       	adc	r25, r19
    25a0:	e9 81       	ldd	r30, Y+1	; 0x01
    25a2:	fa 81       	ldd	r31, Y+2	; 0x02
    25a4:	97 83       	std	Z+7, r25	; 0x07
    25a6:	86 83       	std	Z+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    25a8:	e9 81       	ldd	r30, Y+1	; 0x01
    25aa:	fa 81       	ldd	r31, Y+2	; 0x02
    25ac:	26 81       	ldd	r18, Z+6	; 0x06
    25ae:	37 81       	ldd	r19, Z+7	; 0x07
    25b0:	e9 81       	ldd	r30, Y+1	; 0x01
    25b2:	fa 81       	ldd	r31, Y+2	; 0x02
    25b4:	82 81       	ldd	r24, Z+2	; 0x02
    25b6:	93 81       	ldd	r25, Z+3	; 0x03
    25b8:	28 17       	cp	r18, r24
    25ba:	39 07       	cpc	r19, r25
    25bc:	40 f0       	brcs	.+16     	; 0x25ce <xQueueCRReceive+0xb2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    25be:	e9 81       	ldd	r30, Y+1	; 0x01
    25c0:	fa 81       	ldd	r31, Y+2	; 0x02
    25c2:	80 81       	ld	r24, Z
    25c4:	91 81       	ldd	r25, Z+1	; 0x01
    25c6:	e9 81       	ldd	r30, Y+1	; 0x01
    25c8:	fa 81       	ldd	r31, Y+2	; 0x02
    25ca:	97 83       	std	Z+7, r25	; 0x07
    25cc:	86 83       	std	Z+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    25ce:	e9 81       	ldd	r30, Y+1	; 0x01
    25d0:	fa 81       	ldd	r31, Y+2	; 0x02
    25d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    25d4:	81 50       	subi	r24, 0x01	; 1
    25d6:	e9 81       	ldd	r30, Y+1	; 0x01
    25d8:	fa 81       	ldd	r31, Y+2	; 0x02
    25da:	82 8f       	std	Z+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    25dc:	e9 81       	ldd	r30, Y+1	; 0x01
    25de:	fa 81       	ldd	r31, Y+2	; 0x02
    25e0:	46 81       	ldd	r20, Z+6	; 0x06
    25e2:	57 81       	ldd	r21, Z+7	; 0x07
    25e4:	e9 81       	ldd	r30, Y+1	; 0x01
    25e6:	fa 81       	ldd	r31, Y+2	; 0x02
    25e8:	84 8d       	ldd	r24, Z+28	; 0x1c
    25ea:	28 2f       	mov	r18, r24
    25ec:	30 e0       	ldi	r19, 0x00	; 0
    25ee:	8e 81       	ldd	r24, Y+6	; 0x06
    25f0:	9f 81       	ldd	r25, Y+7	; 0x07
    25f2:	ba 01       	movw	r22, r20
    25f4:	a9 01       	movw	r20, r18
    25f6:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <memcpy>

				xReturn = pdPASS;
    25fa:	81 e0       	ldi	r24, 0x01	; 1
    25fc:	8b 83       	std	Y+3, r24	; 0x03

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    25fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2600:	fa 81       	ldd	r31, Y+2	; 0x02
    2602:	80 85       	ldd	r24, Z+8	; 0x08
    2604:	88 23       	and	r24, r24
    2606:	59 f0       	breq	.+22     	; 0x261e <xQueueCRReceive+0x102>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2608:	89 81       	ldd	r24, Y+1	; 0x01
    260a:	9a 81       	ldd	r25, Y+2	; 0x02
    260c:	08 96       	adiw	r24, 0x08	; 8
    260e:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <xCoRoutineRemoveFromEventList>
    2612:	88 23       	and	r24, r24
    2614:	21 f0       	breq	.+8      	; 0x261e <xQueueCRReceive+0x102>
					{
						xReturn = errQUEUE_YIELD;
    2616:	8b ef       	ldi	r24, 0xFB	; 251
    2618:	8b 83       	std	Y+3, r24	; 0x03
    261a:	01 c0       	rjmp	.+2      	; 0x261e <xQueueCRReceive+0x102>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    261c:	1b 82       	std	Y+3, r1	; 0x03
			}
		}
		portENABLE_INTERRUPTS();
    261e:	78 94       	sei

		return xReturn;
    2620:	8b 81       	ldd	r24, Y+3	; 0x03
    2622:	8a 87       	std	Y+10, r24	; 0x0a
    2624:	8a 85       	ldd	r24, Y+10	; 0x0a
	}
    2626:	2a 96       	adiw	r28, 0x0a	; 10
    2628:	0f b6       	in	r0, 0x3f	; 63
    262a:	f8 94       	cli
    262c:	de bf       	out	0x3e, r29	; 62
    262e:	0f be       	out	0x3f, r0	; 63
    2630:	cd bf       	out	0x3d, r28	; 61
    2632:	cf 91       	pop	r28
    2634:	df 91       	pop	r29
    2636:	08 95       	ret

00002638 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    2638:	df 93       	push	r29
    263a:	cf 93       	push	r28
    263c:	cd b7       	in	r28, 0x3d	; 61
    263e:	de b7       	in	r29, 0x3e	; 62
    2640:	28 97       	sbiw	r28, 0x08	; 8
    2642:	0f b6       	in	r0, 0x3f	; 63
    2644:	f8 94       	cli
    2646:	de bf       	out	0x3e, r29	; 62
    2648:	0f be       	out	0x3f, r0	; 63
    264a:	cd bf       	out	0x3d, r28	; 61
    264c:	9c 83       	std	Y+4, r25	; 0x04
    264e:	8b 83       	std	Y+3, r24	; 0x03
    2650:	7e 83       	std	Y+6, r23	; 0x06
    2652:	6d 83       	std	Y+5, r22	; 0x05
    2654:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2656:	8b 81       	ldd	r24, Y+3	; 0x03
    2658:	9c 81       	ldd	r25, Y+4	; 0x04
    265a:	9a 83       	std	Y+2, r25	; 0x02
    265c:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    265e:	e9 81       	ldd	r30, Y+1	; 0x01
    2660:	fa 81       	ldd	r31, Y+2	; 0x02
    2662:	92 8d       	ldd	r25, Z+26	; 0x1a
    2664:	e9 81       	ldd	r30, Y+1	; 0x01
    2666:	fa 81       	ldd	r31, Y+2	; 0x02
    2668:	83 8d       	ldd	r24, Z+27	; 0x1b
    266a:	98 17       	cp	r25, r24
    266c:	d0 f4       	brcc	.+52     	; 0x26a2 <xQueueCRSendFromISR+0x6a>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    266e:	89 81       	ldd	r24, Y+1	; 0x01
    2670:	9a 81       	ldd	r25, Y+2	; 0x02
    2672:	2d 81       	ldd	r18, Y+5	; 0x05
    2674:	3e 81       	ldd	r19, Y+6	; 0x06
    2676:	b9 01       	movw	r22, r18
    2678:	40 e0       	ldi	r20, 0x00	; 0
    267a:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    267e:	8f 81       	ldd	r24, Y+7	; 0x07
    2680:	88 23       	and	r24, r24
    2682:	79 f4       	brne	.+30     	; 0x26a2 <xQueueCRSendFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2684:	e9 81       	ldd	r30, Y+1	; 0x01
    2686:	fa 81       	ldd	r31, Y+2	; 0x02
    2688:	81 89       	ldd	r24, Z+17	; 0x11
    268a:	88 23       	and	r24, r24
    268c:	51 f0       	breq	.+20     	; 0x26a2 <xQueueCRSendFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    268e:	89 81       	ldd	r24, Y+1	; 0x01
    2690:	9a 81       	ldd	r25, Y+2	; 0x02
    2692:	41 96       	adiw	r24, 0x11	; 17
    2694:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <xCoRoutineRemoveFromEventList>
    2698:	88 23       	and	r24, r24
    269a:	19 f0       	breq	.+6      	; 0x26a2 <xQueueCRSendFromISR+0x6a>
					{
						return pdTRUE;
    269c:	81 e0       	ldi	r24, 0x01	; 1
    269e:	88 87       	std	Y+8, r24	; 0x08
    26a0:	02 c0       	rjmp	.+4      	; 0x26a6 <xQueueCRSendFromISR+0x6e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    26a2:	8f 81       	ldd	r24, Y+7	; 0x07
    26a4:	88 87       	std	Y+8, r24	; 0x08
    26a6:	88 85       	ldd	r24, Y+8	; 0x08
	}
    26a8:	28 96       	adiw	r28, 0x08	; 8
    26aa:	0f b6       	in	r0, 0x3f	; 63
    26ac:	f8 94       	cli
    26ae:	de bf       	out	0x3e, r29	; 62
    26b0:	0f be       	out	0x3f, r0	; 63
    26b2:	cd bf       	out	0x3d, r28	; 61
    26b4:	cf 91       	pop	r28
    26b6:	df 91       	pop	r29
    26b8:	08 95       	ret

000026ba <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    26ba:	df 93       	push	r29
    26bc:	cf 93       	push	r28
    26be:	cd b7       	in	r28, 0x3d	; 61
    26c0:	de b7       	in	r29, 0x3e	; 62
    26c2:	29 97       	sbiw	r28, 0x09	; 9
    26c4:	0f b6       	in	r0, 0x3f	; 63
    26c6:	f8 94       	cli
    26c8:	de bf       	out	0x3e, r29	; 62
    26ca:	0f be       	out	0x3f, r0	; 63
    26cc:	cd bf       	out	0x3d, r28	; 61
    26ce:	9d 83       	std	Y+5, r25	; 0x05
    26d0:	8c 83       	std	Y+4, r24	; 0x04
    26d2:	7f 83       	std	Y+7, r23	; 0x07
    26d4:	6e 83       	std	Y+6, r22	; 0x06
    26d6:	59 87       	std	Y+9, r21	; 0x09
    26d8:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    26da:	8c 81       	ldd	r24, Y+4	; 0x04
    26dc:	9d 81       	ldd	r25, Y+5	; 0x05
    26de:	9a 83       	std	Y+2, r25	; 0x02
    26e0:	89 83       	std	Y+1, r24	; 0x01

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    26e2:	e9 81       	ldd	r30, Y+1	; 0x01
    26e4:	fa 81       	ldd	r31, Y+2	; 0x02
    26e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    26e8:	88 23       	and	r24, r24
    26ea:	09 f4       	brne	.+2      	; 0x26ee <xQueueCRReceiveFromISR+0x34>
    26ec:	50 c0       	rjmp	.+160    	; 0x278e <xQueueCRReceiveFromISR+0xd4>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    26ee:	e9 81       	ldd	r30, Y+1	; 0x01
    26f0:	fa 81       	ldd	r31, Y+2	; 0x02
    26f2:	26 81       	ldd	r18, Z+6	; 0x06
    26f4:	37 81       	ldd	r19, Z+7	; 0x07
    26f6:	e9 81       	ldd	r30, Y+1	; 0x01
    26f8:	fa 81       	ldd	r31, Y+2	; 0x02
    26fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    26fc:	88 2f       	mov	r24, r24
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	82 0f       	add	r24, r18
    2702:	93 1f       	adc	r25, r19
    2704:	e9 81       	ldd	r30, Y+1	; 0x01
    2706:	fa 81       	ldd	r31, Y+2	; 0x02
    2708:	97 83       	std	Z+7, r25	; 0x07
    270a:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    270c:	e9 81       	ldd	r30, Y+1	; 0x01
    270e:	fa 81       	ldd	r31, Y+2	; 0x02
    2710:	26 81       	ldd	r18, Z+6	; 0x06
    2712:	37 81       	ldd	r19, Z+7	; 0x07
    2714:	e9 81       	ldd	r30, Y+1	; 0x01
    2716:	fa 81       	ldd	r31, Y+2	; 0x02
    2718:	82 81       	ldd	r24, Z+2	; 0x02
    271a:	93 81       	ldd	r25, Z+3	; 0x03
    271c:	28 17       	cp	r18, r24
    271e:	39 07       	cpc	r19, r25
    2720:	40 f0       	brcs	.+16     	; 0x2732 <xQueueCRReceiveFromISR+0x78>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2722:	e9 81       	ldd	r30, Y+1	; 0x01
    2724:	fa 81       	ldd	r31, Y+2	; 0x02
    2726:	80 81       	ld	r24, Z
    2728:	91 81       	ldd	r25, Z+1	; 0x01
    272a:	e9 81       	ldd	r30, Y+1	; 0x01
    272c:	fa 81       	ldd	r31, Y+2	; 0x02
    272e:	97 83       	std	Z+7, r25	; 0x07
    2730:	86 83       	std	Z+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    2732:	e9 81       	ldd	r30, Y+1	; 0x01
    2734:	fa 81       	ldd	r31, Y+2	; 0x02
    2736:	82 8d       	ldd	r24, Z+26	; 0x1a
    2738:	81 50       	subi	r24, 0x01	; 1
    273a:	e9 81       	ldd	r30, Y+1	; 0x01
    273c:	fa 81       	ldd	r31, Y+2	; 0x02
    273e:	82 8f       	std	Z+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2740:	e9 81       	ldd	r30, Y+1	; 0x01
    2742:	fa 81       	ldd	r31, Y+2	; 0x02
    2744:	46 81       	ldd	r20, Z+6	; 0x06
    2746:	57 81       	ldd	r21, Z+7	; 0x07
    2748:	e9 81       	ldd	r30, Y+1	; 0x01
    274a:	fa 81       	ldd	r31, Y+2	; 0x02
    274c:	84 8d       	ldd	r24, Z+28	; 0x1c
    274e:	28 2f       	mov	r18, r24
    2750:	30 e0       	ldi	r19, 0x00	; 0
    2752:	8e 81       	ldd	r24, Y+6	; 0x06
    2754:	9f 81       	ldd	r25, Y+7	; 0x07
    2756:	ba 01       	movw	r22, r20
    2758:	a9 01       	movw	r20, r18
    275a:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    275e:	e8 85       	ldd	r30, Y+8	; 0x08
    2760:	f9 85       	ldd	r31, Y+9	; 0x09
    2762:	80 81       	ld	r24, Z
    2764:	88 23       	and	r24, r24
    2766:	81 f4       	brne	.+32     	; 0x2788 <xQueueCRReceiveFromISR+0xce>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2768:	e9 81       	ldd	r30, Y+1	; 0x01
    276a:	fa 81       	ldd	r31, Y+2	; 0x02
    276c:	80 85       	ldd	r24, Z+8	; 0x08
    276e:	88 23       	and	r24, r24
    2770:	59 f0       	breq	.+22     	; 0x2788 <xQueueCRReceiveFromISR+0xce>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2772:	89 81       	ldd	r24, Y+1	; 0x01
    2774:	9a 81       	ldd	r25, Y+2	; 0x02
    2776:	08 96       	adiw	r24, 0x08	; 8
    2778:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <xCoRoutineRemoveFromEventList>
    277c:	88 23       	and	r24, r24
    277e:	21 f0       	breq	.+8      	; 0x2788 <xQueueCRReceiveFromISR+0xce>
					{
						*pxCoRoutineWoken = pdTRUE;
    2780:	e8 85       	ldd	r30, Y+8	; 0x08
    2782:	f9 85       	ldd	r31, Y+9	; 0x09
    2784:	81 e0       	ldi	r24, 0x01	; 1
    2786:	80 83       	st	Z, r24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    2788:	81 e0       	ldi	r24, 0x01	; 1
    278a:	8b 83       	std	Y+3, r24	; 0x03
    278c:	01 c0       	rjmp	.+2      	; 0x2790 <xQueueCRReceiveFromISR+0xd6>
		}
		else
		{
			xReturn = pdFAIL;
    278e:	1b 82       	std	Y+3, r1	; 0x03
		}

		return xReturn;
    2790:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2792:	29 96       	adiw	r28, 0x09	; 9
    2794:	0f b6       	in	r0, 0x3f	; 63
    2796:	f8 94       	cli
    2798:	de bf       	out	0x3e, r29	; 62
    279a:	0f be       	out	0x3f, r0	; 63
    279c:	cd bf       	out	0x3d, r28	; 61
    279e:	cf 91       	pop	r28
    27a0:	df 91       	pop	r29
    27a2:	08 95       	ret

000027a4 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    27a4:	af 92       	push	r10
    27a6:	bf 92       	push	r11
    27a8:	cf 92       	push	r12
    27aa:	df 92       	push	r13
    27ac:	ef 92       	push	r14
    27ae:	ff 92       	push	r15
    27b0:	0f 93       	push	r16
    27b2:	1f 93       	push	r17
    27b4:	df 93       	push	r29
    27b6:	cf 93       	push	r28
    27b8:	cd b7       	in	r28, 0x3d	; 61
    27ba:	de b7       	in	r29, 0x3e	; 62
    27bc:	64 97       	sbiw	r28, 0x14	; 20
    27be:	0f b6       	in	r0, 0x3f	; 63
    27c0:	f8 94       	cli
    27c2:	de bf       	out	0x3e, r29	; 62
    27c4:	0f be       	out	0x3f, r0	; 63
    27c6:	cd bf       	out	0x3d, r28	; 61
    27c8:	9f 83       	std	Y+7, r25	; 0x07
    27ca:	8e 83       	std	Y+6, r24	; 0x06
    27cc:	79 87       	std	Y+9, r23	; 0x09
    27ce:	68 87       	std	Y+8, r22	; 0x08
    27d0:	5b 87       	std	Y+11, r21	; 0x0b
    27d2:	4a 87       	std	Y+10, r20	; 0x0a
    27d4:	3d 87       	std	Y+13, r19	; 0x0d
    27d6:	2c 87       	std	Y+12, r18	; 0x0c
    27d8:	0e 87       	std	Y+14, r16	; 0x0e
    27da:	f8 8a       	std	Y+16, r15	; 0x10
    27dc:	ef 86       	std	Y+15, r14	; 0x0f
    27de:	da 8a       	std	Y+18, r13	; 0x12
    27e0:	c9 8a       	std	Y+17, r12	; 0x11
    27e2:	bc 8a       	std	Y+20, r11	; 0x14
    27e4:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    27e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    27e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    27ea:	29 89       	ldd	r18, Y+17	; 0x11
    27ec:	3a 89       	ldd	r19, Y+18	; 0x12
    27ee:	b9 01       	movw	r22, r18
    27f0:	0e 94 35 1b 	call	0x366a	; 0x366a <prvAllocateTCBAndStack>
    27f4:	9c 83       	std	Y+4, r25	; 0x04
    27f6:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    27f8:	8b 81       	ldd	r24, Y+3	; 0x03
    27fa:	9c 81       	ldd	r25, Y+4	; 0x04
    27fc:	00 97       	sbiw	r24, 0x00	; 0
    27fe:	09 f4       	brne	.+2      	; 0x2802 <xTaskGenericCreate+0x5e>
    2800:	8d c0       	rjmp	.+282    	; 0x291c <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    2802:	eb 81       	ldd	r30, Y+3	; 0x03
    2804:	fc 81       	ldd	r31, Y+4	; 0x04
    2806:	27 89       	ldd	r18, Z+23	; 0x17
    2808:	30 8d       	ldd	r19, Z+24	; 0x18
    280a:	8a 85       	ldd	r24, Y+10	; 0x0a
    280c:	9b 85       	ldd	r25, Y+11	; 0x0b
    280e:	01 97       	sbiw	r24, 0x01	; 1
    2810:	82 0f       	add	r24, r18
    2812:	93 1f       	adc	r25, r19
    2814:	9a 83       	std	Y+2, r25	; 0x02
    2816:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    2818:	8b 81       	ldd	r24, Y+3	; 0x03
    281a:	9c 81       	ldd	r25, Y+4	; 0x04
    281c:	28 85       	ldd	r18, Y+8	; 0x08
    281e:	39 85       	ldd	r19, Y+9	; 0x09
    2820:	eb 89       	ldd	r30, Y+19	; 0x13
    2822:	fc 89       	ldd	r31, Y+20	; 0x14
    2824:	aa 85       	ldd	r26, Y+10	; 0x0a
    2826:	bb 85       	ldd	r27, Y+11	; 0x0b
    2828:	b9 01       	movw	r22, r18
    282a:	4e 85       	ldd	r20, Y+14	; 0x0e
    282c:	9f 01       	movw	r18, r30
    282e:	8d 01       	movw	r16, r26
    2830:	0e 94 fd 19 	call	0x33fa	; 0x33fa <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2834:	89 81       	ldd	r24, Y+1	; 0x01
    2836:	9a 81       	ldd	r25, Y+2	; 0x02
    2838:	2e 81       	ldd	r18, Y+6	; 0x06
    283a:	3f 81       	ldd	r19, Y+7	; 0x07
    283c:	4c 85       	ldd	r20, Y+12	; 0x0c
    283e:	5d 85       	ldd	r21, Y+13	; 0x0d
    2840:	b9 01       	movw	r22, r18
    2842:	0e 94 cf 09 	call	0x139e	; 0x139e <pxPortInitialiseStack>
    2846:	eb 81       	ldd	r30, Y+3	; 0x03
    2848:	fc 81       	ldd	r31, Y+4	; 0x04
    284a:	91 83       	std	Z+1, r25	; 0x01
    284c:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    284e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2850:	98 89       	ldd	r25, Y+16	; 0x10
    2852:	00 97       	sbiw	r24, 0x00	; 0
    2854:	31 f0       	breq	.+12     	; 0x2862 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2856:	ef 85       	ldd	r30, Y+15	; 0x0f
    2858:	f8 89       	ldd	r31, Y+16	; 0x10
    285a:	8b 81       	ldd	r24, Y+3	; 0x03
    285c:	9c 81       	ldd	r25, Y+4	; 0x04
    285e:	91 83       	std	Z+1, r25	; 0x01
    2860:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    2862:	0f b6       	in	r0, 0x3f	; 63
    2864:	f8 94       	cli
    2866:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2868:	80 91 b0 06 	lds	r24, 0x06B0
    286c:	8f 5f       	subi	r24, 0xFF	; 255
    286e:	80 93 b0 06 	sts	0x06B0, r24
			if( pxCurrentTCB == NULL )
    2872:	80 91 ad 06 	lds	r24, 0x06AD
    2876:	90 91 ae 06 	lds	r25, 0x06AE
    287a:	00 97       	sbiw	r24, 0x00	; 0
    287c:	69 f4       	brne	.+26     	; 0x2898 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    287e:	8b 81       	ldd	r24, Y+3	; 0x03
    2880:	9c 81       	ldd	r25, Y+4	; 0x04
    2882:	90 93 ae 06 	sts	0x06AE, r25
    2886:	80 93 ad 06 	sts	0x06AD, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    288a:	80 91 b0 06 	lds	r24, 0x06B0
    288e:	81 30       	cpi	r24, 0x01	; 1
    2890:	a9 f4       	brne	.+42     	; 0x28bc <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2892:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvInitialiseTaskLists>
    2896:	12 c0       	rjmp	.+36     	; 0x28bc <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2898:	80 91 b4 06 	lds	r24, 0x06B4
    289c:	88 23       	and	r24, r24
    289e:	71 f4       	brne	.+28     	; 0x28bc <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    28a0:	e0 91 ad 06 	lds	r30, 0x06AD
    28a4:	f0 91 ae 06 	lds	r31, 0x06AE
    28a8:	96 89       	ldd	r25, Z+22	; 0x16
    28aa:	8e 85       	ldd	r24, Y+14	; 0x0e
    28ac:	89 17       	cp	r24, r25
    28ae:	30 f0       	brcs	.+12     	; 0x28bc <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    28b0:	8b 81       	ldd	r24, Y+3	; 0x03
    28b2:	9c 81       	ldd	r25, Y+4	; 0x04
    28b4:	90 93 ae 06 	sts	0x06AE, r25
    28b8:	80 93 ad 06 	sts	0x06AD, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    28bc:	80 91 b8 06 	lds	r24, 0x06B8
    28c0:	8f 5f       	subi	r24, 0xFF	; 255
    28c2:	80 93 b8 06 	sts	0x06B8, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    28c6:	eb 81       	ldd	r30, Y+3	; 0x03
    28c8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ca:	96 89       	ldd	r25, Z+22	; 0x16
    28cc:	80 91 b3 06 	lds	r24, 0x06B3
    28d0:	89 17       	cp	r24, r25
    28d2:	28 f4       	brcc	.+10     	; 0x28de <xTaskGenericCreate+0x13a>
    28d4:	eb 81       	ldd	r30, Y+3	; 0x03
    28d6:	fc 81       	ldd	r31, Y+4	; 0x04
    28d8:	86 89       	ldd	r24, Z+22	; 0x16
    28da:	80 93 b3 06 	sts	0x06B3, r24
    28de:	eb 81       	ldd	r30, Y+3	; 0x03
    28e0:	fc 81       	ldd	r31, Y+4	; 0x04
    28e2:	86 89       	ldd	r24, Z+22	; 0x16
    28e4:	28 2f       	mov	r18, r24
    28e6:	30 e0       	ldi	r19, 0x00	; 0
    28e8:	c9 01       	movw	r24, r18
    28ea:	88 0f       	add	r24, r24
    28ec:	99 1f       	adc	r25, r25
    28ee:	88 0f       	add	r24, r24
    28f0:	99 1f       	adc	r25, r25
    28f2:	88 0f       	add	r24, r24
    28f4:	99 1f       	adc	r25, r25
    28f6:	82 0f       	add	r24, r18
    28f8:	93 1f       	adc	r25, r19
    28fa:	ac 01       	movw	r20, r24
    28fc:	46 54       	subi	r20, 0x46	; 70
    28fe:	59 4f       	sbci	r21, 0xF9	; 249
    2900:	8b 81       	ldd	r24, Y+3	; 0x03
    2902:	9c 81       	ldd	r25, Y+4	; 0x04
    2904:	9c 01       	movw	r18, r24
    2906:	2e 5f       	subi	r18, 0xFE	; 254
    2908:	3f 4f       	sbci	r19, 0xFF	; 255
    290a:	ca 01       	movw	r24, r20
    290c:	b9 01       	movw	r22, r18
    290e:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

			xReturn = pdPASS;
    2912:	81 e0       	ldi	r24, 0x01	; 1
    2914:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2916:	0f 90       	pop	r0
    2918:	0f be       	out	0x3f, r0	; 63
    291a:	02 c0       	rjmp	.+4      	; 0x2920 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    291c:	8f ef       	ldi	r24, 0xFF	; 255
    291e:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2920:	8d 81       	ldd	r24, Y+5	; 0x05
    2922:	81 30       	cpi	r24, 0x01	; 1
    2924:	71 f4       	brne	.+28     	; 0x2942 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    2926:	80 91 b4 06 	lds	r24, 0x06B4
    292a:	88 23       	and	r24, r24
    292c:	51 f0       	breq	.+20     	; 0x2942 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    292e:	e0 91 ad 06 	lds	r30, 0x06AD
    2932:	f0 91 ae 06 	lds	r31, 0x06AE
    2936:	96 89       	ldd	r25, Z+22	; 0x16
    2938:	8e 85       	ldd	r24, Y+14	; 0x0e
    293a:	98 17       	cp	r25, r24
    293c:	10 f4       	brcc	.+4      	; 0x2942 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    293e:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    2942:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2944:	64 96       	adiw	r28, 0x14	; 20
    2946:	0f b6       	in	r0, 0x3f	; 63
    2948:	f8 94       	cli
    294a:	de bf       	out	0x3e, r29	; 62
    294c:	0f be       	out	0x3f, r0	; 63
    294e:	cd bf       	out	0x3d, r28	; 61
    2950:	cf 91       	pop	r28
    2952:	df 91       	pop	r29
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	ff 90       	pop	r15
    295a:	ef 90       	pop	r14
    295c:	df 90       	pop	r13
    295e:	cf 90       	pop	r12
    2960:	bf 90       	pop	r11
    2962:	af 90       	pop	r10
    2964:	08 95       	ret

00002966 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    2966:	df 93       	push	r29
    2968:	cf 93       	push	r28
    296a:	00 d0       	rcall	.+0      	; 0x296c <vTaskDelete+0x6>
    296c:	00 d0       	rcall	.+0      	; 0x296e <vTaskDelete+0x8>
    296e:	00 d0       	rcall	.+0      	; 0x2970 <vTaskDelete+0xa>
    2970:	cd b7       	in	r28, 0x3d	; 61
    2972:	de b7       	in	r29, 0x3e	; 62
    2974:	9c 83       	std	Y+4, r25	; 0x04
    2976:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2978:	0f b6       	in	r0, 0x3f	; 63
    297a:	f8 94       	cli
    297c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    297e:	8b 81       	ldd	r24, Y+3	; 0x03
    2980:	9c 81       	ldd	r25, Y+4	; 0x04
    2982:	00 97       	sbiw	r24, 0x00	; 0
    2984:	39 f4       	brne	.+14     	; 0x2994 <vTaskDelete+0x2e>
    2986:	80 91 ad 06 	lds	r24, 0x06AD
    298a:	90 91 ae 06 	lds	r25, 0x06AE
    298e:	9e 83       	std	Y+6, r25	; 0x06
    2990:	8d 83       	std	Y+5, r24	; 0x05
    2992:	04 c0       	rjmp	.+8      	; 0x299c <vTaskDelete+0x36>
    2994:	8b 81       	ldd	r24, Y+3	; 0x03
    2996:	9c 81       	ldd	r25, Y+4	; 0x04
    2998:	9e 83       	std	Y+6, r25	; 0x06
    299a:	8d 83       	std	Y+5, r24	; 0x05
    299c:	8d 81       	ldd	r24, Y+5	; 0x05
    299e:	9e 81       	ldd	r25, Y+6	; 0x06
    29a0:	9a 83       	std	Y+2, r25	; 0x02
    29a2:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    29a4:	89 81       	ldd	r24, Y+1	; 0x01
    29a6:	9a 81       	ldd	r25, Y+2	; 0x02
    29a8:	02 96       	adiw	r24, 0x02	; 2
    29aa:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    29ae:	e9 81       	ldd	r30, Y+1	; 0x01
    29b0:	fa 81       	ldd	r31, Y+2	; 0x02
    29b2:	84 89       	ldd	r24, Z+20	; 0x14
    29b4:	95 89       	ldd	r25, Z+21	; 0x15
    29b6:	00 97       	sbiw	r24, 0x00	; 0
    29b8:	29 f0       	breq	.+10     	; 0x29c4 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    29ba:	89 81       	ldd	r24, Y+1	; 0x01
    29bc:	9a 81       	ldd	r25, Y+2	; 0x02
    29be:	0c 96       	adiw	r24, 0x0c	; 12
    29c0:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    29c4:	89 81       	ldd	r24, Y+1	; 0x01
    29c6:	9a 81       	ldd	r25, Y+2	; 0x02
    29c8:	9c 01       	movw	r18, r24
    29ca:	2e 5f       	subi	r18, 0xFE	; 254
    29cc:	3f 4f       	sbci	r19, 0xFF	; 255
    29ce:	8d ef       	ldi	r24, 0xFD	; 253
    29d0:	96 e0       	ldi	r25, 0x06	; 6
    29d2:	b9 01       	movw	r22, r18
    29d4:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    29d8:	80 91 af 06 	lds	r24, 0x06AF
    29dc:	8f 5f       	subi	r24, 0xFF	; 255
    29de:	80 93 af 06 	sts	0x06AF, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    29e2:	80 91 b8 06 	lds	r24, 0x06B8
    29e6:	8f 5f       	subi	r24, 0xFF	; 255
    29e8:	80 93 b8 06 	sts	0x06B8, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    29ec:	0f 90       	pop	r0
    29ee:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    29f0:	80 91 b4 06 	lds	r24, 0x06B4
    29f4:	88 23       	and	r24, r24
    29f6:	99 f0       	breq	.+38     	; 0x2a1e <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    29f8:	20 91 ad 06 	lds	r18, 0x06AD
    29fc:	30 91 ae 06 	lds	r19, 0x06AE
    2a00:	89 81       	ldd	r24, Y+1	; 0x01
    2a02:	9a 81       	ldd	r25, Y+2	; 0x02
    2a04:	82 17       	cp	r24, r18
    2a06:	93 07       	cpc	r25, r19
    2a08:	19 f4       	brne	.+6      	; 0x2a10 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    2a0a:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    2a0e:	07 c0       	rjmp	.+14     	; 0x2a1e <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    2a10:	0f b6       	in	r0, 0x3f	; 63
    2a12:	f8 94       	cli
    2a14:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    2a16:	0e 94 8f 1b 	call	0x371e	; 0x371e <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    2a1a:	0f 90       	pop	r0
    2a1c:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    2a1e:	26 96       	adiw	r28, 0x06	; 6
    2a20:	0f b6       	in	r0, 0x3f	; 63
    2a22:	f8 94       	cli
    2a24:	de bf       	out	0x3e, r29	; 62
    2a26:	0f be       	out	0x3f, r0	; 63
    2a28:	cd bf       	out	0x3d, r28	; 61
    2a2a:	cf 91       	pop	r28
    2a2c:	df 91       	pop	r29
    2a2e:	08 95       	ret

00002a30 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2a30:	df 93       	push	r29
    2a32:	cf 93       	push	r28
    2a34:	cd b7       	in	r28, 0x3d	; 61
    2a36:	de b7       	in	r29, 0x3e	; 62
    2a38:	2a 97       	sbiw	r28, 0x0a	; 10
    2a3a:	0f b6       	in	r0, 0x3f	; 63
    2a3c:	f8 94       	cli
    2a3e:	de bf       	out	0x3e, r29	; 62
    2a40:	0f be       	out	0x3f, r0	; 63
    2a42:	cd bf       	out	0x3d, r28	; 61
    2a44:	98 87       	std	Y+8, r25	; 0x08
    2a46:	8f 83       	std	Y+7, r24	; 0x07
    2a48:	7a 87       	std	Y+10, r23	; 0x0a
    2a4a:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2a4c:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2a4e:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2a52:	80 91 b1 06 	lds	r24, 0x06B1
    2a56:	90 91 b2 06 	lds	r25, 0x06B2
    2a5a:	9a 83       	std	Y+2, r25	; 0x02
    2a5c:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a5e:	ef 81       	ldd	r30, Y+7	; 0x07
    2a60:	f8 85       	ldd	r31, Y+8	; 0x08
    2a62:	20 81       	ld	r18, Z
    2a64:	31 81       	ldd	r19, Z+1	; 0x01
    2a66:	89 85       	ldd	r24, Y+9	; 0x09
    2a68:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a6a:	82 0f       	add	r24, r18
    2a6c:	93 1f       	adc	r25, r19
    2a6e:	9e 83       	std	Y+6, r25	; 0x06
    2a70:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2a72:	ef 81       	ldd	r30, Y+7	; 0x07
    2a74:	f8 85       	ldd	r31, Y+8	; 0x08
    2a76:	20 81       	ld	r18, Z
    2a78:	31 81       	ldd	r19, Z+1	; 0x01
    2a7a:	89 81       	ldd	r24, Y+1	; 0x01
    2a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7e:	82 17       	cp	r24, r18
    2a80:	93 07       	cpc	r25, r19
    2a82:	98 f4       	brcc	.+38     	; 0x2aaa <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2a84:	ef 81       	ldd	r30, Y+7	; 0x07
    2a86:	f8 85       	ldd	r31, Y+8	; 0x08
    2a88:	20 81       	ld	r18, Z
    2a8a:	31 81       	ldd	r19, Z+1	; 0x01
    2a8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a90:	82 17       	cp	r24, r18
    2a92:	93 07       	cpc	r25, r19
    2a94:	e0 f4       	brcc	.+56     	; 0x2ace <vTaskDelayUntil+0x9e>
    2a96:	2d 81       	ldd	r18, Y+5	; 0x05
    2a98:	3e 81       	ldd	r19, Y+6	; 0x06
    2a9a:	89 81       	ldd	r24, Y+1	; 0x01
    2a9c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a9e:	82 17       	cp	r24, r18
    2aa0:	93 07       	cpc	r25, r19
    2aa2:	a8 f4       	brcc	.+42     	; 0x2ace <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2aa4:	81 e0       	ldi	r24, 0x01	; 1
    2aa6:	8b 83       	std	Y+3, r24	; 0x03
    2aa8:	12 c0       	rjmp	.+36     	; 0x2ace <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2aaa:	ef 81       	ldd	r30, Y+7	; 0x07
    2aac:	f8 85       	ldd	r31, Y+8	; 0x08
    2aae:	20 81       	ld	r18, Z
    2ab0:	31 81       	ldd	r19, Z+1	; 0x01
    2ab2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ab4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ab6:	82 17       	cp	r24, r18
    2ab8:	93 07       	cpc	r25, r19
    2aba:	38 f0       	brcs	.+14     	; 0x2aca <vTaskDelayUntil+0x9a>
    2abc:	2d 81       	ldd	r18, Y+5	; 0x05
    2abe:	3e 81       	ldd	r19, Y+6	; 0x06
    2ac0:	89 81       	ldd	r24, Y+1	; 0x01
    2ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac4:	82 17       	cp	r24, r18
    2ac6:	93 07       	cpc	r25, r19
    2ac8:	10 f4       	brcc	.+4      	; 0x2ace <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2aca:	81 e0       	ldi	r24, 0x01	; 1
    2acc:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2ace:	ef 81       	ldd	r30, Y+7	; 0x07
    2ad0:	f8 85       	ldd	r31, Y+8	; 0x08
    2ad2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ad4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ad6:	91 83       	std	Z+1, r25	; 0x01
    2ad8:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2ada:	8b 81       	ldd	r24, Y+3	; 0x03
    2adc:	88 23       	and	r24, r24
    2ade:	59 f0       	breq	.+22     	; 0x2af6 <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2ae0:	80 91 ad 06 	lds	r24, 0x06AD
    2ae4:	90 91 ae 06 	lds	r25, 0x06AE
    2ae8:	02 96       	adiw	r24, 0x02	; 2
    2aea:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2aee:	8d 81       	ldd	r24, Y+5	; 0x05
    2af0:	9e 81       	ldd	r25, Y+6	; 0x06
    2af2:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2af6:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
    2afa:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2afc:	8c 81       	ldd	r24, Y+4	; 0x04
    2afe:	88 23       	and	r24, r24
    2b00:	11 f4       	brne	.+4      	; 0x2b06 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2b02:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2b06:	2a 96       	adiw	r28, 0x0a	; 10
    2b08:	0f b6       	in	r0, 0x3f	; 63
    2b0a:	f8 94       	cli
    2b0c:	de bf       	out	0x3e, r29	; 62
    2b0e:	0f be       	out	0x3f, r0	; 63
    2b10:	cd bf       	out	0x3d, r28	; 61
    2b12:	cf 91       	pop	r28
    2b14:	df 91       	pop	r29
    2b16:	08 95       	ret

00002b18 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2b18:	df 93       	push	r29
    2b1a:	cf 93       	push	r28
    2b1c:	00 d0       	rcall	.+0      	; 0x2b1e <vTaskDelay+0x6>
    2b1e:	00 d0       	rcall	.+0      	; 0x2b20 <vTaskDelay+0x8>
    2b20:	0f 92       	push	r0
    2b22:	cd b7       	in	r28, 0x3d	; 61
    2b24:	de b7       	in	r29, 0x3e	; 62
    2b26:	9d 83       	std	Y+5, r25	; 0x05
    2b28:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    2b2a:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2b2c:	8c 81       	ldd	r24, Y+4	; 0x04
    2b2e:	9d 81       	ldd	r25, Y+5	; 0x05
    2b30:	00 97       	sbiw	r24, 0x00	; 0
    2b32:	d1 f0       	breq	.+52     	; 0x2b68 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2b34:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2b38:	20 91 b1 06 	lds	r18, 0x06B1
    2b3c:	30 91 b2 06 	lds	r19, 0x06B2
    2b40:	8c 81       	ldd	r24, Y+4	; 0x04
    2b42:	9d 81       	ldd	r25, Y+5	; 0x05
    2b44:	82 0f       	add	r24, r18
    2b46:	93 1f       	adc	r25, r19
    2b48:	9b 83       	std	Y+3, r25	; 0x03
    2b4a:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2b4c:	80 91 ad 06 	lds	r24, 0x06AD
    2b50:	90 91 ae 06 	lds	r25, 0x06AE
    2b54:	02 96       	adiw	r24, 0x02	; 2
    2b56:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2b5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b5e:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b62:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>
    2b66:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b68:	89 81       	ldd	r24, Y+1	; 0x01
    2b6a:	88 23       	and	r24, r24
    2b6c:	11 f4       	brne	.+4      	; 0x2b72 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2b6e:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2b72:	0f 90       	pop	r0
    2b74:	0f 90       	pop	r0
    2b76:	0f 90       	pop	r0
    2b78:	0f 90       	pop	r0
    2b7a:	0f 90       	pop	r0
    2b7c:	cf 91       	pop	r28
    2b7e:	df 91       	pop	r29
    2b80:	08 95       	ret

00002b82 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2b82:	af 92       	push	r10
    2b84:	bf 92       	push	r11
    2b86:	cf 92       	push	r12
    2b88:	df 92       	push	r13
    2b8a:	ef 92       	push	r14
    2b8c:	ff 92       	push	r15
    2b8e:	0f 93       	push	r16
    2b90:	df 93       	push	r29
    2b92:	cf 93       	push	r28
    2b94:	0f 92       	push	r0
    2b96:	cd b7       	in	r28, 0x3d	; 61
    2b98:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    2b9a:	8d ee       	ldi	r24, 0xED	; 237
    2b9c:	99 e1       	ldi	r25, 0x19	; 25
    2b9e:	28 e7       	ldi	r18, 0x78	; 120
    2ba0:	30 e0       	ldi	r19, 0x00	; 0
    2ba2:	b9 01       	movw	r22, r18
    2ba4:	45 e5       	ldi	r20, 0x55	; 85
    2ba6:	50 e0       	ldi	r21, 0x00	; 0
    2ba8:	20 e0       	ldi	r18, 0x00	; 0
    2baa:	30 e0       	ldi	r19, 0x00	; 0
    2bac:	00 e0       	ldi	r16, 0x00	; 0
    2bae:	ee 24       	eor	r14, r14
    2bb0:	ff 24       	eor	r15, r15
    2bb2:	cc 24       	eor	r12, r12
    2bb4:	dd 24       	eor	r13, r13
    2bb6:	aa 24       	eor	r10, r10
    2bb8:	bb 24       	eor	r11, r11
    2bba:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <xTaskGenericCreate>
    2bbe:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2bc0:	89 81       	ldd	r24, Y+1	; 0x01
    2bc2:	81 30       	cpi	r24, 0x01	; 1
    2bc4:	51 f4       	brne	.+20     	; 0x2bda <vTaskStartScheduler+0x58>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2bc6:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    2bc8:	81 e0       	ldi	r24, 0x01	; 1
    2bca:	80 93 b4 06 	sts	0x06B4, r24
		xTickCount = ( TickType_t ) 0U;
    2bce:	10 92 b2 06 	sts	0x06B2, r1
    2bd2:	10 92 b1 06 	sts	0x06B1, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2bd6:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    2bda:	0f 90       	pop	r0
    2bdc:	cf 91       	pop	r28
    2bde:	df 91       	pop	r29
    2be0:	0f 91       	pop	r16
    2be2:	ff 90       	pop	r15
    2be4:	ef 90       	pop	r14
    2be6:	df 90       	pop	r13
    2be8:	cf 90       	pop	r12
    2bea:	bf 90       	pop	r11
    2bec:	af 90       	pop	r10
    2bee:	08 95       	ret

00002bf0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2bf0:	df 93       	push	r29
    2bf2:	cf 93       	push	r28
    2bf4:	cd b7       	in	r28, 0x3d	; 61
    2bf6:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2bf8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2bfa:	10 92 b4 06 	sts	0x06B4, r1
	vPortEndScheduler();
    2bfe:	0e 94 87 0b 	call	0x170e	; 0x170e <vPortEndScheduler>
}
    2c02:	cf 91       	pop	r28
    2c04:	df 91       	pop	r29
    2c06:	08 95       	ret

00002c08 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2c08:	df 93       	push	r29
    2c0a:	cf 93       	push	r28
    2c0c:	cd b7       	in	r28, 0x3d	; 61
    2c0e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2c10:	80 91 b9 06 	lds	r24, 0x06B9
    2c14:	8f 5f       	subi	r24, 0xFF	; 255
    2c16:	80 93 b9 06 	sts	0x06B9, r24
}
    2c1a:	cf 91       	pop	r28
    2c1c:	df 91       	pop	r29
    2c1e:	08 95       	ret

00002c20 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2c20:	df 93       	push	r29
    2c22:	cf 93       	push	r28
    2c24:	00 d0       	rcall	.+0      	; 0x2c26 <xTaskResumeAll+0x6>
    2c26:	0f 92       	push	r0
    2c28:	cd b7       	in	r28, 0x3d	; 61
    2c2a:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    2c2c:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2c2e:	0f b6       	in	r0, 0x3f	; 63
    2c30:	f8 94       	cli
    2c32:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2c34:	80 91 b9 06 	lds	r24, 0x06B9
    2c38:	81 50       	subi	r24, 0x01	; 1
    2c3a:	80 93 b9 06 	sts	0x06B9, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2c3e:	80 91 b9 06 	lds	r24, 0x06B9
    2c42:	88 23       	and	r24, r24
    2c44:	09 f0       	breq	.+2      	; 0x2c48 <xTaskResumeAll+0x28>
    2c46:	6d c0       	rjmp	.+218    	; 0x2d22 <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2c48:	80 91 b0 06 	lds	r24, 0x06B0
    2c4c:	88 23       	and	r24, r24
    2c4e:	09 f4       	brne	.+2      	; 0x2c52 <xTaskResumeAll+0x32>
    2c50:	68 c0       	rjmp	.+208    	; 0x2d22 <xTaskResumeAll+0x102>
    2c52:	45 c0       	rjmp	.+138    	; 0x2cde <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    2c54:	e0 91 f9 06 	lds	r30, 0x06F9
    2c58:	f0 91 fa 06 	lds	r31, 0x06FA
    2c5c:	86 81       	ldd	r24, Z+6	; 0x06
    2c5e:	97 81       	ldd	r25, Z+7	; 0x07
    2c60:	9b 83       	std	Y+3, r25	; 0x03
    2c62:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2c64:	8a 81       	ldd	r24, Y+2	; 0x02
    2c66:	9b 81       	ldd	r25, Y+3	; 0x03
    2c68:	0c 96       	adiw	r24, 0x0c	; 12
    2c6a:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2c6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c70:	9b 81       	ldd	r25, Y+3	; 0x03
    2c72:	02 96       	adiw	r24, 0x02	; 2
    2c74:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2c78:	ea 81       	ldd	r30, Y+2	; 0x02
    2c7a:	fb 81       	ldd	r31, Y+3	; 0x03
    2c7c:	96 89       	ldd	r25, Z+22	; 0x16
    2c7e:	80 91 b3 06 	lds	r24, 0x06B3
    2c82:	89 17       	cp	r24, r25
    2c84:	28 f4       	brcc	.+10     	; 0x2c90 <xTaskResumeAll+0x70>
    2c86:	ea 81       	ldd	r30, Y+2	; 0x02
    2c88:	fb 81       	ldd	r31, Y+3	; 0x03
    2c8a:	86 89       	ldd	r24, Z+22	; 0x16
    2c8c:	80 93 b3 06 	sts	0x06B3, r24
    2c90:	ea 81       	ldd	r30, Y+2	; 0x02
    2c92:	fb 81       	ldd	r31, Y+3	; 0x03
    2c94:	86 89       	ldd	r24, Z+22	; 0x16
    2c96:	28 2f       	mov	r18, r24
    2c98:	30 e0       	ldi	r19, 0x00	; 0
    2c9a:	c9 01       	movw	r24, r18
    2c9c:	88 0f       	add	r24, r24
    2c9e:	99 1f       	adc	r25, r25
    2ca0:	88 0f       	add	r24, r24
    2ca2:	99 1f       	adc	r25, r25
    2ca4:	88 0f       	add	r24, r24
    2ca6:	99 1f       	adc	r25, r25
    2ca8:	82 0f       	add	r24, r18
    2caa:	93 1f       	adc	r25, r19
    2cac:	ac 01       	movw	r20, r24
    2cae:	46 54       	subi	r20, 0x46	; 70
    2cb0:	59 4f       	sbci	r21, 0xF9	; 249
    2cb2:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb4:	9b 81       	ldd	r25, Y+3	; 0x03
    2cb6:	9c 01       	movw	r18, r24
    2cb8:	2e 5f       	subi	r18, 0xFE	; 254
    2cba:	3f 4f       	sbci	r19, 0xFF	; 255
    2cbc:	ca 01       	movw	r24, r20
    2cbe:	b9 01       	movw	r22, r18
    2cc0:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2cc4:	ea 81       	ldd	r30, Y+2	; 0x02
    2cc6:	fb 81       	ldd	r31, Y+3	; 0x03
    2cc8:	96 89       	ldd	r25, Z+22	; 0x16
    2cca:	e0 91 ad 06 	lds	r30, 0x06AD
    2cce:	f0 91 ae 06 	lds	r31, 0x06AE
    2cd2:	86 89       	ldd	r24, Z+22	; 0x16
    2cd4:	98 17       	cp	r25, r24
    2cd6:	18 f0       	brcs	.+6      	; 0x2cde <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    2cd8:	81 e0       	ldi	r24, 0x01	; 1
    2cda:	80 93 b6 06 	sts	0x06B6, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2cde:	80 91 f4 06 	lds	r24, 0x06F4
    2ce2:	88 23       	and	r24, r24
    2ce4:	09 f0       	breq	.+2      	; 0x2ce8 <xTaskResumeAll+0xc8>
    2ce6:	b6 cf       	rjmp	.-148    	; 0x2c54 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    2ce8:	80 91 b5 06 	lds	r24, 0x06B5
    2cec:	88 23       	and	r24, r24
    2cee:	89 f0       	breq	.+34     	; 0x2d12 <xTaskResumeAll+0xf2>
    2cf0:	0c c0       	rjmp	.+24     	; 0x2d0a <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    2cf2:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <xTaskIncrementTick>
    2cf6:	88 23       	and	r24, r24
    2cf8:	19 f0       	breq	.+6      	; 0x2d00 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    2cfa:	81 e0       	ldi	r24, 0x01	; 1
    2cfc:	80 93 b6 06 	sts	0x06B6, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2d00:	80 91 b5 06 	lds	r24, 0x06B5
    2d04:	81 50       	subi	r24, 0x01	; 1
    2d06:	80 93 b5 06 	sts	0x06B5, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    2d0a:	80 91 b5 06 	lds	r24, 0x06B5
    2d0e:	88 23       	and	r24, r24
    2d10:	81 f7       	brne	.-32     	; 0x2cf2 <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    2d12:	80 91 b6 06 	lds	r24, 0x06B6
    2d16:	81 30       	cpi	r24, 0x01	; 1
    2d18:	21 f4       	brne	.+8      	; 0x2d22 <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2d1a:	81 e0       	ldi	r24, 0x01	; 1
    2d1c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2d1e:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2d22:	0f 90       	pop	r0
    2d24:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2d26:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d28:	0f 90       	pop	r0
    2d2a:	0f 90       	pop	r0
    2d2c:	0f 90       	pop	r0
    2d2e:	cf 91       	pop	r28
    2d30:	df 91       	pop	r29
    2d32:	08 95       	ret

00002d34 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2d34:	df 93       	push	r29
    2d36:	cf 93       	push	r28
    2d38:	00 d0       	rcall	.+0      	; 0x2d3a <xTaskGetTickCount+0x6>
    2d3a:	cd b7       	in	r28, 0x3d	; 61
    2d3c:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2d3e:	0f b6       	in	r0, 0x3f	; 63
    2d40:	f8 94       	cli
    2d42:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2d44:	80 91 b1 06 	lds	r24, 0x06B1
    2d48:	90 91 b2 06 	lds	r25, 0x06B2
    2d4c:	9a 83       	std	Y+2, r25	; 0x02
    2d4e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2d50:	0f 90       	pop	r0
    2d52:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2d54:	89 81       	ldd	r24, Y+1	; 0x01
    2d56:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d58:	0f 90       	pop	r0
    2d5a:	0f 90       	pop	r0
    2d5c:	cf 91       	pop	r28
    2d5e:	df 91       	pop	r29
    2d60:	08 95       	ret

00002d62 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    2d62:	df 93       	push	r29
    2d64:	cf 93       	push	r28
    2d66:	00 d0       	rcall	.+0      	; 0x2d68 <xTaskGetTickCountFromISR+0x6>
    2d68:	0f 92       	push	r0
    2d6a:	cd b7       	in	r28, 0x3d	; 61
    2d6c:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d6e:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    2d70:	80 91 b1 06 	lds	r24, 0x06B1
    2d74:	90 91 b2 06 	lds	r25, 0x06B2
    2d78:	9b 83       	std	Y+3, r25	; 0x03
    2d7a:	8a 83       	std	Y+2, r24	; 0x02
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2d80:	0f 90       	pop	r0
    2d82:	0f 90       	pop	r0
    2d84:	0f 90       	pop	r0
    2d86:	cf 91       	pop	r28
    2d88:	df 91       	pop	r29
    2d8a:	08 95       	ret

00002d8c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    2d8c:	df 93       	push	r29
    2d8e:	cf 93       	push	r28
    2d90:	cd b7       	in	r28, 0x3d	; 61
    2d92:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2d94:	80 91 b0 06 	lds	r24, 0x06B0
}
    2d98:	cf 91       	pop	r28
    2d9a:	df 91       	pop	r29
    2d9c:	08 95       	ret

00002d9e <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2d9e:	df 93       	push	r29
    2da0:	cf 93       	push	r28
    2da2:	cd b7       	in	r28, 0x3d	; 61
    2da4:	de b7       	in	r29, 0x3e	; 62
    2da6:	29 97       	sbiw	r28, 0x09	; 9
    2da8:	0f b6       	in	r0, 0x3f	; 63
    2daa:	f8 94       	cli
    2dac:	de bf       	out	0x3e, r29	; 62
    2dae:	0f be       	out	0x3f, r0	; 63
    2db0:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2db2:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2db4:	80 91 b9 06 	lds	r24, 0x06B9
    2db8:	88 23       	and	r24, r24
    2dba:	09 f0       	breq	.+2      	; 0x2dbe <xTaskIncrementTick+0x20>
    2dbc:	c2 c0       	rjmp	.+388    	; 0x2f42 <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    2dbe:	80 91 b1 06 	lds	r24, 0x06B1
    2dc2:	90 91 b2 06 	lds	r25, 0x06B2
    2dc6:	01 96       	adiw	r24, 0x01	; 1
    2dc8:	90 93 b2 06 	sts	0x06B2, r25
    2dcc:	80 93 b1 06 	sts	0x06B1, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2dd0:	80 91 b1 06 	lds	r24, 0x06B1
    2dd4:	90 91 b2 06 	lds	r25, 0x06B2
    2dd8:	9c 83       	std	Y+4, r25	; 0x04
    2dda:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    2ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dde:	9c 81       	ldd	r25, Y+4	; 0x04
    2de0:	00 97       	sbiw	r24, 0x00	; 0
    2de2:	d9 f4       	brne	.+54     	; 0x2e1a <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    2de4:	80 91 f0 06 	lds	r24, 0x06F0
    2de8:	90 91 f1 06 	lds	r25, 0x06F1
    2dec:	9a 83       	std	Y+2, r25	; 0x02
    2dee:	89 83       	std	Y+1, r24	; 0x01
    2df0:	80 91 f2 06 	lds	r24, 0x06F2
    2df4:	90 91 f3 06 	lds	r25, 0x06F3
    2df8:	90 93 f1 06 	sts	0x06F1, r25
    2dfc:	80 93 f0 06 	sts	0x06F0, r24
    2e00:	89 81       	ldd	r24, Y+1	; 0x01
    2e02:	9a 81       	ldd	r25, Y+2	; 0x02
    2e04:	90 93 f3 06 	sts	0x06F3, r25
    2e08:	80 93 f2 06 	sts	0x06F2, r24
    2e0c:	80 91 b7 06 	lds	r24, 0x06B7
    2e10:	8f 5f       	subi	r24, 0xFF	; 255
    2e12:	80 93 b7 06 	sts	0x06B7, r24
    2e16:	0e 94 8f 1b 	call	0x371e	; 0x371e <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    2e1a:	20 91 8c 00 	lds	r18, 0x008C
    2e1e:	30 91 8d 00 	lds	r19, 0x008D
    2e22:	8b 81       	ldd	r24, Y+3	; 0x03
    2e24:	9c 81       	ldd	r25, Y+4	; 0x04
    2e26:	82 17       	cp	r24, r18
    2e28:	93 07       	cpc	r25, r19
    2e2a:	08 f4       	brcc	.+2      	; 0x2e2e <xTaskIncrementTick+0x90>
    2e2c:	71 c0       	rjmp	.+226    	; 0x2f10 <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2e2e:	e0 91 f0 06 	lds	r30, 0x06F0
    2e32:	f0 91 f1 06 	lds	r31, 0x06F1
    2e36:	80 81       	ld	r24, Z
    2e38:	88 23       	and	r24, r24
    2e3a:	39 f4       	brne	.+14     	; 0x2e4a <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    2e3c:	8f ef       	ldi	r24, 0xFF	; 255
    2e3e:	9f ef       	ldi	r25, 0xFF	; 255
    2e40:	90 93 8d 00 	sts	0x008D, r25
    2e44:	80 93 8c 00 	sts	0x008C, r24
    2e48:	63 c0       	rjmp	.+198    	; 0x2f10 <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2e4a:	e0 91 f0 06 	lds	r30, 0x06F0
    2e4e:	f0 91 f1 06 	lds	r31, 0x06F1
    2e52:	05 80       	ldd	r0, Z+5	; 0x05
    2e54:	f6 81       	ldd	r31, Z+6	; 0x06
    2e56:	e0 2d       	mov	r30, r0
    2e58:	86 81       	ldd	r24, Z+6	; 0x06
    2e5a:	97 81       	ldd	r25, Z+7	; 0x07
    2e5c:	99 87       	std	Y+9, r25	; 0x09
    2e5e:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2e60:	e8 85       	ldd	r30, Y+8	; 0x08
    2e62:	f9 85       	ldd	r31, Y+9	; 0x09
    2e64:	82 81       	ldd	r24, Z+2	; 0x02
    2e66:	93 81       	ldd	r25, Z+3	; 0x03
    2e68:	9f 83       	std	Y+7, r25	; 0x07
    2e6a:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    2e6c:	2b 81       	ldd	r18, Y+3	; 0x03
    2e6e:	3c 81       	ldd	r19, Y+4	; 0x04
    2e70:	8e 81       	ldd	r24, Y+6	; 0x06
    2e72:	9f 81       	ldd	r25, Y+7	; 0x07
    2e74:	28 17       	cp	r18, r24
    2e76:	39 07       	cpc	r19, r25
    2e78:	38 f4       	brcc	.+14     	; 0x2e88 <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    2e7a:	8e 81       	ldd	r24, Y+6	; 0x06
    2e7c:	9f 81       	ldd	r25, Y+7	; 0x07
    2e7e:	90 93 8d 00 	sts	0x008D, r25
    2e82:	80 93 8c 00 	sts	0x008C, r24
    2e86:	44 c0       	rjmp	.+136    	; 0x2f10 <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2e88:	88 85       	ldd	r24, Y+8	; 0x08
    2e8a:	99 85       	ldd	r25, Y+9	; 0x09
    2e8c:	02 96       	adiw	r24, 0x02	; 2
    2e8e:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2e92:	e8 85       	ldd	r30, Y+8	; 0x08
    2e94:	f9 85       	ldd	r31, Y+9	; 0x09
    2e96:	84 89       	ldd	r24, Z+20	; 0x14
    2e98:	95 89       	ldd	r25, Z+21	; 0x15
    2e9a:	00 97       	sbiw	r24, 0x00	; 0
    2e9c:	29 f0       	breq	.+10     	; 0x2ea8 <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2e9e:	88 85       	ldd	r24, Y+8	; 0x08
    2ea0:	99 85       	ldd	r25, Y+9	; 0x09
    2ea2:	0c 96       	adiw	r24, 0x0c	; 12
    2ea4:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    2ea8:	e8 85       	ldd	r30, Y+8	; 0x08
    2eaa:	f9 85       	ldd	r31, Y+9	; 0x09
    2eac:	96 89       	ldd	r25, Z+22	; 0x16
    2eae:	80 91 b3 06 	lds	r24, 0x06B3
    2eb2:	89 17       	cp	r24, r25
    2eb4:	28 f4       	brcc	.+10     	; 0x2ec0 <xTaskIncrementTick+0x122>
    2eb6:	e8 85       	ldd	r30, Y+8	; 0x08
    2eb8:	f9 85       	ldd	r31, Y+9	; 0x09
    2eba:	86 89       	ldd	r24, Z+22	; 0x16
    2ebc:	80 93 b3 06 	sts	0x06B3, r24
    2ec0:	e8 85       	ldd	r30, Y+8	; 0x08
    2ec2:	f9 85       	ldd	r31, Y+9	; 0x09
    2ec4:	86 89       	ldd	r24, Z+22	; 0x16
    2ec6:	28 2f       	mov	r18, r24
    2ec8:	30 e0       	ldi	r19, 0x00	; 0
    2eca:	c9 01       	movw	r24, r18
    2ecc:	88 0f       	add	r24, r24
    2ece:	99 1f       	adc	r25, r25
    2ed0:	88 0f       	add	r24, r24
    2ed2:	99 1f       	adc	r25, r25
    2ed4:	88 0f       	add	r24, r24
    2ed6:	99 1f       	adc	r25, r25
    2ed8:	82 0f       	add	r24, r18
    2eda:	93 1f       	adc	r25, r19
    2edc:	ac 01       	movw	r20, r24
    2ede:	46 54       	subi	r20, 0x46	; 70
    2ee0:	59 4f       	sbci	r21, 0xF9	; 249
    2ee2:	88 85       	ldd	r24, Y+8	; 0x08
    2ee4:	99 85       	ldd	r25, Y+9	; 0x09
    2ee6:	9c 01       	movw	r18, r24
    2ee8:	2e 5f       	subi	r18, 0xFE	; 254
    2eea:	3f 4f       	sbci	r19, 0xFF	; 255
    2eec:	ca 01       	movw	r24, r20
    2eee:	b9 01       	movw	r22, r18
    2ef0:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2ef4:	e8 85       	ldd	r30, Y+8	; 0x08
    2ef6:	f9 85       	ldd	r31, Y+9	; 0x09
    2ef8:	96 89       	ldd	r25, Z+22	; 0x16
    2efa:	e0 91 ad 06 	lds	r30, 0x06AD
    2efe:	f0 91 ae 06 	lds	r31, 0x06AE
    2f02:	86 89       	ldd	r24, Z+22	; 0x16
    2f04:	98 17       	cp	r25, r24
    2f06:	08 f4       	brcc	.+2      	; 0x2f0a <xTaskIncrementTick+0x16c>
    2f08:	92 cf       	rjmp	.-220    	; 0x2e2e <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    2f0a:	81 e0       	ldi	r24, 0x01	; 1
    2f0c:	8d 83       	std	Y+5, r24	; 0x05
    2f0e:	8f cf       	rjmp	.-226    	; 0x2e2e <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2f10:	e0 91 ad 06 	lds	r30, 0x06AD
    2f14:	f0 91 ae 06 	lds	r31, 0x06AE
    2f18:	86 89       	ldd	r24, Z+22	; 0x16
    2f1a:	28 2f       	mov	r18, r24
    2f1c:	30 e0       	ldi	r19, 0x00	; 0
    2f1e:	c9 01       	movw	r24, r18
    2f20:	88 0f       	add	r24, r24
    2f22:	99 1f       	adc	r25, r25
    2f24:	88 0f       	add	r24, r24
    2f26:	99 1f       	adc	r25, r25
    2f28:	88 0f       	add	r24, r24
    2f2a:	99 1f       	adc	r25, r25
    2f2c:	82 0f       	add	r24, r18
    2f2e:	93 1f       	adc	r25, r19
    2f30:	fc 01       	movw	r30, r24
    2f32:	e6 54       	subi	r30, 0x46	; 70
    2f34:	f9 4f       	sbci	r31, 0xF9	; 249
    2f36:	80 81       	ld	r24, Z
    2f38:	82 30       	cpi	r24, 0x02	; 2
    2f3a:	40 f0       	brcs	.+16     	; 0x2f4c <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    2f3c:	81 e0       	ldi	r24, 0x01	; 1
    2f3e:	8d 83       	std	Y+5, r24	; 0x05
    2f40:	05 c0       	rjmp	.+10     	; 0x2f4c <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2f42:	80 91 b5 06 	lds	r24, 0x06B5
    2f46:	8f 5f       	subi	r24, 0xFF	; 255
    2f48:	80 93 b5 06 	sts	0x06B5, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2f4c:	80 91 b6 06 	lds	r24, 0x06B6
    2f50:	88 23       	and	r24, r24
    2f52:	11 f0       	breq	.+4      	; 0x2f58 <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    2f54:	81 e0       	ldi	r24, 0x01	; 1
    2f56:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2f58:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2f5a:	29 96       	adiw	r28, 0x09	; 9
    2f5c:	0f b6       	in	r0, 0x3f	; 63
    2f5e:	f8 94       	cli
    2f60:	de bf       	out	0x3e, r29	; 62
    2f62:	0f be       	out	0x3f, r0	; 63
    2f64:	cd bf       	out	0x3d, r28	; 61
    2f66:	cf 91       	pop	r28
    2f68:	df 91       	pop	r29
    2f6a:	08 95       	ret

00002f6c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2f6c:	df 93       	push	r29
    2f6e:	cf 93       	push	r28
    2f70:	00 d0       	rcall	.+0      	; 0x2f72 <vTaskSwitchContext+0x6>
    2f72:	cd b7       	in	r28, 0x3d	; 61
    2f74:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2f76:	80 91 b9 06 	lds	r24, 0x06B9
    2f7a:	88 23       	and	r24, r24
    2f7c:	21 f0       	breq	.+8      	; 0x2f86 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2f7e:	81 e0       	ldi	r24, 0x01	; 1
    2f80:	80 93 b6 06 	sts	0x06B6, r24
    2f84:	57 c0       	rjmp	.+174    	; 0x3034 <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    2f86:	10 92 b6 06 	sts	0x06B6, r1
    2f8a:	05 c0       	rjmp	.+10     	; 0x2f96 <vTaskSwitchContext+0x2a>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2f8c:	80 91 b3 06 	lds	r24, 0x06B3
    2f90:	81 50       	subi	r24, 0x01	; 1
    2f92:	80 93 b3 06 	sts	0x06B3, r24
    2f96:	80 91 b3 06 	lds	r24, 0x06B3
    2f9a:	28 2f       	mov	r18, r24
    2f9c:	30 e0       	ldi	r19, 0x00	; 0
    2f9e:	c9 01       	movw	r24, r18
    2fa0:	88 0f       	add	r24, r24
    2fa2:	99 1f       	adc	r25, r25
    2fa4:	88 0f       	add	r24, r24
    2fa6:	99 1f       	adc	r25, r25
    2fa8:	88 0f       	add	r24, r24
    2faa:	99 1f       	adc	r25, r25
    2fac:	82 0f       	add	r24, r18
    2fae:	93 1f       	adc	r25, r19
    2fb0:	fc 01       	movw	r30, r24
    2fb2:	e6 54       	subi	r30, 0x46	; 70
    2fb4:	f9 4f       	sbci	r31, 0xF9	; 249
    2fb6:	80 81       	ld	r24, Z
    2fb8:	88 23       	and	r24, r24
    2fba:	41 f3       	breq	.-48     	; 0x2f8c <vTaskSwitchContext+0x20>
    2fbc:	80 91 b3 06 	lds	r24, 0x06B3
    2fc0:	28 2f       	mov	r18, r24
    2fc2:	30 e0       	ldi	r19, 0x00	; 0
    2fc4:	c9 01       	movw	r24, r18
    2fc6:	88 0f       	add	r24, r24
    2fc8:	99 1f       	adc	r25, r25
    2fca:	88 0f       	add	r24, r24
    2fcc:	99 1f       	adc	r25, r25
    2fce:	88 0f       	add	r24, r24
    2fd0:	99 1f       	adc	r25, r25
    2fd2:	82 0f       	add	r24, r18
    2fd4:	93 1f       	adc	r25, r19
    2fd6:	86 54       	subi	r24, 0x46	; 70
    2fd8:	99 4f       	sbci	r25, 0xF9	; 249
    2fda:	9a 83       	std	Y+2, r25	; 0x02
    2fdc:	89 83       	std	Y+1, r24	; 0x01
    2fde:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe0:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe2:	01 80       	ldd	r0, Z+1	; 0x01
    2fe4:	f2 81       	ldd	r31, Z+2	; 0x02
    2fe6:	e0 2d       	mov	r30, r0
    2fe8:	82 81       	ldd	r24, Z+2	; 0x02
    2fea:	93 81       	ldd	r25, Z+3	; 0x03
    2fec:	e9 81       	ldd	r30, Y+1	; 0x01
    2fee:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff0:	92 83       	std	Z+2, r25	; 0x02
    2ff2:	81 83       	std	Z+1, r24	; 0x01
    2ff4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff8:	21 81       	ldd	r18, Z+1	; 0x01
    2ffa:	32 81       	ldd	r19, Z+2	; 0x02
    2ffc:	89 81       	ldd	r24, Y+1	; 0x01
    2ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    3000:	03 96       	adiw	r24, 0x03	; 3
    3002:	28 17       	cp	r18, r24
    3004:	39 07       	cpc	r19, r25
    3006:	59 f4       	brne	.+22     	; 0x301e <vTaskSwitchContext+0xb2>
    3008:	e9 81       	ldd	r30, Y+1	; 0x01
    300a:	fa 81       	ldd	r31, Y+2	; 0x02
    300c:	01 80       	ldd	r0, Z+1	; 0x01
    300e:	f2 81       	ldd	r31, Z+2	; 0x02
    3010:	e0 2d       	mov	r30, r0
    3012:	82 81       	ldd	r24, Z+2	; 0x02
    3014:	93 81       	ldd	r25, Z+3	; 0x03
    3016:	e9 81       	ldd	r30, Y+1	; 0x01
    3018:	fa 81       	ldd	r31, Y+2	; 0x02
    301a:	92 83       	std	Z+2, r25	; 0x02
    301c:	81 83       	std	Z+1, r24	; 0x01
    301e:	e9 81       	ldd	r30, Y+1	; 0x01
    3020:	fa 81       	ldd	r31, Y+2	; 0x02
    3022:	01 80       	ldd	r0, Z+1	; 0x01
    3024:	f2 81       	ldd	r31, Z+2	; 0x02
    3026:	e0 2d       	mov	r30, r0
    3028:	86 81       	ldd	r24, Z+6	; 0x06
    302a:	97 81       	ldd	r25, Z+7	; 0x07
    302c:	90 93 ae 06 	sts	0x06AE, r25
    3030:	80 93 ad 06 	sts	0x06AD, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3034:	0f 90       	pop	r0
    3036:	0f 90       	pop	r0
    3038:	cf 91       	pop	r28
    303a:	df 91       	pop	r29
    303c:	08 95       	ret

0000303e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    303e:	df 93       	push	r29
    3040:	cf 93       	push	r28
    3042:	00 d0       	rcall	.+0      	; 0x3044 <vTaskPlaceOnEventList+0x6>
    3044:	00 d0       	rcall	.+0      	; 0x3046 <vTaskPlaceOnEventList+0x8>
    3046:	00 d0       	rcall	.+0      	; 0x3048 <vTaskPlaceOnEventList+0xa>
    3048:	cd b7       	in	r28, 0x3d	; 61
    304a:	de b7       	in	r29, 0x3e	; 62
    304c:	9c 83       	std	Y+4, r25	; 0x04
    304e:	8b 83       	std	Y+3, r24	; 0x03
    3050:	7e 83       	std	Y+6, r23	; 0x06
    3052:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3054:	80 91 ad 06 	lds	r24, 0x06AD
    3058:	90 91 ae 06 	lds	r25, 0x06AE
    305c:	9c 01       	movw	r18, r24
    305e:	24 5f       	subi	r18, 0xF4	; 244
    3060:	3f 4f       	sbci	r19, 0xFF	; 255
    3062:	8b 81       	ldd	r24, Y+3	; 0x03
    3064:	9c 81       	ldd	r25, Y+4	; 0x04
    3066:	b9 01       	movw	r22, r18
    3068:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    306c:	80 91 ad 06 	lds	r24, 0x06AD
    3070:	90 91 ae 06 	lds	r25, 0x06AE
    3074:	02 96       	adiw	r24, 0x02	; 2
    3076:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    307a:	20 91 b1 06 	lds	r18, 0x06B1
    307e:	30 91 b2 06 	lds	r19, 0x06B2
    3082:	8d 81       	ldd	r24, Y+5	; 0x05
    3084:	9e 81       	ldd	r25, Y+6	; 0x06
    3086:	82 0f       	add	r24, r18
    3088:	93 1f       	adc	r25, r19
    308a:	9a 83       	std	Y+2, r25	; 0x02
    308c:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    308e:	89 81       	ldd	r24, Y+1	; 0x01
    3090:	9a 81       	ldd	r25, Y+2	; 0x02
    3092:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3096:	26 96       	adiw	r28, 0x06	; 6
    3098:	0f b6       	in	r0, 0x3f	; 63
    309a:	f8 94       	cli
    309c:	de bf       	out	0x3e, r29	; 62
    309e:	0f be       	out	0x3f, r0	; 63
    30a0:	cd bf       	out	0x3d, r28	; 61
    30a2:	cf 91       	pop	r28
    30a4:	df 91       	pop	r29
    30a6:	08 95       	ret

000030a8 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    30a8:	df 93       	push	r29
    30aa:	cf 93       	push	r28
    30ac:	cd b7       	in	r28, 0x3d	; 61
    30ae:	de b7       	in	r29, 0x3e	; 62
    30b0:	28 97       	sbiw	r28, 0x08	; 8
    30b2:	0f b6       	in	r0, 0x3f	; 63
    30b4:	f8 94       	cli
    30b6:	de bf       	out	0x3e, r29	; 62
    30b8:	0f be       	out	0x3f, r0	; 63
    30ba:	cd bf       	out	0x3d, r28	; 61
    30bc:	9c 83       	std	Y+4, r25	; 0x04
    30be:	8b 83       	std	Y+3, r24	; 0x03
    30c0:	7e 83       	std	Y+6, r23	; 0x06
    30c2:	6d 83       	std	Y+5, r22	; 0x05
    30c4:	58 87       	std	Y+8, r21	; 0x08
    30c6:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    30c8:	e0 91 ad 06 	lds	r30, 0x06AD
    30cc:	f0 91 ae 06 	lds	r31, 0x06AE
    30d0:	8d 81       	ldd	r24, Y+5	; 0x05
    30d2:	9e 81       	ldd	r25, Y+6	; 0x06
    30d4:	90 68       	ori	r25, 0x80	; 128
    30d6:	95 87       	std	Z+13, r25	; 0x0d
    30d8:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    30da:	80 91 ad 06 	lds	r24, 0x06AD
    30de:	90 91 ae 06 	lds	r25, 0x06AE
    30e2:	9c 01       	movw	r18, r24
    30e4:	24 5f       	subi	r18, 0xF4	; 244
    30e6:	3f 4f       	sbci	r19, 0xFF	; 255
    30e8:	8b 81       	ldd	r24, Y+3	; 0x03
    30ea:	9c 81       	ldd	r25, Y+4	; 0x04
    30ec:	b9 01       	movw	r22, r18
    30ee:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    30f2:	80 91 ad 06 	lds	r24, 0x06AD
    30f6:	90 91 ae 06 	lds	r25, 0x06AE
    30fa:	02 96       	adiw	r24, 0x02	; 2
    30fc:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    3100:	20 91 b1 06 	lds	r18, 0x06B1
    3104:	30 91 b2 06 	lds	r19, 0x06B2
    3108:	8f 81       	ldd	r24, Y+7	; 0x07
    310a:	98 85       	ldd	r25, Y+8	; 0x08
    310c:	82 0f       	add	r24, r18
    310e:	93 1f       	adc	r25, r19
    3110:	9a 83       	std	Y+2, r25	; 0x02
    3112:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3114:	89 81       	ldd	r24, Y+1	; 0x01
    3116:	9a 81       	ldd	r25, Y+2	; 0x02
    3118:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    311c:	28 96       	adiw	r28, 0x08	; 8
    311e:	0f b6       	in	r0, 0x3f	; 63
    3120:	f8 94       	cli
    3122:	de bf       	out	0x3e, r29	; 62
    3124:	0f be       	out	0x3f, r0	; 63
    3126:	cd bf       	out	0x3d, r28	; 61
    3128:	cf 91       	pop	r28
    312a:	df 91       	pop	r29
    312c:	08 95       	ret

0000312e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    312e:	df 93       	push	r29
    3130:	cf 93       	push	r28
    3132:	00 d0       	rcall	.+0      	; 0x3134 <xTaskRemoveFromEventList+0x6>
    3134:	00 d0       	rcall	.+0      	; 0x3136 <xTaskRemoveFromEventList+0x8>
    3136:	0f 92       	push	r0
    3138:	cd b7       	in	r28, 0x3d	; 61
    313a:	de b7       	in	r29, 0x3e	; 62
    313c:	9d 83       	std	Y+5, r25	; 0x05
    313e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3140:	ec 81       	ldd	r30, Y+4	; 0x04
    3142:	fd 81       	ldd	r31, Y+5	; 0x05
    3144:	05 80       	ldd	r0, Z+5	; 0x05
    3146:	f6 81       	ldd	r31, Z+6	; 0x06
    3148:	e0 2d       	mov	r30, r0
    314a:	86 81       	ldd	r24, Z+6	; 0x06
    314c:	97 81       	ldd	r25, Z+7	; 0x07
    314e:	9b 83       	std	Y+3, r25	; 0x03
    3150:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3152:	8a 81       	ldd	r24, Y+2	; 0x02
    3154:	9b 81       	ldd	r25, Y+3	; 0x03
    3156:	0c 96       	adiw	r24, 0x0c	; 12
    3158:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    315c:	80 91 b9 06 	lds	r24, 0x06B9
    3160:	88 23       	and	r24, r24
    3162:	61 f5       	brne	.+88     	; 0x31bc <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3164:	8a 81       	ldd	r24, Y+2	; 0x02
    3166:	9b 81       	ldd	r25, Y+3	; 0x03
    3168:	02 96       	adiw	r24, 0x02	; 2
    316a:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    316e:	ea 81       	ldd	r30, Y+2	; 0x02
    3170:	fb 81       	ldd	r31, Y+3	; 0x03
    3172:	96 89       	ldd	r25, Z+22	; 0x16
    3174:	80 91 b3 06 	lds	r24, 0x06B3
    3178:	89 17       	cp	r24, r25
    317a:	28 f4       	brcc	.+10     	; 0x3186 <xTaskRemoveFromEventList+0x58>
    317c:	ea 81       	ldd	r30, Y+2	; 0x02
    317e:	fb 81       	ldd	r31, Y+3	; 0x03
    3180:	86 89       	ldd	r24, Z+22	; 0x16
    3182:	80 93 b3 06 	sts	0x06B3, r24
    3186:	ea 81       	ldd	r30, Y+2	; 0x02
    3188:	fb 81       	ldd	r31, Y+3	; 0x03
    318a:	86 89       	ldd	r24, Z+22	; 0x16
    318c:	28 2f       	mov	r18, r24
    318e:	30 e0       	ldi	r19, 0x00	; 0
    3190:	c9 01       	movw	r24, r18
    3192:	88 0f       	add	r24, r24
    3194:	99 1f       	adc	r25, r25
    3196:	88 0f       	add	r24, r24
    3198:	99 1f       	adc	r25, r25
    319a:	88 0f       	add	r24, r24
    319c:	99 1f       	adc	r25, r25
    319e:	82 0f       	add	r24, r18
    31a0:	93 1f       	adc	r25, r19
    31a2:	ac 01       	movw	r20, r24
    31a4:	46 54       	subi	r20, 0x46	; 70
    31a6:	59 4f       	sbci	r21, 0xF9	; 249
    31a8:	8a 81       	ldd	r24, Y+2	; 0x02
    31aa:	9b 81       	ldd	r25, Y+3	; 0x03
    31ac:	9c 01       	movw	r18, r24
    31ae:	2e 5f       	subi	r18, 0xFE	; 254
    31b0:	3f 4f       	sbci	r19, 0xFF	; 255
    31b2:	ca 01       	movw	r24, r20
    31b4:	b9 01       	movw	r22, r18
    31b6:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
    31ba:	0a c0       	rjmp	.+20     	; 0x31d0 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    31bc:	8a 81       	ldd	r24, Y+2	; 0x02
    31be:	9b 81       	ldd	r25, Y+3	; 0x03
    31c0:	9c 01       	movw	r18, r24
    31c2:	24 5f       	subi	r18, 0xF4	; 244
    31c4:	3f 4f       	sbci	r19, 0xFF	; 255
    31c6:	84 ef       	ldi	r24, 0xF4	; 244
    31c8:	96 e0       	ldi	r25, 0x06	; 6
    31ca:	b9 01       	movw	r22, r18
    31cc:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    31d0:	ea 81       	ldd	r30, Y+2	; 0x02
    31d2:	fb 81       	ldd	r31, Y+3	; 0x03
    31d4:	96 89       	ldd	r25, Z+22	; 0x16
    31d6:	e0 91 ad 06 	lds	r30, 0x06AD
    31da:	f0 91 ae 06 	lds	r31, 0x06AE
    31de:	86 89       	ldd	r24, Z+22	; 0x16
    31e0:	89 17       	cp	r24, r25
    31e2:	30 f4       	brcc	.+12     	; 0x31f0 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    31e4:	81 e0       	ldi	r24, 0x01	; 1
    31e6:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    31e8:	81 e0       	ldi	r24, 0x01	; 1
    31ea:	80 93 b6 06 	sts	0x06B6, r24
    31ee:	01 c0       	rjmp	.+2      	; 0x31f2 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    31f0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    31f2:	89 81       	ldd	r24, Y+1	; 0x01
}
    31f4:	0f 90       	pop	r0
    31f6:	0f 90       	pop	r0
    31f8:	0f 90       	pop	r0
    31fa:	0f 90       	pop	r0
    31fc:	0f 90       	pop	r0
    31fe:	cf 91       	pop	r28
    3200:	df 91       	pop	r29
    3202:	08 95       	ret

00003204 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3204:	df 93       	push	r29
    3206:	cf 93       	push	r28
    3208:	cd b7       	in	r28, 0x3d	; 61
    320a:	de b7       	in	r29, 0x3e	; 62
    320c:	27 97       	sbiw	r28, 0x07	; 7
    320e:	0f b6       	in	r0, 0x3f	; 63
    3210:	f8 94       	cli
    3212:	de bf       	out	0x3e, r29	; 62
    3214:	0f be       	out	0x3f, r0	; 63
    3216:	cd bf       	out	0x3d, r28	; 61
    3218:	9d 83       	std	Y+5, r25	; 0x05
    321a:	8c 83       	std	Y+4, r24	; 0x04
    321c:	7f 83       	std	Y+7, r23	; 0x07
    321e:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3220:	8e 81       	ldd	r24, Y+6	; 0x06
    3222:	9f 81       	ldd	r25, Y+7	; 0x07
    3224:	90 68       	ori	r25, 0x80	; 128
    3226:	ec 81       	ldd	r30, Y+4	; 0x04
    3228:	fd 81       	ldd	r31, Y+5	; 0x05
    322a:	91 83       	std	Z+1, r25	; 0x01
    322c:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    322e:	ec 81       	ldd	r30, Y+4	; 0x04
    3230:	fd 81       	ldd	r31, Y+5	; 0x05
    3232:	86 81       	ldd	r24, Z+6	; 0x06
    3234:	97 81       	ldd	r25, Z+7	; 0x07
    3236:	9b 83       	std	Y+3, r25	; 0x03
    3238:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    323a:	8c 81       	ldd	r24, Y+4	; 0x04
    323c:	9d 81       	ldd	r25, Y+5	; 0x05
    323e:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3242:	8a 81       	ldd	r24, Y+2	; 0x02
    3244:	9b 81       	ldd	r25, Y+3	; 0x03
    3246:	02 96       	adiw	r24, 0x02	; 2
    3248:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    324c:	ea 81       	ldd	r30, Y+2	; 0x02
    324e:	fb 81       	ldd	r31, Y+3	; 0x03
    3250:	96 89       	ldd	r25, Z+22	; 0x16
    3252:	80 91 b3 06 	lds	r24, 0x06B3
    3256:	89 17       	cp	r24, r25
    3258:	28 f4       	brcc	.+10     	; 0x3264 <xTaskRemoveFromUnorderedEventList+0x60>
    325a:	ea 81       	ldd	r30, Y+2	; 0x02
    325c:	fb 81       	ldd	r31, Y+3	; 0x03
    325e:	86 89       	ldd	r24, Z+22	; 0x16
    3260:	80 93 b3 06 	sts	0x06B3, r24
    3264:	ea 81       	ldd	r30, Y+2	; 0x02
    3266:	fb 81       	ldd	r31, Y+3	; 0x03
    3268:	86 89       	ldd	r24, Z+22	; 0x16
    326a:	28 2f       	mov	r18, r24
    326c:	30 e0       	ldi	r19, 0x00	; 0
    326e:	c9 01       	movw	r24, r18
    3270:	88 0f       	add	r24, r24
    3272:	99 1f       	adc	r25, r25
    3274:	88 0f       	add	r24, r24
    3276:	99 1f       	adc	r25, r25
    3278:	88 0f       	add	r24, r24
    327a:	99 1f       	adc	r25, r25
    327c:	82 0f       	add	r24, r18
    327e:	93 1f       	adc	r25, r19
    3280:	ac 01       	movw	r20, r24
    3282:	46 54       	subi	r20, 0x46	; 70
    3284:	59 4f       	sbci	r21, 0xF9	; 249
    3286:	8a 81       	ldd	r24, Y+2	; 0x02
    3288:	9b 81       	ldd	r25, Y+3	; 0x03
    328a:	9c 01       	movw	r18, r24
    328c:	2e 5f       	subi	r18, 0xFE	; 254
    328e:	3f 4f       	sbci	r19, 0xFF	; 255
    3290:	ca 01       	movw	r24, r20
    3292:	b9 01       	movw	r22, r18
    3294:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3298:	ea 81       	ldd	r30, Y+2	; 0x02
    329a:	fb 81       	ldd	r31, Y+3	; 0x03
    329c:	96 89       	ldd	r25, Z+22	; 0x16
    329e:	e0 91 ad 06 	lds	r30, 0x06AD
    32a2:	f0 91 ae 06 	lds	r31, 0x06AE
    32a6:	86 89       	ldd	r24, Z+22	; 0x16
    32a8:	89 17       	cp	r24, r25
    32aa:	30 f4       	brcc	.+12     	; 0x32b8 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    32ac:	81 e0       	ldi	r24, 0x01	; 1
    32ae:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	80 93 b6 06 	sts	0x06B6, r24
    32b6:	01 c0       	rjmp	.+2      	; 0x32ba <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    32b8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    32ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    32bc:	27 96       	adiw	r28, 0x07	; 7
    32be:	0f b6       	in	r0, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	de bf       	out	0x3e, r29	; 62
    32c4:	0f be       	out	0x3f, r0	; 63
    32c6:	cd bf       	out	0x3d, r28	; 61
    32c8:	cf 91       	pop	r28
    32ca:	df 91       	pop	r29
    32cc:	08 95       	ret

000032ce <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    32ce:	df 93       	push	r29
    32d0:	cf 93       	push	r28
    32d2:	00 d0       	rcall	.+0      	; 0x32d4 <vTaskSetTimeOutState+0x6>
    32d4:	cd b7       	in	r28, 0x3d	; 61
    32d6:	de b7       	in	r29, 0x3e	; 62
    32d8:	9a 83       	std	Y+2, r25	; 0x02
    32da:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    32dc:	80 91 b7 06 	lds	r24, 0x06B7
    32e0:	e9 81       	ldd	r30, Y+1	; 0x01
    32e2:	fa 81       	ldd	r31, Y+2	; 0x02
    32e4:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    32e6:	80 91 b1 06 	lds	r24, 0x06B1
    32ea:	90 91 b2 06 	lds	r25, 0x06B2
    32ee:	e9 81       	ldd	r30, Y+1	; 0x01
    32f0:	fa 81       	ldd	r31, Y+2	; 0x02
    32f2:	92 83       	std	Z+2, r25	; 0x02
    32f4:	81 83       	std	Z+1, r24	; 0x01
}
    32f6:	0f 90       	pop	r0
    32f8:	0f 90       	pop	r0
    32fa:	cf 91       	pop	r28
    32fc:	df 91       	pop	r29
    32fe:	08 95       	ret

00003300 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3300:	df 93       	push	r29
    3302:	cf 93       	push	r28
    3304:	cd b7       	in	r28, 0x3d	; 61
    3306:	de b7       	in	r29, 0x3e	; 62
    3308:	27 97       	sbiw	r28, 0x07	; 7
    330a:	0f b6       	in	r0, 0x3f	; 63
    330c:	f8 94       	cli
    330e:	de bf       	out	0x3e, r29	; 62
    3310:	0f be       	out	0x3f, r0	; 63
    3312:	cd bf       	out	0x3d, r28	; 61
    3314:	9d 83       	std	Y+5, r25	; 0x05
    3316:	8c 83       	std	Y+4, r24	; 0x04
    3318:	7f 83       	std	Y+7, r23	; 0x07
    331a:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    331c:	0f b6       	in	r0, 0x3f	; 63
    331e:	f8 94       	cli
    3320:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3322:	80 91 b1 06 	lds	r24, 0x06B1
    3326:	90 91 b2 06 	lds	r25, 0x06B2
    332a:	9a 83       	std	Y+2, r25	; 0x02
    332c:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    332e:	ec 81       	ldd	r30, Y+4	; 0x04
    3330:	fd 81       	ldd	r31, Y+5	; 0x05
    3332:	90 81       	ld	r25, Z
    3334:	80 91 b7 06 	lds	r24, 0x06B7
    3338:	98 17       	cp	r25, r24
    333a:	61 f0       	breq	.+24     	; 0x3354 <xTaskCheckForTimeOut+0x54>
    333c:	ec 81       	ldd	r30, Y+4	; 0x04
    333e:	fd 81       	ldd	r31, Y+5	; 0x05
    3340:	21 81       	ldd	r18, Z+1	; 0x01
    3342:	32 81       	ldd	r19, Z+2	; 0x02
    3344:	89 81       	ldd	r24, Y+1	; 0x01
    3346:	9a 81       	ldd	r25, Y+2	; 0x02
    3348:	82 17       	cp	r24, r18
    334a:	93 07       	cpc	r25, r19
    334c:	18 f0       	brcs	.+6      	; 0x3354 <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    334e:	81 e0       	ldi	r24, 0x01	; 1
    3350:	8b 83       	std	Y+3, r24	; 0x03
    3352:	2d c0       	rjmp	.+90     	; 0x33ae <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    3354:	ec 81       	ldd	r30, Y+4	; 0x04
    3356:	fd 81       	ldd	r31, Y+5	; 0x05
    3358:	21 81       	ldd	r18, Z+1	; 0x01
    335a:	32 81       	ldd	r19, Z+2	; 0x02
    335c:	89 81       	ldd	r24, Y+1	; 0x01
    335e:	9a 81       	ldd	r25, Y+2	; 0x02
    3360:	ac 01       	movw	r20, r24
    3362:	42 1b       	sub	r20, r18
    3364:	53 0b       	sbc	r21, r19
    3366:	9a 01       	movw	r18, r20
    3368:	ee 81       	ldd	r30, Y+6	; 0x06
    336a:	ff 81       	ldd	r31, Y+7	; 0x07
    336c:	80 81       	ld	r24, Z
    336e:	91 81       	ldd	r25, Z+1	; 0x01
    3370:	28 17       	cp	r18, r24
    3372:	39 07       	cpc	r19, r25
    3374:	d0 f4       	brcc	.+52     	; 0x33aa <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    3376:	ee 81       	ldd	r30, Y+6	; 0x06
    3378:	ff 81       	ldd	r31, Y+7	; 0x07
    337a:	40 81       	ld	r20, Z
    337c:	51 81       	ldd	r21, Z+1	; 0x01
    337e:	ec 81       	ldd	r30, Y+4	; 0x04
    3380:	fd 81       	ldd	r31, Y+5	; 0x05
    3382:	21 81       	ldd	r18, Z+1	; 0x01
    3384:	32 81       	ldd	r19, Z+2	; 0x02
    3386:	89 81       	ldd	r24, Y+1	; 0x01
    3388:	9a 81       	ldd	r25, Y+2	; 0x02
    338a:	b9 01       	movw	r22, r18
    338c:	68 1b       	sub	r22, r24
    338e:	79 0b       	sbc	r23, r25
    3390:	cb 01       	movw	r24, r22
    3392:	84 0f       	add	r24, r20
    3394:	95 1f       	adc	r25, r21
    3396:	ee 81       	ldd	r30, Y+6	; 0x06
    3398:	ff 81       	ldd	r31, Y+7	; 0x07
    339a:	91 83       	std	Z+1, r25	; 0x01
    339c:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    339e:	8c 81       	ldd	r24, Y+4	; 0x04
    33a0:	9d 81       	ldd	r25, Y+5	; 0x05
    33a2:	0e 94 67 19 	call	0x32ce	; 0x32ce <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    33a6:	1b 82       	std	Y+3, r1	; 0x03
    33a8:	02 c0       	rjmp	.+4      	; 0x33ae <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    33aa:	81 e0       	ldi	r24, 0x01	; 1
    33ac:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    33ae:	0f 90       	pop	r0
    33b0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    33b2:	8b 81       	ldd	r24, Y+3	; 0x03
}
    33b4:	27 96       	adiw	r28, 0x07	; 7
    33b6:	0f b6       	in	r0, 0x3f	; 63
    33b8:	f8 94       	cli
    33ba:	de bf       	out	0x3e, r29	; 62
    33bc:	0f be       	out	0x3f, r0	; 63
    33be:	cd bf       	out	0x3d, r28	; 61
    33c0:	cf 91       	pop	r28
    33c2:	df 91       	pop	r29
    33c4:	08 95       	ret

000033c6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    33c6:	df 93       	push	r29
    33c8:	cf 93       	push	r28
    33ca:	cd b7       	in	r28, 0x3d	; 61
    33cc:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    33ce:	81 e0       	ldi	r24, 0x01	; 1
    33d0:	80 93 b6 06 	sts	0x06B6, r24
}
    33d4:	cf 91       	pop	r28
    33d6:	df 91       	pop	r29
    33d8:	08 95       	ret

000033da <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    33da:	df 93       	push	r29
    33dc:	cf 93       	push	r28
    33de:	00 d0       	rcall	.+0      	; 0x33e0 <prvIdleTask+0x6>
    33e0:	cd b7       	in	r28, 0x3d	; 61
    33e2:	de b7       	in	r29, 0x3e	; 62
    33e4:	9a 83       	std	Y+2, r25	; 0x02
    33e6:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    33e8:	0e 94 ad 1a 	call	0x355a	; 0x355a <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    33ec:	80 91 ba 06 	lds	r24, 0x06BA
    33f0:	82 30       	cpi	r24, 0x02	; 2
    33f2:	d0 f3       	brcs	.-12     	; 0x33e8 <prvIdleTask+0xe>
			{
				taskYIELD();
    33f4:	0e 94 8e 0b 	call	0x171c	; 0x171c <vPortYield>
    33f8:	f7 cf       	rjmp	.-18     	; 0x33e8 <prvIdleTask+0xe>

000033fa <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    33fa:	0f 93       	push	r16
    33fc:	1f 93       	push	r17
    33fe:	df 93       	push	r29
    3400:	cf 93       	push	r28
    3402:	cd b7       	in	r28, 0x3d	; 61
    3404:	de b7       	in	r29, 0x3e	; 62
    3406:	2a 97       	sbiw	r28, 0x0a	; 10
    3408:	0f b6       	in	r0, 0x3f	; 63
    340a:	f8 94       	cli
    340c:	de bf       	out	0x3e, r29	; 62
    340e:	0f be       	out	0x3f, r0	; 63
    3410:	cd bf       	out	0x3d, r28	; 61
    3412:	9b 83       	std	Y+3, r25	; 0x03
    3414:	8a 83       	std	Y+2, r24	; 0x02
    3416:	7d 83       	std	Y+5, r23	; 0x05
    3418:	6c 83       	std	Y+4, r22	; 0x04
    341a:	4e 83       	std	Y+6, r20	; 0x06
    341c:	38 87       	std	Y+8, r19	; 0x08
    341e:	2f 83       	std	Y+7, r18	; 0x07
    3420:	1a 87       	std	Y+10, r17	; 0x0a
    3422:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3424:	19 82       	std	Y+1, r1	; 0x01
    3426:	21 c0       	rjmp	.+66     	; 0x346a <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    3428:	89 81       	ldd	r24, Y+1	; 0x01
    342a:	48 2f       	mov	r20, r24
    342c:	50 e0       	ldi	r21, 0x00	; 0
    342e:	89 81       	ldd	r24, Y+1	; 0x01
    3430:	28 2f       	mov	r18, r24
    3432:	30 e0       	ldi	r19, 0x00	; 0
    3434:	8c 81       	ldd	r24, Y+4	; 0x04
    3436:	9d 81       	ldd	r25, Y+5	; 0x05
    3438:	fc 01       	movw	r30, r24
    343a:	e2 0f       	add	r30, r18
    343c:	f3 1f       	adc	r31, r19
    343e:	20 81       	ld	r18, Z
    3440:	8a 81       	ldd	r24, Y+2	; 0x02
    3442:	9b 81       	ldd	r25, Y+3	; 0x03
    3444:	84 0f       	add	r24, r20
    3446:	95 1f       	adc	r25, r21
    3448:	fc 01       	movw	r30, r24
    344a:	79 96       	adiw	r30, 0x19	; 25
    344c:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    344e:	89 81       	ldd	r24, Y+1	; 0x01
    3450:	28 2f       	mov	r18, r24
    3452:	30 e0       	ldi	r19, 0x00	; 0
    3454:	8c 81       	ldd	r24, Y+4	; 0x04
    3456:	9d 81       	ldd	r25, Y+5	; 0x05
    3458:	fc 01       	movw	r30, r24
    345a:	e2 0f       	add	r30, r18
    345c:	f3 1f       	adc	r31, r19
    345e:	80 81       	ld	r24, Z
    3460:	88 23       	and	r24, r24
    3462:	31 f0       	breq	.+12     	; 0x3470 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3464:	89 81       	ldd	r24, Y+1	; 0x01
    3466:	8f 5f       	subi	r24, 0xFF	; 255
    3468:	89 83       	std	Y+1, r24	; 0x01
    346a:	89 81       	ldd	r24, Y+1	; 0x01
    346c:	84 31       	cpi	r24, 0x14	; 20
    346e:	e0 f2       	brcs	.-72     	; 0x3428 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3470:	ea 81       	ldd	r30, Y+2	; 0x02
    3472:	fb 81       	ldd	r31, Y+3	; 0x03
    3474:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3476:	8e 81       	ldd	r24, Y+6	; 0x06
    3478:	84 30       	cpi	r24, 0x04	; 4
    347a:	10 f0       	brcs	.+4      	; 0x3480 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    347c:	83 e0       	ldi	r24, 0x03	; 3
    347e:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    3480:	ea 81       	ldd	r30, Y+2	; 0x02
    3482:	fb 81       	ldd	r31, Y+3	; 0x03
    3484:	8e 81       	ldd	r24, Y+6	; 0x06
    3486:	86 8b       	std	Z+22, r24	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3488:	8a 81       	ldd	r24, Y+2	; 0x02
    348a:	9b 81       	ldd	r25, Y+3	; 0x03
    348c:	02 96       	adiw	r24, 0x02	; 2
    348e:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    3492:	8a 81       	ldd	r24, Y+2	; 0x02
    3494:	9b 81       	ldd	r25, Y+3	; 0x03
    3496:	0c 96       	adiw	r24, 0x0c	; 12
    3498:	0e 94 c3 08 	call	0x1186	; 0x1186 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    349c:	ea 81       	ldd	r30, Y+2	; 0x02
    349e:	fb 81       	ldd	r31, Y+3	; 0x03
    34a0:	8a 81       	ldd	r24, Y+2	; 0x02
    34a2:	9b 81       	ldd	r25, Y+3	; 0x03
    34a4:	91 87       	std	Z+9, r25	; 0x09
    34a6:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    34a8:	8e 81       	ldd	r24, Y+6	; 0x06
    34aa:	28 2f       	mov	r18, r24
    34ac:	30 e0       	ldi	r19, 0x00	; 0
    34ae:	84 e0       	ldi	r24, 0x04	; 4
    34b0:	90 e0       	ldi	r25, 0x00	; 0
    34b2:	82 1b       	sub	r24, r18
    34b4:	93 0b       	sbc	r25, r19
    34b6:	ea 81       	ldd	r30, Y+2	; 0x02
    34b8:	fb 81       	ldd	r31, Y+3	; 0x03
    34ba:	95 87       	std	Z+13, r25	; 0x0d
    34bc:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    34be:	ea 81       	ldd	r30, Y+2	; 0x02
    34c0:	fb 81       	ldd	r31, Y+3	; 0x03
    34c2:	8a 81       	ldd	r24, Y+2	; 0x02
    34c4:	9b 81       	ldd	r25, Y+3	; 0x03
    34c6:	93 8b       	std	Z+19, r25	; 0x13
    34c8:	82 8b       	std	Z+18, r24	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    34ca:	2a 96       	adiw	r28, 0x0a	; 10
    34cc:	0f b6       	in	r0, 0x3f	; 63
    34ce:	f8 94       	cli
    34d0:	de bf       	out	0x3e, r29	; 62
    34d2:	0f be       	out	0x3f, r0	; 63
    34d4:	cd bf       	out	0x3d, r28	; 61
    34d6:	cf 91       	pop	r28
    34d8:	df 91       	pop	r29
    34da:	1f 91       	pop	r17
    34dc:	0f 91       	pop	r16
    34de:	08 95       	ret

000034e0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    34e0:	df 93       	push	r29
    34e2:	cf 93       	push	r28
    34e4:	0f 92       	push	r0
    34e6:	cd b7       	in	r28, 0x3d	; 61
    34e8:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    34ea:	19 82       	std	Y+1, r1	; 0x01
    34ec:	13 c0       	rjmp	.+38     	; 0x3514 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    34ee:	89 81       	ldd	r24, Y+1	; 0x01
    34f0:	28 2f       	mov	r18, r24
    34f2:	30 e0       	ldi	r19, 0x00	; 0
    34f4:	c9 01       	movw	r24, r18
    34f6:	88 0f       	add	r24, r24
    34f8:	99 1f       	adc	r25, r25
    34fa:	88 0f       	add	r24, r24
    34fc:	99 1f       	adc	r25, r25
    34fe:	88 0f       	add	r24, r24
    3500:	99 1f       	adc	r25, r25
    3502:	82 0f       	add	r24, r18
    3504:	93 1f       	adc	r25, r19
    3506:	86 54       	subi	r24, 0x46	; 70
    3508:	99 4f       	sbci	r25, 0xF9	; 249
    350a:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    350e:	89 81       	ldd	r24, Y+1	; 0x01
    3510:	8f 5f       	subi	r24, 0xFF	; 255
    3512:	89 83       	std	Y+1, r24	; 0x01
    3514:	89 81       	ldd	r24, Y+1	; 0x01
    3516:	84 30       	cpi	r24, 0x04	; 4
    3518:	50 f3       	brcs	.-44     	; 0x34ee <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    351a:	8e ed       	ldi	r24, 0xDE	; 222
    351c:	96 e0       	ldi	r25, 0x06	; 6
    351e:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3522:	87 ee       	ldi	r24, 0xE7	; 231
    3524:	96 e0       	ldi	r25, 0x06	; 6
    3526:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    352a:	84 ef       	ldi	r24, 0xF4	; 244
    352c:	96 e0       	ldi	r25, 0x06	; 6
    352e:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3532:	8d ef       	ldi	r24, 0xFD	; 253
    3534:	96 e0       	ldi	r25, 0x06	; 6
    3536:	0e 94 99 08 	call	0x1132	; 0x1132 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    353a:	8e ed       	ldi	r24, 0xDE	; 222
    353c:	96 e0       	ldi	r25, 0x06	; 6
    353e:	90 93 f1 06 	sts	0x06F1, r25
    3542:	80 93 f0 06 	sts	0x06F0, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3546:	87 ee       	ldi	r24, 0xE7	; 231
    3548:	96 e0       	ldi	r25, 0x06	; 6
    354a:	90 93 f3 06 	sts	0x06F3, r25
    354e:	80 93 f2 06 	sts	0x06F2, r24
}
    3552:	0f 90       	pop	r0
    3554:	cf 91       	pop	r28
    3556:	df 91       	pop	r29
    3558:	08 95       	ret

0000355a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    355a:	df 93       	push	r29
    355c:	cf 93       	push	r28
    355e:	00 d0       	rcall	.+0      	; 0x3560 <prvCheckTasksWaitingTermination+0x6>
    3560:	0f 92       	push	r0
    3562:	cd b7       	in	r28, 0x3d	; 61
    3564:	de b7       	in	r29, 0x3e	; 62
    3566:	2e c0       	rjmp	.+92     	; 0x35c4 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    3568:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    356c:	80 91 fd 06 	lds	r24, 0x06FD
    3570:	1b 82       	std	Y+3, r1	; 0x03
    3572:	88 23       	and	r24, r24
    3574:	11 f4       	brne	.+4      	; 0x357a <prvCheckTasksWaitingTermination+0x20>
    3576:	81 e0       	ldi	r24, 0x01	; 1
    3578:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    357a:	0e 94 10 16 	call	0x2c20	; 0x2c20 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    357e:	8b 81       	ldd	r24, Y+3	; 0x03
    3580:	88 23       	and	r24, r24
    3582:	01 f5       	brne	.+64     	; 0x35c4 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    3584:	0f b6       	in	r0, 0x3f	; 63
    3586:	f8 94       	cli
    3588:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    358a:	e0 91 02 07 	lds	r30, 0x0702
    358e:	f0 91 03 07 	lds	r31, 0x0703
    3592:	86 81       	ldd	r24, Z+6	; 0x06
    3594:	97 81       	ldd	r25, Z+7	; 0x07
    3596:	9a 83       	std	Y+2, r25	; 0x02
    3598:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    359a:	89 81       	ldd	r24, Y+1	; 0x01
    359c:	9a 81       	ldd	r25, Y+2	; 0x02
    359e:	02 96       	adiw	r24, 0x02	; 2
    35a0:	0e 94 83 09 	call	0x1306	; 0x1306 <uxListRemove>
					--uxCurrentNumberOfTasks;
    35a4:	80 91 b0 06 	lds	r24, 0x06B0
    35a8:	81 50       	subi	r24, 0x01	; 1
    35aa:	80 93 b0 06 	sts	0x06B0, r24
					--uxTasksDeleted;
    35ae:	80 91 af 06 	lds	r24, 0x06AF
    35b2:	81 50       	subi	r24, 0x01	; 1
    35b4:	80 93 af 06 	sts	0x06AF, r24
				}
				taskEXIT_CRITICAL();
    35b8:	0f 90       	pop	r0
    35ba:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    35bc:	89 81       	ldd	r24, Y+1	; 0x01
    35be:	9a 81       	ldd	r25, Y+2	; 0x02
    35c0:	0e 94 79 1b 	call	0x36f2	; 0x36f2 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    35c4:	80 91 af 06 	lds	r24, 0x06AF
    35c8:	88 23       	and	r24, r24
    35ca:	71 f6       	brne	.-100    	; 0x3568 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    35cc:	0f 90       	pop	r0
    35ce:	0f 90       	pop	r0
    35d0:	0f 90       	pop	r0
    35d2:	cf 91       	pop	r28
    35d4:	df 91       	pop	r29
    35d6:	08 95       	ret

000035d8 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    35d8:	df 93       	push	r29
    35da:	cf 93       	push	r28
    35dc:	00 d0       	rcall	.+0      	; 0x35de <prvAddCurrentTaskToDelayedList+0x6>
    35de:	cd b7       	in	r28, 0x3d	; 61
    35e0:	de b7       	in	r29, 0x3e	; 62
    35e2:	9a 83       	std	Y+2, r25	; 0x02
    35e4:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    35e6:	e0 91 ad 06 	lds	r30, 0x06AD
    35ea:	f0 91 ae 06 	lds	r31, 0x06AE
    35ee:	89 81       	ldd	r24, Y+1	; 0x01
    35f0:	9a 81       	ldd	r25, Y+2	; 0x02
    35f2:	93 83       	std	Z+3, r25	; 0x03
    35f4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    35f6:	20 91 b1 06 	lds	r18, 0x06B1
    35fa:	30 91 b2 06 	lds	r19, 0x06B2
    35fe:	89 81       	ldd	r24, Y+1	; 0x01
    3600:	9a 81       	ldd	r25, Y+2	; 0x02
    3602:	82 17       	cp	r24, r18
    3604:	93 07       	cpc	r25, r19
    3606:	70 f4       	brcc	.+28     	; 0x3624 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3608:	80 91 f2 06 	lds	r24, 0x06F2
    360c:	90 91 f3 06 	lds	r25, 0x06F3
    3610:	20 91 ad 06 	lds	r18, 0x06AD
    3614:	30 91 ae 06 	lds	r19, 0x06AE
    3618:	2e 5f       	subi	r18, 0xFE	; 254
    361a:	3f 4f       	sbci	r19, 0xFF	; 255
    361c:	b9 01       	movw	r22, r18
    361e:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>
    3622:	1e c0       	rjmp	.+60     	; 0x3660 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3624:	40 91 f0 06 	lds	r20, 0x06F0
    3628:	50 91 f1 06 	lds	r21, 0x06F1
    362c:	80 91 ad 06 	lds	r24, 0x06AD
    3630:	90 91 ae 06 	lds	r25, 0x06AE
    3634:	9c 01       	movw	r18, r24
    3636:	2e 5f       	subi	r18, 0xFE	; 254
    3638:	3f 4f       	sbci	r19, 0xFF	; 255
    363a:	ca 01       	movw	r24, r20
    363c:	b9 01       	movw	r22, r18
    363e:	0e 94 17 09 	call	0x122e	; 0x122e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3642:	20 91 8c 00 	lds	r18, 0x008C
    3646:	30 91 8d 00 	lds	r19, 0x008D
    364a:	89 81       	ldd	r24, Y+1	; 0x01
    364c:	9a 81       	ldd	r25, Y+2	; 0x02
    364e:	82 17       	cp	r24, r18
    3650:	93 07       	cpc	r25, r19
    3652:	30 f4       	brcc	.+12     	; 0x3660 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3654:	89 81       	ldd	r24, Y+1	; 0x01
    3656:	9a 81       	ldd	r25, Y+2	; 0x02
    3658:	90 93 8d 00 	sts	0x008D, r25
    365c:	80 93 8c 00 	sts	0x008C, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    3660:	0f 90       	pop	r0
    3662:	0f 90       	pop	r0
    3664:	cf 91       	pop	r28
    3666:	df 91       	pop	r29
    3668:	08 95       	ret

0000366a <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    366a:	df 93       	push	r29
    366c:	cf 93       	push	r28
    366e:	cd b7       	in	r28, 0x3d	; 61
    3670:	de b7       	in	r29, 0x3e	; 62
    3672:	28 97       	sbiw	r28, 0x08	; 8
    3674:	0f b6       	in	r0, 0x3f	; 63
    3676:	f8 94       	cli
    3678:	de bf       	out	0x3e, r29	; 62
    367a:	0f be       	out	0x3f, r0	; 63
    367c:	cd bf       	out	0x3d, r28	; 61
    367e:	9c 83       	std	Y+4, r25	; 0x04
    3680:	8b 83       	std	Y+3, r24	; 0x03
    3682:	7e 83       	std	Y+6, r23	; 0x06
    3684:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    3686:	8d e2       	ldi	r24, 0x2D	; 45
    3688:	90 e0       	ldi	r25, 0x00	; 0
    368a:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    368e:	9a 83       	std	Y+2, r25	; 0x02
    3690:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3692:	89 81       	ldd	r24, Y+1	; 0x01
    3694:	9a 81       	ldd	r25, Y+2	; 0x02
    3696:	00 97       	sbiw	r24, 0x00	; 0
    3698:	09 f1       	breq	.+66     	; 0x36dc <prvAllocateTCBAndStack+0x72>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    369a:	8d 81       	ldd	r24, Y+5	; 0x05
    369c:	9e 81       	ldd	r25, Y+6	; 0x06
    369e:	00 97       	sbiw	r24, 0x00	; 0
    36a0:	39 f4       	brne	.+14     	; 0x36b0 <prvAllocateTCBAndStack+0x46>
    36a2:	8b 81       	ldd	r24, Y+3	; 0x03
    36a4:	9c 81       	ldd	r25, Y+4	; 0x04
    36a6:	0e 94 4b 07 	call	0xe96	; 0xe96 <pvPortMalloc>
    36aa:	98 87       	std	Y+8, r25	; 0x08
    36ac:	8f 83       	std	Y+7, r24	; 0x07
    36ae:	04 c0       	rjmp	.+8      	; 0x36b8 <prvAllocateTCBAndStack+0x4e>
    36b0:	8d 81       	ldd	r24, Y+5	; 0x05
    36b2:	9e 81       	ldd	r25, Y+6	; 0x06
    36b4:	98 87       	std	Y+8, r25	; 0x08
    36b6:	8f 83       	std	Y+7, r24	; 0x07
    36b8:	e9 81       	ldd	r30, Y+1	; 0x01
    36ba:	fa 81       	ldd	r31, Y+2	; 0x02
    36bc:	8f 81       	ldd	r24, Y+7	; 0x07
    36be:	98 85       	ldd	r25, Y+8	; 0x08
    36c0:	90 8f       	std	Z+24, r25	; 0x18
    36c2:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    36c4:	e9 81       	ldd	r30, Y+1	; 0x01
    36c6:	fa 81       	ldd	r31, Y+2	; 0x02
    36c8:	87 89       	ldd	r24, Z+23	; 0x17
    36ca:	90 8d       	ldd	r25, Z+24	; 0x18
    36cc:	00 97       	sbiw	r24, 0x00	; 0
    36ce:	31 f4       	brne	.+12     	; 0x36dc <prvAllocateTCBAndStack+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    36d0:	89 81       	ldd	r24, Y+1	; 0x01
    36d2:	9a 81       	ldd	r25, Y+2	; 0x02
    36d4:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
			pxNewTCB = NULL;
    36d8:	1a 82       	std	Y+2, r1	; 0x02
    36da:	19 82       	std	Y+1, r1	; 0x01
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    36dc:	89 81       	ldd	r24, Y+1	; 0x01
    36de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    36e0:	28 96       	adiw	r28, 0x08	; 8
    36e2:	0f b6       	in	r0, 0x3f	; 63
    36e4:	f8 94       	cli
    36e6:	de bf       	out	0x3e, r29	; 62
    36e8:	0f be       	out	0x3f, r0	; 63
    36ea:	cd bf       	out	0x3d, r28	; 61
    36ec:	cf 91       	pop	r28
    36ee:	df 91       	pop	r29
    36f0:	08 95       	ret

000036f2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    36f2:	df 93       	push	r29
    36f4:	cf 93       	push	r28
    36f6:	00 d0       	rcall	.+0      	; 0x36f8 <prvDeleteTCB+0x6>
    36f8:	cd b7       	in	r28, 0x3d	; 61
    36fa:	de b7       	in	r29, 0x3e	; 62
    36fc:	9a 83       	std	Y+2, r25	; 0x02
    36fe:	89 83       	std	Y+1, r24	; 0x01
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    3700:	e9 81       	ldd	r30, Y+1	; 0x01
    3702:	fa 81       	ldd	r31, Y+2	; 0x02
    3704:	87 89       	ldd	r24, Z+23	; 0x17
    3706:	90 8d       	ldd	r25, Z+24	; 0x18
    3708:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
		vPortFree( pxTCB );
    370c:	89 81       	ldd	r24, Y+1	; 0x01
    370e:	9a 81       	ldd	r25, Y+2	; 0x02
    3710:	0e 94 a1 07 	call	0xf42	; 0xf42 <vPortFree>
	}
    3714:	0f 90       	pop	r0
    3716:	0f 90       	pop	r0
    3718:	cf 91       	pop	r28
    371a:	df 91       	pop	r29
    371c:	08 95       	ret

0000371e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    371e:	df 93       	push	r29
    3720:	cf 93       	push	r28
    3722:	00 d0       	rcall	.+0      	; 0x3724 <prvResetNextTaskUnblockTime+0x6>
    3724:	cd b7       	in	r28, 0x3d	; 61
    3726:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3728:	e0 91 f0 06 	lds	r30, 0x06F0
    372c:	f0 91 f1 06 	lds	r31, 0x06F1
    3730:	80 81       	ld	r24, Z
    3732:	88 23       	and	r24, r24
    3734:	39 f4       	brne	.+14     	; 0x3744 <prvResetNextTaskUnblockTime+0x26>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3736:	8f ef       	ldi	r24, 0xFF	; 255
    3738:	9f ef       	ldi	r25, 0xFF	; 255
    373a:	90 93 8d 00 	sts	0x008D, r25
    373e:	80 93 8c 00 	sts	0x008C, r24
    3742:	13 c0       	rjmp	.+38     	; 0x376a <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3744:	e0 91 f0 06 	lds	r30, 0x06F0
    3748:	f0 91 f1 06 	lds	r31, 0x06F1
    374c:	05 80       	ldd	r0, Z+5	; 0x05
    374e:	f6 81       	ldd	r31, Z+6	; 0x06
    3750:	e0 2d       	mov	r30, r0
    3752:	86 81       	ldd	r24, Z+6	; 0x06
    3754:	97 81       	ldd	r25, Z+7	; 0x07
    3756:	9a 83       	std	Y+2, r25	; 0x02
    3758:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    375a:	e9 81       	ldd	r30, Y+1	; 0x01
    375c:	fa 81       	ldd	r31, Y+2	; 0x02
    375e:	82 81       	ldd	r24, Z+2	; 0x02
    3760:	93 81       	ldd	r25, Z+3	; 0x03
    3762:	90 93 8d 00 	sts	0x008D, r25
    3766:	80 93 8c 00 	sts	0x008C, r24
	}
}
    376a:	0f 90       	pop	r0
    376c:	0f 90       	pop	r0
    376e:	cf 91       	pop	r28
    3770:	df 91       	pop	r29
    3772:	08 95       	ret

00003774 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3774:	df 93       	push	r29
    3776:	cf 93       	push	r28
    3778:	00 d0       	rcall	.+0      	; 0x377a <uxTaskResetEventItemValue+0x6>
    377a:	cd b7       	in	r28, 0x3d	; 61
    377c:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    377e:	e0 91 ad 06 	lds	r30, 0x06AD
    3782:	f0 91 ae 06 	lds	r31, 0x06AE
    3786:	84 85       	ldd	r24, Z+12	; 0x0c
    3788:	95 85       	ldd	r25, Z+13	; 0x0d
    378a:	9a 83       	std	Y+2, r25	; 0x02
    378c:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    378e:	a0 91 ad 06 	lds	r26, 0x06AD
    3792:	b0 91 ae 06 	lds	r27, 0x06AE
    3796:	e0 91 ad 06 	lds	r30, 0x06AD
    379a:	f0 91 ae 06 	lds	r31, 0x06AE
    379e:	86 89       	ldd	r24, Z+22	; 0x16
    37a0:	28 2f       	mov	r18, r24
    37a2:	30 e0       	ldi	r19, 0x00	; 0
    37a4:	84 e0       	ldi	r24, 0x04	; 4
    37a6:	90 e0       	ldi	r25, 0x00	; 0
    37a8:	82 1b       	sub	r24, r18
    37aa:	93 0b       	sbc	r25, r19
    37ac:	1d 96       	adiw	r26, 0x0d	; 13
    37ae:	9c 93       	st	X, r25
    37b0:	8e 93       	st	-X, r24
    37b2:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    37b4:	89 81       	ldd	r24, Y+1	; 0x01
    37b6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    37b8:	0f 90       	pop	r0
    37ba:	0f 90       	pop	r0
    37bc:	cf 91       	pop	r28
    37be:	df 91       	pop	r29
    37c0:	08 95       	ret

000037c2 <main>:

/* Declare */
QueueHandle_t	mqTerm;


int main(){
    37c2:	af 92       	push	r10
    37c4:	bf 92       	push	r11
    37c6:	cf 92       	push	r12
    37c8:	df 92       	push	r13
    37ca:	ef 92       	push	r14
    37cc:	ff 92       	push	r15
    37ce:	0f 93       	push	r16
    37d0:	df 93       	push	r29
    37d2:	cf 93       	push	r28
    37d4:	cd b7       	in	r28, 0x3d	; 61
    37d6:	de b7       	in	r29, 0x3e	; 62
	/* init pr. */
	system_init();
    37d8:	0e 94 56 1c 	call	0x38ac	; 0x38ac <system_init>
	mqTerm = xQueueCreate(10,1);
    37dc:	8a e0       	ldi	r24, 0x0A	; 10
    37de:	61 e0       	ldi	r22, 0x01	; 1
    37e0:	40 e0       	ldi	r20, 0x00	; 0
    37e2:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <xQueueGenericCreate>
    37e6:	90 93 07 07 	sts	0x0707, r25
    37ea:	80 93 06 07 	sts	0x0706, r24
	/* Create Tasks */
	xTaskCreate(T_T1, NULL, 100, NULL, 1, NULL);
    37ee:	8c e1       	ldi	r24, 0x1C	; 28
    37f0:	9c e1       	ldi	r25, 0x1C	; 28
    37f2:	60 e0       	ldi	r22, 0x00	; 0
    37f4:	70 e0       	ldi	r23, 0x00	; 0
    37f6:	44 e6       	ldi	r20, 0x64	; 100
    37f8:	50 e0       	ldi	r21, 0x00	; 0
    37fa:	20 e0       	ldi	r18, 0x00	; 0
    37fc:	30 e0       	ldi	r19, 0x00	; 0
    37fe:	01 e0       	ldi	r16, 0x01	; 1
    3800:	ee 24       	eor	r14, r14
    3802:	ff 24       	eor	r15, r15
    3804:	cc 24       	eor	r12, r12
    3806:	dd 24       	eor	r13, r13
    3808:	aa 24       	eor	r10, r10
    380a:	bb 24       	eor	r11, r11
    380c:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <xTaskGenericCreate>
	xTaskCreate(T_T2, NULL, 100, NULL, 2, NULL);
    3810:	86 e3       	ldi	r24, 0x36	; 54
    3812:	9c e1       	ldi	r25, 0x1C	; 28
    3814:	60 e0       	ldi	r22, 0x00	; 0
    3816:	70 e0       	ldi	r23, 0x00	; 0
    3818:	44 e6       	ldi	r20, 0x64	; 100
    381a:	50 e0       	ldi	r21, 0x00	; 0
    381c:	20 e0       	ldi	r18, 0x00	; 0
    381e:	30 e0       	ldi	r19, 0x00	; 0
    3820:	02 e0       	ldi	r16, 0x02	; 2
    3822:	ee 24       	eor	r14, r14
    3824:	ff 24       	eor	r15, r15
    3826:	cc 24       	eor	r12, r12
    3828:	dd 24       	eor	r13, r13
    382a:	aa 24       	eor	r10, r10
    382c:	bb 24       	eor	r11, r11
    382e:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <xTaskGenericCreate>
	/* Start RTOS */
	vTaskStartScheduler();
    3832:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vTaskStartScheduler>
    3836:	ff cf       	rjmp	.-2      	; 0x3836 <main+0x74>

00003838 <T_T1>:
	while(1);
	return 0;
}
void T_T1(void* pvParam){
    3838:	df 93       	push	r29
    383a:	cf 93       	push	r28
    383c:	00 d0       	rcall	.+0      	; 0x383e <T_T1+0x6>
    383e:	0f 92       	push	r0
    3840:	cd b7       	in	r28, 0x3d	; 61
    3842:	de b7       	in	r29, 0x3e	; 62
    3844:	9b 83       	std	Y+3, r25	; 0x03
    3846:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char data = 0;
    3848:	19 82       	std	Y+1, r1	; 0x01
	while(1){
		data = usart_getc();
    384a:	0e 94 b3 1c 	call	0x3966	; 0x3966 <usart_getc>
    384e:	89 83       	std	Y+1, r24	; 0x01
		xQueueSend(mqTerm, &data, portMAX_DELAY);
    3850:	80 91 06 07 	lds	r24, 0x0706
    3854:	90 91 07 07 	lds	r25, 0x0707
    3858:	9e 01       	movw	r18, r28
    385a:	2f 5f       	subi	r18, 0xFF	; 255
    385c:	3f 4f       	sbci	r19, 0xFF	; 255
    385e:	b9 01       	movw	r22, r18
    3860:	4f ef       	ldi	r20, 0xFF	; 255
    3862:	5f ef       	ldi	r21, 0xFF	; 255
    3864:	20 e0       	ldi	r18, 0x00	; 0
    3866:	0e 94 a6 0d 	call	0x1b4c	; 0x1b4c <xQueueGenericSend>
    386a:	ef cf       	rjmp	.-34     	; 0x384a <T_T1+0x12>

0000386c <T_T2>:
	}
}
void T_T2(void* pvParam){
    386c:	df 93       	push	r29
    386e:	cf 93       	push	r28
    3870:	00 d0       	rcall	.+0      	; 0x3872 <T_T2+0x6>
    3872:	0f 92       	push	r0
    3874:	cd b7       	in	r28, 0x3d	; 61
    3876:	de b7       	in	r29, 0x3e	; 62
    3878:	9b 83       	std	Y+3, r25	; 0x03
    387a:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char rxData = 0;
    387c:	19 82       	std	Y+1, r1	; 0x01
	while(1){
		if(xQueueReceive(mqTerm,&rxData,portMAX_DELAY)){
    387e:	80 91 06 07 	lds	r24, 0x0706
    3882:	90 91 07 07 	lds	r25, 0x0707
    3886:	9e 01       	movw	r18, r28
    3888:	2f 5f       	subi	r18, 0xFF	; 255
    388a:	3f 4f       	sbci	r19, 0xFF	; 255
    388c:	b9 01       	movw	r22, r18
    388e:	4f ef       	ldi	r20, 0xFF	; 255
    3890:	5f ef       	ldi	r21, 0xFF	; 255
    3892:	20 e0       	ldi	r18, 0x00	; 0
    3894:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xQueueGenericReceive>
    3898:	88 23       	and	r24, r24
    389a:	89 f3       	breq	.-30     	; 0x387e <T_T2+0x12>
			vTaskDelay(2000);
    389c:	80 ed       	ldi	r24, 0xD0	; 208
    389e:	97 e0       	ldi	r25, 0x07	; 7
    38a0:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <vTaskDelay>
			usart_putc(rxData);
    38a4:	89 81       	ldd	r24, Y+1	; 0x01
    38a6:	0e 94 c2 1c 	call	0x3984	; 0x3984 <usart_putc>
    38aa:	e9 cf       	rjmp	.-46     	; 0x387e <T_T2+0x12>

000038ac <system_init>:
		}

	}
}

void system_init(void){
    38ac:	df 93       	push	r29
    38ae:	cf 93       	push	r28
    38b0:	cd b7       	in	r28, 0x3d	; 61
    38b2:	de b7       	in	r29, 0x3e	; 62
	DDRA = 0xFF;
    38b4:	ea e3       	ldi	r30, 0x3A	; 58
    38b6:	f0 e0       	ldi	r31, 0x00	; 0
    38b8:	8f ef       	ldi	r24, 0xFF	; 255
    38ba:	80 83       	st	Z, r24
	DDRC = 0xFF;
    38bc:	e4 e3       	ldi	r30, 0x34	; 52
    38be:	f0 e0       	ldi	r31, 0x00	; 0
    38c0:	8f ef       	ldi	r24, 0xFF	; 255
    38c2:	80 83       	st	Z, r24
	usart_init(9600);
    38c4:	80 e8       	ldi	r24, 0x80	; 128
    38c6:	95 e2       	ldi	r25, 0x25	; 37
    38c8:	0e 94 6d 1c 	call	0x38da	; 0x38da <usart_init>
	usart_puts("Started ... \r\n");
    38cc:	8d e7       	ldi	r24, 0x7D	; 125
    38ce:	90 e0       	ldi	r25, 0x00	; 0
    38d0:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <usart_puts>
}
    38d4:	cf 91       	pop	r28
    38d6:	df 91       	pop	r29
    38d8:	08 95       	ret

000038da <usart_init>:
#include <avr/io.h>
#include "usart_driver.h"

void usart_init(unsigned short int baudrate)
{
    38da:	df 93       	push	r29
    38dc:	cf 93       	push	r28
    38de:	00 d0       	rcall	.+0      	; 0x38e0 <usart_init+0x6>
    38e0:	00 d0       	rcall	.+0      	; 0x38e2 <usart_init+0x8>
    38e2:	cd b7       	in	r28, 0x3d	; 61
    38e4:	de b7       	in	r29, 0x3e	; 62
    38e6:	9c 83       	std	Y+4, r25	; 0x04
    38e8:	8b 83       	std	Y+3, r24	; 0x03
	//Set baud rate
	unsigned short int UBRRVAL=(FCLK_SYSTEM/(baudrate*16UL))-1;
    38ea:	8b 81       	ldd	r24, Y+3	; 0x03
    38ec:	9c 81       	ldd	r25, Y+4	; 0x04
    38ee:	cc 01       	movw	r24, r24
    38f0:	a0 e0       	ldi	r26, 0x00	; 0
    38f2:	b0 e0       	ldi	r27, 0x00	; 0
    38f4:	88 0f       	add	r24, r24
    38f6:	99 1f       	adc	r25, r25
    38f8:	aa 1f       	adc	r26, r26
    38fa:	bb 1f       	adc	r27, r27
    38fc:	88 0f       	add	r24, r24
    38fe:	99 1f       	adc	r25, r25
    3900:	aa 1f       	adc	r26, r26
    3902:	bb 1f       	adc	r27, r27
    3904:	88 0f       	add	r24, r24
    3906:	99 1f       	adc	r25, r25
    3908:	aa 1f       	adc	r26, r26
    390a:	bb 1f       	adc	r27, r27
    390c:	88 0f       	add	r24, r24
    390e:	99 1f       	adc	r25, r25
    3910:	aa 1f       	adc	r26, r26
    3912:	bb 1f       	adc	r27, r27
    3914:	9c 01       	movw	r18, r24
    3916:	ad 01       	movw	r20, r26
    3918:	80 e0       	ldi	r24, 0x00	; 0
    391a:	92 e1       	ldi	r25, 0x12	; 18
    391c:	aa e7       	ldi	r26, 0x7A	; 122
    391e:	b0 e0       	ldi	r27, 0x00	; 0
    3920:	bc 01       	movw	r22, r24
    3922:	cd 01       	movw	r24, r26
    3924:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <__udivmodsi4>
    3928:	da 01       	movw	r26, r20
    392a:	c9 01       	movw	r24, r18
    392c:	01 97       	sbiw	r24, 0x01	; 1
    392e:	9a 83       	std	Y+2, r25	; 0x02
    3930:	89 83       	std	Y+1, r24	; 0x01
	UBRRL=UBRRVAL; 			//low byte
    3932:	e9 e2       	ldi	r30, 0x29	; 41
    3934:	f0 e0       	ldi	r31, 0x00	; 0
    3936:	89 81       	ldd	r24, Y+1	; 0x01
    3938:	80 83       	st	Z, r24
	UBRRH=(UBRRVAL>>8); 	//high byte
    393a:	e0 e4       	ldi	r30, 0x40	; 64
    393c:	f0 e0       	ldi	r31, 0x00	; 0
    393e:	89 81       	ldd	r24, Y+1	; 0x01
    3940:	9a 81       	ldd	r25, Y+2	; 0x02
    3942:	89 2f       	mov	r24, r25
    3944:	99 27       	eor	r25, r25
    3946:	80 83       	st	Z, r24

	//Set data frame format: asynchronous mode,no parity, 1 stop bit, 8 bit size
	UCSRC=(1<<URSEL)|(0<<UMSEL)|(0<<UPM1)|(0<<UPM0)|(0<<USBS)|(0<<UCSZ2)|(1<<UCSZ1)|(1<<UCSZ0); 
    3948:	e0 e4       	ldi	r30, 0x40	; 64
    394a:	f0 e0       	ldi	r31, 0x00	; 0
    394c:	86 e8       	ldi	r24, 0x86	; 134
    394e:	80 83       	st	Z, r24

	//Enable Transmitter and Receiver
	UCSRB=(1<<RXEN)|(1<<TXEN);
    3950:	ea e2       	ldi	r30, 0x2A	; 42
    3952:	f0 e0       	ldi	r31, 0x00	; 0
    3954:	88 e1       	ldi	r24, 0x18	; 24
    3956:	80 83       	st	Z, r24
}
    3958:	0f 90       	pop	r0
    395a:	0f 90       	pop	r0
    395c:	0f 90       	pop	r0
    395e:	0f 90       	pop	r0
    3960:	cf 91       	pop	r28
    3962:	df 91       	pop	r29
    3964:	08 95       	ret

00003966 <usart_getc>:
unsigned char usart_getc( void )
{
    3966:	df 93       	push	r29
    3968:	cf 93       	push	r28
    396a:	cd b7       	in	r28, 0x3d	; 61
    396c:	de b7       	in	r29, 0x3e	; 62
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
    396e:	eb e2       	ldi	r30, 0x2B	; 43
    3970:	f0 e0       	ldi	r31, 0x00	; 0
    3972:	80 81       	ld	r24, Z
    3974:	88 23       	and	r24, r24
    3976:	dc f7       	brge	.-10     	; 0x396e <usart_getc+0x8>
	/* Get and return received data from buffer */
	return UDR;
    3978:	ec e2       	ldi	r30, 0x2C	; 44
    397a:	f0 e0       	ldi	r31, 0x00	; 0
    397c:	80 81       	ld	r24, Z
}
    397e:	cf 91       	pop	r28
    3980:	df 91       	pop	r29
    3982:	08 95       	ret

00003984 <usart_putc>:
void usart_putc( unsigned char data )
{
    3984:	df 93       	push	r29
    3986:	cf 93       	push	r28
    3988:	0f 92       	push	r0
    398a:	cd b7       	in	r28, 0x3d	; 61
    398c:	de b7       	in	r29, 0x3e	; 62
    398e:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)));
    3990:	eb e2       	ldi	r30, 0x2B	; 43
    3992:	f0 e0       	ldi	r31, 0x00	; 0
    3994:	80 81       	ld	r24, Z
    3996:	88 2f       	mov	r24, r24
    3998:	90 e0       	ldi	r25, 0x00	; 0
    399a:	80 72       	andi	r24, 0x20	; 32
    399c:	90 70       	andi	r25, 0x00	; 0
    399e:	00 97       	sbiw	r24, 0x00	; 0
    39a0:	b9 f3       	breq	.-18     	; 0x3990 <usart_putc+0xc>
	/* Put data into buffer, sends the data */
	UDR = data;
    39a2:	ec e2       	ldi	r30, 0x2C	; 44
    39a4:	f0 e0       	ldi	r31, 0x00	; 0
    39a6:	89 81       	ldd	r24, Y+1	; 0x01
    39a8:	80 83       	st	Z, r24
}
    39aa:	0f 90       	pop	r0
    39ac:	cf 91       	pop	r28
    39ae:	df 91       	pop	r29
    39b0:	08 95       	ret

000039b2 <usart_puts>:
void usart_puts( char* str )
{
    39b2:	df 93       	push	r29
    39b4:	cf 93       	push	r28
    39b6:	00 d0       	rcall	.+0      	; 0x39b8 <usart_puts+0x6>
    39b8:	00 d0       	rcall	.+0      	; 0x39ba <usart_puts+0x8>
    39ba:	cd b7       	in	r28, 0x3d	; 61
    39bc:	de b7       	in	r29, 0x3e	; 62
    39be:	9c 83       	std	Y+4, r25	; 0x04
    39c0:	8b 83       	std	Y+3, r24	; 0x03
	short int i=0;
    39c2:	1a 82       	std	Y+2, r1	; 0x02
    39c4:	19 82       	std	Y+1, r1	; 0x01
    39c6:	0f c0       	rjmp	.+30     	; 0x39e6 <usart_puts+0x34>
	while(str[i])
	{
		usart_putc(str[i]);
    39c8:	29 81       	ldd	r18, Y+1	; 0x01
    39ca:	3a 81       	ldd	r19, Y+2	; 0x02
    39cc:	8b 81       	ldd	r24, Y+3	; 0x03
    39ce:	9c 81       	ldd	r25, Y+4	; 0x04
    39d0:	fc 01       	movw	r30, r24
    39d2:	e2 0f       	add	r30, r18
    39d4:	f3 1f       	adc	r31, r19
    39d6:	80 81       	ld	r24, Z
    39d8:	0e 94 c2 1c 	call	0x3984	; 0x3984 <usart_putc>
		i++;
    39dc:	89 81       	ldd	r24, Y+1	; 0x01
    39de:	9a 81       	ldd	r25, Y+2	; 0x02
    39e0:	01 96       	adiw	r24, 0x01	; 1
    39e2:	9a 83       	std	Y+2, r25	; 0x02
    39e4:	89 83       	std	Y+1, r24	; 0x01
	UDR = data;
}
void usart_puts( char* str )
{
	short int i=0;
	while(str[i])
    39e6:	29 81       	ldd	r18, Y+1	; 0x01
    39e8:	3a 81       	ldd	r19, Y+2	; 0x02
    39ea:	8b 81       	ldd	r24, Y+3	; 0x03
    39ec:	9c 81       	ldd	r25, Y+4	; 0x04
    39ee:	fc 01       	movw	r30, r24
    39f0:	e2 0f       	add	r30, r18
    39f2:	f3 1f       	adc	r31, r19
    39f4:	80 81       	ld	r24, Z
    39f6:	88 23       	and	r24, r24
    39f8:	39 f7       	brne	.-50     	; 0x39c8 <usart_puts+0x16>
	{
		usart_putc(str[i]);
		i++;
	}
}
    39fa:	0f 90       	pop	r0
    39fc:	0f 90       	pop	r0
    39fe:	0f 90       	pop	r0
    3a00:	0f 90       	pop	r0
    3a02:	cf 91       	pop	r28
    3a04:	df 91       	pop	r29
    3a06:	08 95       	ret

00003a08 <__mulsi3>:
    3a08:	62 9f       	mul	r22, r18
    3a0a:	d0 01       	movw	r26, r0
    3a0c:	73 9f       	mul	r23, r19
    3a0e:	f0 01       	movw	r30, r0
    3a10:	82 9f       	mul	r24, r18
    3a12:	e0 0d       	add	r30, r0
    3a14:	f1 1d       	adc	r31, r1
    3a16:	64 9f       	mul	r22, r20
    3a18:	e0 0d       	add	r30, r0
    3a1a:	f1 1d       	adc	r31, r1
    3a1c:	92 9f       	mul	r25, r18
    3a1e:	f0 0d       	add	r31, r0
    3a20:	83 9f       	mul	r24, r19
    3a22:	f0 0d       	add	r31, r0
    3a24:	74 9f       	mul	r23, r20
    3a26:	f0 0d       	add	r31, r0
    3a28:	65 9f       	mul	r22, r21
    3a2a:	f0 0d       	add	r31, r0
    3a2c:	99 27       	eor	r25, r25
    3a2e:	72 9f       	mul	r23, r18
    3a30:	b0 0d       	add	r27, r0
    3a32:	e1 1d       	adc	r30, r1
    3a34:	f9 1f       	adc	r31, r25
    3a36:	63 9f       	mul	r22, r19
    3a38:	b0 0d       	add	r27, r0
    3a3a:	e1 1d       	adc	r30, r1
    3a3c:	f9 1f       	adc	r31, r25
    3a3e:	bd 01       	movw	r22, r26
    3a40:	cf 01       	movw	r24, r30
    3a42:	11 24       	eor	r1, r1
    3a44:	08 95       	ret

00003a46 <__udivmodsi4>:
    3a46:	a1 e2       	ldi	r26, 0x21	; 33
    3a48:	1a 2e       	mov	r1, r26
    3a4a:	aa 1b       	sub	r26, r26
    3a4c:	bb 1b       	sub	r27, r27
    3a4e:	fd 01       	movw	r30, r26
    3a50:	0d c0       	rjmp	.+26     	; 0x3a6c <__udivmodsi4_ep>

00003a52 <__udivmodsi4_loop>:
    3a52:	aa 1f       	adc	r26, r26
    3a54:	bb 1f       	adc	r27, r27
    3a56:	ee 1f       	adc	r30, r30
    3a58:	ff 1f       	adc	r31, r31
    3a5a:	a2 17       	cp	r26, r18
    3a5c:	b3 07       	cpc	r27, r19
    3a5e:	e4 07       	cpc	r30, r20
    3a60:	f5 07       	cpc	r31, r21
    3a62:	20 f0       	brcs	.+8      	; 0x3a6c <__udivmodsi4_ep>
    3a64:	a2 1b       	sub	r26, r18
    3a66:	b3 0b       	sbc	r27, r19
    3a68:	e4 0b       	sbc	r30, r20
    3a6a:	f5 0b       	sbc	r31, r21

00003a6c <__udivmodsi4_ep>:
    3a6c:	66 1f       	adc	r22, r22
    3a6e:	77 1f       	adc	r23, r23
    3a70:	88 1f       	adc	r24, r24
    3a72:	99 1f       	adc	r25, r25
    3a74:	1a 94       	dec	r1
    3a76:	69 f7       	brne	.-38     	; 0x3a52 <__udivmodsi4_loop>
    3a78:	60 95       	com	r22
    3a7a:	70 95       	com	r23
    3a7c:	80 95       	com	r24
    3a7e:	90 95       	com	r25
    3a80:	9b 01       	movw	r18, r22
    3a82:	ac 01       	movw	r20, r24
    3a84:	bd 01       	movw	r22, r26
    3a86:	cf 01       	movw	r24, r30
    3a88:	08 95       	ret

00003a8a <__divmodsi4>:
    3a8a:	97 fb       	bst	r25, 7
    3a8c:	09 2e       	mov	r0, r25
    3a8e:	05 26       	eor	r0, r21
    3a90:	0e d0       	rcall	.+28     	; 0x3aae <__divmodsi4_neg1>
    3a92:	57 fd       	sbrc	r21, 7
    3a94:	04 d0       	rcall	.+8      	; 0x3a9e <__divmodsi4_neg2>
    3a96:	d7 df       	rcall	.-82     	; 0x3a46 <__udivmodsi4>
    3a98:	0a d0       	rcall	.+20     	; 0x3aae <__divmodsi4_neg1>
    3a9a:	00 1c       	adc	r0, r0
    3a9c:	38 f4       	brcc	.+14     	; 0x3aac <__divmodsi4_exit>

00003a9e <__divmodsi4_neg2>:
    3a9e:	50 95       	com	r21
    3aa0:	40 95       	com	r20
    3aa2:	30 95       	com	r19
    3aa4:	21 95       	neg	r18
    3aa6:	3f 4f       	sbci	r19, 0xFF	; 255
    3aa8:	4f 4f       	sbci	r20, 0xFF	; 255
    3aaa:	5f 4f       	sbci	r21, 0xFF	; 255

00003aac <__divmodsi4_exit>:
    3aac:	08 95       	ret

00003aae <__divmodsi4_neg1>:
    3aae:	f6 f7       	brtc	.-4      	; 0x3aac <__divmodsi4_exit>
    3ab0:	90 95       	com	r25
    3ab2:	80 95       	com	r24
    3ab4:	70 95       	com	r23
    3ab6:	61 95       	neg	r22
    3ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aba:	8f 4f       	sbci	r24, 0xFF	; 255
    3abc:	9f 4f       	sbci	r25, 0xFF	; 255
    3abe:	08 95       	ret

00003ac0 <memcpy>:
    3ac0:	fb 01       	movw	r30, r22
    3ac2:	dc 01       	movw	r26, r24
    3ac4:	02 c0       	rjmp	.+4      	; 0x3aca <memcpy+0xa>
    3ac6:	01 90       	ld	r0, Z+
    3ac8:	0d 92       	st	X+, r0
    3aca:	41 50       	subi	r20, 0x01	; 1
    3acc:	50 40       	sbci	r21, 0x00	; 0
    3ace:	d8 f7       	brcc	.-10     	; 0x3ac6 <memcpy+0x6>
    3ad0:	08 95       	ret

00003ad2 <_exit>:
    3ad2:	f8 94       	cli

00003ad4 <__stop_program>:
    3ad4:	ff cf       	rjmp	.-2      	; 0x3ad4 <__stop_program>
