
RTOS_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003c44  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001c8  00800060  00003c44  00003cd8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004ac  00800228  00800228  00003ea0  2**0
                  ALLOC
  3 .stab         000074c4  00000000  00000000  00003ea0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003b6c  00000000  00000000  0000b364  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000eed0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000195  00000000  00000000  0000f010  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001a89  00000000  00000000  0000f1a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ea8  00000000  00000000  00010c2e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000df9  00000000  00000000  00011ad6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000128d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002bc  00000000  00000000  00012a30  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000852  00000000  00000000  00012cec  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f3 0b 	jmp	0x17e6	; 0x17e6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 0c 15 	jmp	0x2a18	; 0x2a18 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e4       	ldi	r30, 0x44	; 68
      68:	fc e3       	ldi	r31, 0x3C	; 60
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 32       	cpi	r26, 0x28	; 40
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a8 e2       	ldi	r26, 0x28	; 40
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 3d       	cpi	r26, 0xD4	; 212
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e0 1c 	call	0x39c0	; 0x39c0 <main>
      8a:	0c 94 20 1e 	jmp	0x3c40	; 0x3c40 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 cb 02 	call	0x596	; 0x596 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 e0 1d 	jmp	0x3bc0	; 0x3bc0 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a3 e0       	ldi	r26, 0x03	; 3
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 fc 1d 	jmp	0x3bf8	; 0x3bf8 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 ec 1d 	jmp	0x3bd8	; 0x3bd8 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 08 1e 	jmp	0x3c10	; 0x3c10 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 ec 1d 	jmp	0x3bd8	; 0x3bd8 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 08 1e 	jmp	0x3c10	; 0x3c10 <__epilogue_restores__+0x18>

0000043e <__divsf3>:
     43e:	a8 e1       	ldi	r26, 0x18	; 24
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 e8 1d 	jmp	0x3bd0	; 0x3bd0 <__prologue_saves__+0x10>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	b9 e0       	ldi	r27, 0x09	; 9
     45c:	eb 2e       	mov	r14, r27
     45e:	f1 2c       	mov	r15, r1
     460:	ec 0e       	add	r14, r28
     462:	fd 1e       	adc	r15, r29
     464:	ce 01       	movw	r24, r28
     466:	01 96       	adiw	r24, 0x01	; 1
     468:	b7 01       	movw	r22, r14
     46a:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     46e:	8e 01       	movw	r16, r28
     470:	0f 5e       	subi	r16, 0xEF	; 239
     472:	1f 4f       	sbci	r17, 0xFF	; 255
     474:	ce 01       	movw	r24, r28
     476:	05 96       	adiw	r24, 0x05	; 5
     478:	b8 01       	movw	r22, r16
     47a:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     47e:	29 85       	ldd	r18, Y+9	; 0x09
     480:	22 30       	cpi	r18, 0x02	; 2
     482:	08 f4       	brcc	.+2      	; 0x486 <__divsf3+0x48>
     484:	7e c0       	rjmp	.+252    	; 0x582 <__divsf3+0x144>
     486:	39 89       	ldd	r19, Y+17	; 0x11
     488:	32 30       	cpi	r19, 0x02	; 2
     48a:	10 f4       	brcc	.+4      	; 0x490 <__divsf3+0x52>
     48c:	b8 01       	movw	r22, r16
     48e:	7c c0       	rjmp	.+248    	; 0x588 <__divsf3+0x14a>
     490:	8a 85       	ldd	r24, Y+10	; 0x0a
     492:	9a 89       	ldd	r25, Y+18	; 0x12
     494:	89 27       	eor	r24, r25
     496:	8a 87       	std	Y+10, r24	; 0x0a
     498:	24 30       	cpi	r18, 0x04	; 4
     49a:	11 f0       	breq	.+4      	; 0x4a0 <__divsf3+0x62>
     49c:	22 30       	cpi	r18, 0x02	; 2
     49e:	31 f4       	brne	.+12     	; 0x4ac <__divsf3+0x6e>
     4a0:	23 17       	cp	r18, r19
     4a2:	09 f0       	breq	.+2      	; 0x4a6 <__divsf3+0x68>
     4a4:	6e c0       	rjmp	.+220    	; 0x582 <__divsf3+0x144>
     4a6:	63 e0       	ldi	r22, 0x03	; 3
     4a8:	71 e0       	ldi	r23, 0x01	; 1
     4aa:	6e c0       	rjmp	.+220    	; 0x588 <__divsf3+0x14a>
     4ac:	34 30       	cpi	r19, 0x04	; 4
     4ae:	39 f4       	brne	.+14     	; 0x4be <__divsf3+0x80>
     4b0:	1d 86       	std	Y+13, r1	; 0x0d
     4b2:	1e 86       	std	Y+14, r1	; 0x0e
     4b4:	1f 86       	std	Y+15, r1	; 0x0f
     4b6:	18 8a       	std	Y+16, r1	; 0x10
     4b8:	1c 86       	std	Y+12, r1	; 0x0c
     4ba:	1b 86       	std	Y+11, r1	; 0x0b
     4bc:	04 c0       	rjmp	.+8      	; 0x4c6 <__divsf3+0x88>
     4be:	32 30       	cpi	r19, 0x02	; 2
     4c0:	21 f4       	brne	.+8      	; 0x4ca <__divsf3+0x8c>
     4c2:	84 e0       	ldi	r24, 0x04	; 4
     4c4:	89 87       	std	Y+9, r24	; 0x09
     4c6:	b7 01       	movw	r22, r14
     4c8:	5f c0       	rjmp	.+190    	; 0x588 <__divsf3+0x14a>
     4ca:	2b 85       	ldd	r18, Y+11	; 0x0b
     4cc:	3c 85       	ldd	r19, Y+12	; 0x0c
     4ce:	8b 89       	ldd	r24, Y+19	; 0x13
     4d0:	9c 89       	ldd	r25, Y+20	; 0x14
     4d2:	28 1b       	sub	r18, r24
     4d4:	39 0b       	sbc	r19, r25
     4d6:	3c 87       	std	Y+12, r19	; 0x0c
     4d8:	2b 87       	std	Y+11, r18	; 0x0b
     4da:	ed 84       	ldd	r14, Y+13	; 0x0d
     4dc:	fe 84       	ldd	r15, Y+14	; 0x0e
     4de:	0f 85       	ldd	r16, Y+15	; 0x0f
     4e0:	18 89       	ldd	r17, Y+16	; 0x10
     4e2:	ad 88       	ldd	r10, Y+21	; 0x15
     4e4:	be 88       	ldd	r11, Y+22	; 0x16
     4e6:	cf 88       	ldd	r12, Y+23	; 0x17
     4e8:	d8 8c       	ldd	r13, Y+24	; 0x18
     4ea:	ea 14       	cp	r14, r10
     4ec:	fb 04       	cpc	r15, r11
     4ee:	0c 05       	cpc	r16, r12
     4f0:	1d 05       	cpc	r17, r13
     4f2:	40 f4       	brcc	.+16     	; 0x504 <__divsf3+0xc6>
     4f4:	ee 0c       	add	r14, r14
     4f6:	ff 1c       	adc	r15, r15
     4f8:	00 1f       	adc	r16, r16
     4fa:	11 1f       	adc	r17, r17
     4fc:	21 50       	subi	r18, 0x01	; 1
     4fe:	30 40       	sbci	r19, 0x00	; 0
     500:	3c 87       	std	Y+12, r19	; 0x0c
     502:	2b 87       	std	Y+11, r18	; 0x0b
     504:	20 e0       	ldi	r18, 0x00	; 0
     506:	30 e0       	ldi	r19, 0x00	; 0
     508:	40 e0       	ldi	r20, 0x00	; 0
     50a:	50 e0       	ldi	r21, 0x00	; 0
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e4       	ldi	r27, 0x40	; 64
     514:	60 e0       	ldi	r22, 0x00	; 0
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	ea 14       	cp	r14, r10
     51a:	fb 04       	cpc	r15, r11
     51c:	0c 05       	cpc	r16, r12
     51e:	1d 05       	cpc	r17, r13
     520:	40 f0       	brcs	.+16     	; 0x532 <__divsf3+0xf4>
     522:	28 2b       	or	r18, r24
     524:	39 2b       	or	r19, r25
     526:	4a 2b       	or	r20, r26
     528:	5b 2b       	or	r21, r27
     52a:	ea 18       	sub	r14, r10
     52c:	fb 08       	sbc	r15, r11
     52e:	0c 09       	sbc	r16, r12
     530:	1d 09       	sbc	r17, r13
     532:	b6 95       	lsr	r27
     534:	a7 95       	ror	r26
     536:	97 95       	ror	r25
     538:	87 95       	ror	r24
     53a:	ee 0c       	add	r14, r14
     53c:	ff 1c       	adc	r15, r15
     53e:	00 1f       	adc	r16, r16
     540:	11 1f       	adc	r17, r17
     542:	6f 5f       	subi	r22, 0xFF	; 255
     544:	7f 4f       	sbci	r23, 0xFF	; 255
     546:	6f 31       	cpi	r22, 0x1F	; 31
     548:	71 05       	cpc	r23, r1
     54a:	31 f7       	brne	.-52     	; 0x518 <__divsf3+0xda>
     54c:	da 01       	movw	r26, r20
     54e:	c9 01       	movw	r24, r18
     550:	8f 77       	andi	r24, 0x7F	; 127
     552:	90 70       	andi	r25, 0x00	; 0
     554:	a0 70       	andi	r26, 0x00	; 0
     556:	b0 70       	andi	r27, 0x00	; 0
     558:	80 34       	cpi	r24, 0x40	; 64
     55a:	91 05       	cpc	r25, r1
     55c:	a1 05       	cpc	r26, r1
     55e:	b1 05       	cpc	r27, r1
     560:	61 f4       	brne	.+24     	; 0x57a <__divsf3+0x13c>
     562:	27 fd       	sbrc	r18, 7
     564:	0a c0       	rjmp	.+20     	; 0x57a <__divsf3+0x13c>
     566:	e1 14       	cp	r14, r1
     568:	f1 04       	cpc	r15, r1
     56a:	01 05       	cpc	r16, r1
     56c:	11 05       	cpc	r17, r1
     56e:	29 f0       	breq	.+10     	; 0x57a <__divsf3+0x13c>
     570:	20 5c       	subi	r18, 0xC0	; 192
     572:	3f 4f       	sbci	r19, 0xFF	; 255
     574:	4f 4f       	sbci	r20, 0xFF	; 255
     576:	5f 4f       	sbci	r21, 0xFF	; 255
     578:	20 78       	andi	r18, 0x80	; 128
     57a:	2d 87       	std	Y+13, r18	; 0x0d
     57c:	3e 87       	std	Y+14, r19	; 0x0e
     57e:	4f 87       	std	Y+15, r20	; 0x0f
     580:	58 8b       	std	Y+16, r21	; 0x10
     582:	be 01       	movw	r22, r28
     584:	67 5f       	subi	r22, 0xF7	; 247
     586:	7f 4f       	sbci	r23, 0xFF	; 255
     588:	cb 01       	movw	r24, r22
     58a:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <__pack_f>
     58e:	68 96       	adiw	r28, 0x18	; 24
     590:	ea e0       	ldi	r30, 0x0A	; 10
     592:	0c 94 04 1e 	jmp	0x3c08	; 0x3c08 <__epilogue_restores__+0x10>

00000596 <__gesf2>:
     596:	a8 e1       	ldi	r26, 0x18	; 24
     598:	b0 e0       	ldi	r27, 0x00	; 0
     59a:	e1 ed       	ldi	r30, 0xD1	; 209
     59c:	f2 e0       	ldi	r31, 0x02	; 2
     59e:	0c 94 ec 1d 	jmp	0x3bd8	; 0x3bd8 <__prologue_saves__+0x18>
     5a2:	69 83       	std	Y+1, r22	; 0x01
     5a4:	7a 83       	std	Y+2, r23	; 0x02
     5a6:	8b 83       	std	Y+3, r24	; 0x03
     5a8:	9c 83       	std	Y+4, r25	; 0x04
     5aa:	2d 83       	std	Y+5, r18	; 0x05
     5ac:	3e 83       	std	Y+6, r19	; 0x06
     5ae:	4f 83       	std	Y+7, r20	; 0x07
     5b0:	58 87       	std	Y+8, r21	; 0x08
     5b2:	89 e0       	ldi	r24, 0x09	; 9
     5b4:	e8 2e       	mov	r14, r24
     5b6:	f1 2c       	mov	r15, r1
     5b8:	ec 0e       	add	r14, r28
     5ba:	fd 1e       	adc	r15, r29
     5bc:	ce 01       	movw	r24, r28
     5be:	01 96       	adiw	r24, 0x01	; 1
     5c0:	b7 01       	movw	r22, r14
     5c2:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     5c6:	8e 01       	movw	r16, r28
     5c8:	0f 5e       	subi	r16, 0xEF	; 239
     5ca:	1f 4f       	sbci	r17, 0xFF	; 255
     5cc:	ce 01       	movw	r24, r28
     5ce:	05 96       	adiw	r24, 0x05	; 5
     5d0:	b8 01       	movw	r22, r16
     5d2:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     5d6:	89 85       	ldd	r24, Y+9	; 0x09
     5d8:	82 30       	cpi	r24, 0x02	; 2
     5da:	40 f0       	brcs	.+16     	; 0x5ec <__gesf2+0x56>
     5dc:	89 89       	ldd	r24, Y+17	; 0x11
     5de:	82 30       	cpi	r24, 0x02	; 2
     5e0:	28 f0       	brcs	.+10     	; 0x5ec <__gesf2+0x56>
     5e2:	c7 01       	movw	r24, r14
     5e4:	b8 01       	movw	r22, r16
     5e6:	0e 94 49 05 	call	0xa92	; 0xa92 <__fpcmp_parts_f>
     5ea:	01 c0       	rjmp	.+2      	; 0x5ee <__gesf2+0x58>
     5ec:	8f ef       	ldi	r24, 0xFF	; 255
     5ee:	68 96       	adiw	r28, 0x18	; 24
     5f0:	e6 e0       	ldi	r30, 0x06	; 6
     5f2:	0c 94 08 1e 	jmp	0x3c10	; 0x3c10 <__epilogue_restores__+0x18>

000005f6 <__floatsisf>:
     5f6:	a8 e0       	ldi	r26, 0x08	; 8
     5f8:	b0 e0       	ldi	r27, 0x00	; 0
     5fa:	e1 e0       	ldi	r30, 0x01	; 1
     5fc:	f3 e0       	ldi	r31, 0x03	; 3
     5fe:	0c 94 e9 1d 	jmp	0x3bd2	; 0x3bd2 <__prologue_saves__+0x12>
     602:	9b 01       	movw	r18, r22
     604:	ac 01       	movw	r20, r24
     606:	83 e0       	ldi	r24, 0x03	; 3
     608:	89 83       	std	Y+1, r24	; 0x01
     60a:	da 01       	movw	r26, r20
     60c:	c9 01       	movw	r24, r18
     60e:	88 27       	eor	r24, r24
     610:	b7 fd       	sbrc	r27, 7
     612:	83 95       	inc	r24
     614:	99 27       	eor	r25, r25
     616:	aa 27       	eor	r26, r26
     618:	bb 27       	eor	r27, r27
     61a:	b8 2e       	mov	r11, r24
     61c:	21 15       	cp	r18, r1
     61e:	31 05       	cpc	r19, r1
     620:	41 05       	cpc	r20, r1
     622:	51 05       	cpc	r21, r1
     624:	19 f4       	brne	.+6      	; 0x62c <__floatsisf+0x36>
     626:	82 e0       	ldi	r24, 0x02	; 2
     628:	89 83       	std	Y+1, r24	; 0x01
     62a:	3a c0       	rjmp	.+116    	; 0x6a0 <__floatsisf+0xaa>
     62c:	88 23       	and	r24, r24
     62e:	a9 f0       	breq	.+42     	; 0x65a <__floatsisf+0x64>
     630:	20 30       	cpi	r18, 0x00	; 0
     632:	80 e0       	ldi	r24, 0x00	; 0
     634:	38 07       	cpc	r19, r24
     636:	80 e0       	ldi	r24, 0x00	; 0
     638:	48 07       	cpc	r20, r24
     63a:	80 e8       	ldi	r24, 0x80	; 128
     63c:	58 07       	cpc	r21, r24
     63e:	29 f4       	brne	.+10     	; 0x64a <__floatsisf+0x54>
     640:	60 e0       	ldi	r22, 0x00	; 0
     642:	70 e0       	ldi	r23, 0x00	; 0
     644:	80 e0       	ldi	r24, 0x00	; 0
     646:	9f ec       	ldi	r25, 0xCF	; 207
     648:	30 c0       	rjmp	.+96     	; 0x6aa <__floatsisf+0xb4>
     64a:	ee 24       	eor	r14, r14
     64c:	ff 24       	eor	r15, r15
     64e:	87 01       	movw	r16, r14
     650:	e2 1a       	sub	r14, r18
     652:	f3 0a       	sbc	r15, r19
     654:	04 0b       	sbc	r16, r20
     656:	15 0b       	sbc	r17, r21
     658:	02 c0       	rjmp	.+4      	; 0x65e <__floatsisf+0x68>
     65a:	79 01       	movw	r14, r18
     65c:	8a 01       	movw	r16, r20
     65e:	8e e1       	ldi	r24, 0x1E	; 30
     660:	c8 2e       	mov	r12, r24
     662:	d1 2c       	mov	r13, r1
     664:	dc 82       	std	Y+4, r13	; 0x04
     666:	cb 82       	std	Y+3, r12	; 0x03
     668:	ed 82       	std	Y+5, r14	; 0x05
     66a:	fe 82       	std	Y+6, r15	; 0x06
     66c:	0f 83       	std	Y+7, r16	; 0x07
     66e:	18 87       	std	Y+8, r17	; 0x08
     670:	c8 01       	movw	r24, r16
     672:	b7 01       	movw	r22, r14
     674:	0e 94 ad 03 	call	0x75a	; 0x75a <__clzsi2>
     678:	01 97       	sbiw	r24, 0x01	; 1
     67a:	18 16       	cp	r1, r24
     67c:	19 06       	cpc	r1, r25
     67e:	84 f4       	brge	.+32     	; 0x6a0 <__floatsisf+0xaa>
     680:	08 2e       	mov	r0, r24
     682:	04 c0       	rjmp	.+8      	; 0x68c <__floatsisf+0x96>
     684:	ee 0c       	add	r14, r14
     686:	ff 1c       	adc	r15, r15
     688:	00 1f       	adc	r16, r16
     68a:	11 1f       	adc	r17, r17
     68c:	0a 94       	dec	r0
     68e:	d2 f7       	brpl	.-12     	; 0x684 <__floatsisf+0x8e>
     690:	ed 82       	std	Y+5, r14	; 0x05
     692:	fe 82       	std	Y+6, r15	; 0x06
     694:	0f 83       	std	Y+7, r16	; 0x07
     696:	18 87       	std	Y+8, r17	; 0x08
     698:	c8 1a       	sub	r12, r24
     69a:	d9 0a       	sbc	r13, r25
     69c:	dc 82       	std	Y+4, r13	; 0x04
     69e:	cb 82       	std	Y+3, r12	; 0x03
     6a0:	ba 82       	std	Y+2, r11	; 0x02
     6a2:	ce 01       	movw	r24, r28
     6a4:	01 96       	adiw	r24, 0x01	; 1
     6a6:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <__pack_f>
     6aa:	28 96       	adiw	r28, 0x08	; 8
     6ac:	e9 e0       	ldi	r30, 0x09	; 9
     6ae:	0c 94 05 1e 	jmp	0x3c0a	; 0x3c0a <__epilogue_restores__+0x12>

000006b2 <__fixsfsi>:
     6b2:	ac e0       	ldi	r26, 0x0C	; 12
     6b4:	b0 e0       	ldi	r27, 0x00	; 0
     6b6:	ef e5       	ldi	r30, 0x5F	; 95
     6b8:	f3 e0       	ldi	r31, 0x03	; 3
     6ba:	0c 94 f0 1d 	jmp	0x3be0	; 0x3be0 <__prologue_saves__+0x20>
     6be:	69 83       	std	Y+1, r22	; 0x01
     6c0:	7a 83       	std	Y+2, r23	; 0x02
     6c2:	8b 83       	std	Y+3, r24	; 0x03
     6c4:	9c 83       	std	Y+4, r25	; 0x04
     6c6:	ce 01       	movw	r24, r28
     6c8:	01 96       	adiw	r24, 0x01	; 1
     6ca:	be 01       	movw	r22, r28
     6cc:	6b 5f       	subi	r22, 0xFB	; 251
     6ce:	7f 4f       	sbci	r23, 0xFF	; 255
     6d0:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <__unpack_f>
     6d4:	8d 81       	ldd	r24, Y+5	; 0x05
     6d6:	82 30       	cpi	r24, 0x02	; 2
     6d8:	61 f1       	breq	.+88     	; 0x732 <__fixsfsi+0x80>
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	50 f1       	brcs	.+84     	; 0x732 <__fixsfsi+0x80>
     6de:	84 30       	cpi	r24, 0x04	; 4
     6e0:	21 f4       	brne	.+8      	; 0x6ea <__fixsfsi+0x38>
     6e2:	8e 81       	ldd	r24, Y+6	; 0x06
     6e4:	88 23       	and	r24, r24
     6e6:	51 f1       	breq	.+84     	; 0x73c <__fixsfsi+0x8a>
     6e8:	2e c0       	rjmp	.+92     	; 0x746 <__fixsfsi+0x94>
     6ea:	2f 81       	ldd	r18, Y+7	; 0x07
     6ec:	38 85       	ldd	r19, Y+8	; 0x08
     6ee:	37 fd       	sbrc	r19, 7
     6f0:	20 c0       	rjmp	.+64     	; 0x732 <__fixsfsi+0x80>
     6f2:	6e 81       	ldd	r22, Y+6	; 0x06
     6f4:	2f 31       	cpi	r18, 0x1F	; 31
     6f6:	31 05       	cpc	r19, r1
     6f8:	1c f0       	brlt	.+6      	; 0x700 <__fixsfsi+0x4e>
     6fa:	66 23       	and	r22, r22
     6fc:	f9 f0       	breq	.+62     	; 0x73c <__fixsfsi+0x8a>
     6fe:	23 c0       	rjmp	.+70     	; 0x746 <__fixsfsi+0x94>
     700:	8e e1       	ldi	r24, 0x1E	; 30
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	82 1b       	sub	r24, r18
     706:	93 0b       	sbc	r25, r19
     708:	29 85       	ldd	r18, Y+9	; 0x09
     70a:	3a 85       	ldd	r19, Y+10	; 0x0a
     70c:	4b 85       	ldd	r20, Y+11	; 0x0b
     70e:	5c 85       	ldd	r21, Y+12	; 0x0c
     710:	04 c0       	rjmp	.+8      	; 0x71a <__fixsfsi+0x68>
     712:	56 95       	lsr	r21
     714:	47 95       	ror	r20
     716:	37 95       	ror	r19
     718:	27 95       	ror	r18
     71a:	8a 95       	dec	r24
     71c:	d2 f7       	brpl	.-12     	; 0x712 <__fixsfsi+0x60>
     71e:	66 23       	and	r22, r22
     720:	b1 f0       	breq	.+44     	; 0x74e <__fixsfsi+0x9c>
     722:	50 95       	com	r21
     724:	40 95       	com	r20
     726:	30 95       	com	r19
     728:	21 95       	neg	r18
     72a:	3f 4f       	sbci	r19, 0xFF	; 255
     72c:	4f 4f       	sbci	r20, 0xFF	; 255
     72e:	5f 4f       	sbci	r21, 0xFF	; 255
     730:	0e c0       	rjmp	.+28     	; 0x74e <__fixsfsi+0x9c>
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	30 e0       	ldi	r19, 0x00	; 0
     736:	40 e0       	ldi	r20, 0x00	; 0
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	09 c0       	rjmp	.+18     	; 0x74e <__fixsfsi+0x9c>
     73c:	2f ef       	ldi	r18, 0xFF	; 255
     73e:	3f ef       	ldi	r19, 0xFF	; 255
     740:	4f ef       	ldi	r20, 0xFF	; 255
     742:	5f e7       	ldi	r21, 0x7F	; 127
     744:	04 c0       	rjmp	.+8      	; 0x74e <__fixsfsi+0x9c>
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	30 e0       	ldi	r19, 0x00	; 0
     74a:	40 e0       	ldi	r20, 0x00	; 0
     74c:	50 e8       	ldi	r21, 0x80	; 128
     74e:	b9 01       	movw	r22, r18
     750:	ca 01       	movw	r24, r20
     752:	2c 96       	adiw	r28, 0x0c	; 12
     754:	e2 e0       	ldi	r30, 0x02	; 2
     756:	0c 94 0c 1e 	jmp	0x3c18	; 0x3c18 <__epilogue_restores__+0x20>

0000075a <__clzsi2>:
     75a:	ef 92       	push	r14
     75c:	ff 92       	push	r15
     75e:	0f 93       	push	r16
     760:	1f 93       	push	r17
     762:	7b 01       	movw	r14, r22
     764:	8c 01       	movw	r16, r24
     766:	80 e0       	ldi	r24, 0x00	; 0
     768:	e8 16       	cp	r14, r24
     76a:	80 e0       	ldi	r24, 0x00	; 0
     76c:	f8 06       	cpc	r15, r24
     76e:	81 e0       	ldi	r24, 0x01	; 1
     770:	08 07       	cpc	r16, r24
     772:	80 e0       	ldi	r24, 0x00	; 0
     774:	18 07       	cpc	r17, r24
     776:	88 f4       	brcc	.+34     	; 0x79a <__clzsi2+0x40>
     778:	8f ef       	ldi	r24, 0xFF	; 255
     77a:	e8 16       	cp	r14, r24
     77c:	f1 04       	cpc	r15, r1
     77e:	01 05       	cpc	r16, r1
     780:	11 05       	cpc	r17, r1
     782:	31 f0       	breq	.+12     	; 0x790 <__clzsi2+0x36>
     784:	28 f0       	brcs	.+10     	; 0x790 <__clzsi2+0x36>
     786:	88 e0       	ldi	r24, 0x08	; 8
     788:	90 e0       	ldi	r25, 0x00	; 0
     78a:	a0 e0       	ldi	r26, 0x00	; 0
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	17 c0       	rjmp	.+46     	; 0x7be <__clzsi2+0x64>
     790:	80 e0       	ldi	r24, 0x00	; 0
     792:	90 e0       	ldi	r25, 0x00	; 0
     794:	a0 e0       	ldi	r26, 0x00	; 0
     796:	b0 e0       	ldi	r27, 0x00	; 0
     798:	12 c0       	rjmp	.+36     	; 0x7be <__clzsi2+0x64>
     79a:	80 e0       	ldi	r24, 0x00	; 0
     79c:	e8 16       	cp	r14, r24
     79e:	80 e0       	ldi	r24, 0x00	; 0
     7a0:	f8 06       	cpc	r15, r24
     7a2:	80 e0       	ldi	r24, 0x00	; 0
     7a4:	08 07       	cpc	r16, r24
     7a6:	81 e0       	ldi	r24, 0x01	; 1
     7a8:	18 07       	cpc	r17, r24
     7aa:	28 f0       	brcs	.+10     	; 0x7b6 <__clzsi2+0x5c>
     7ac:	88 e1       	ldi	r24, 0x18	; 24
     7ae:	90 e0       	ldi	r25, 0x00	; 0
     7b0:	a0 e0       	ldi	r26, 0x00	; 0
     7b2:	b0 e0       	ldi	r27, 0x00	; 0
     7b4:	04 c0       	rjmp	.+8      	; 0x7be <__clzsi2+0x64>
     7b6:	80 e1       	ldi	r24, 0x10	; 16
     7b8:	90 e0       	ldi	r25, 0x00	; 0
     7ba:	a0 e0       	ldi	r26, 0x00	; 0
     7bc:	b0 e0       	ldi	r27, 0x00	; 0
     7be:	20 e2       	ldi	r18, 0x20	; 32
     7c0:	30 e0       	ldi	r19, 0x00	; 0
     7c2:	40 e0       	ldi	r20, 0x00	; 0
     7c4:	50 e0       	ldi	r21, 0x00	; 0
     7c6:	28 1b       	sub	r18, r24
     7c8:	39 0b       	sbc	r19, r25
     7ca:	4a 0b       	sbc	r20, r26
     7cc:	5b 0b       	sbc	r21, r27
     7ce:	04 c0       	rjmp	.+8      	; 0x7d8 <__clzsi2+0x7e>
     7d0:	16 95       	lsr	r17
     7d2:	07 95       	ror	r16
     7d4:	f7 94       	ror	r15
     7d6:	e7 94       	ror	r14
     7d8:	8a 95       	dec	r24
     7da:	d2 f7       	brpl	.-12     	; 0x7d0 <__clzsi2+0x76>
     7dc:	f7 01       	movw	r30, r14
     7de:	e5 5f       	subi	r30, 0xF5	; 245
     7e0:	fe 4f       	sbci	r31, 0xFE	; 254
     7e2:	80 81       	ld	r24, Z
     7e4:	28 1b       	sub	r18, r24
     7e6:	31 09       	sbc	r19, r1
     7e8:	41 09       	sbc	r20, r1
     7ea:	51 09       	sbc	r21, r1
     7ec:	c9 01       	movw	r24, r18
     7ee:	1f 91       	pop	r17
     7f0:	0f 91       	pop	r16
     7f2:	ff 90       	pop	r15
     7f4:	ef 90       	pop	r14
     7f6:	08 95       	ret

000007f8 <__pack_f>:
     7f8:	df 92       	push	r13
     7fa:	ef 92       	push	r14
     7fc:	ff 92       	push	r15
     7fe:	0f 93       	push	r16
     800:	1f 93       	push	r17
     802:	fc 01       	movw	r30, r24
     804:	e4 80       	ldd	r14, Z+4	; 0x04
     806:	f5 80       	ldd	r15, Z+5	; 0x05
     808:	06 81       	ldd	r16, Z+6	; 0x06
     80a:	17 81       	ldd	r17, Z+7	; 0x07
     80c:	d1 80       	ldd	r13, Z+1	; 0x01
     80e:	80 81       	ld	r24, Z
     810:	82 30       	cpi	r24, 0x02	; 2
     812:	48 f4       	brcc	.+18     	; 0x826 <__pack_f+0x2e>
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	a0 e1       	ldi	r26, 0x10	; 16
     81a:	b0 e0       	ldi	r27, 0x00	; 0
     81c:	e8 2a       	or	r14, r24
     81e:	f9 2a       	or	r15, r25
     820:	0a 2b       	or	r16, r26
     822:	1b 2b       	or	r17, r27
     824:	a5 c0       	rjmp	.+330    	; 0x970 <__stack+0x111>
     826:	84 30       	cpi	r24, 0x04	; 4
     828:	09 f4       	brne	.+2      	; 0x82c <__pack_f+0x34>
     82a:	9f c0       	rjmp	.+318    	; 0x96a <__stack+0x10b>
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	21 f4       	brne	.+8      	; 0x838 <__pack_f+0x40>
     830:	ee 24       	eor	r14, r14
     832:	ff 24       	eor	r15, r15
     834:	87 01       	movw	r16, r14
     836:	05 c0       	rjmp	.+10     	; 0x842 <__pack_f+0x4a>
     838:	e1 14       	cp	r14, r1
     83a:	f1 04       	cpc	r15, r1
     83c:	01 05       	cpc	r16, r1
     83e:	11 05       	cpc	r17, r1
     840:	19 f4       	brne	.+6      	; 0x848 <__pack_f+0x50>
     842:	e0 e0       	ldi	r30, 0x00	; 0
     844:	f0 e0       	ldi	r31, 0x00	; 0
     846:	96 c0       	rjmp	.+300    	; 0x974 <__stack+0x115>
     848:	62 81       	ldd	r22, Z+2	; 0x02
     84a:	73 81       	ldd	r23, Z+3	; 0x03
     84c:	9f ef       	ldi	r25, 0xFF	; 255
     84e:	62 38       	cpi	r22, 0x82	; 130
     850:	79 07       	cpc	r23, r25
     852:	0c f0       	brlt	.+2      	; 0x856 <__pack_f+0x5e>
     854:	5b c0       	rjmp	.+182    	; 0x90c <__stack+0xad>
     856:	22 e8       	ldi	r18, 0x82	; 130
     858:	3f ef       	ldi	r19, 0xFF	; 255
     85a:	26 1b       	sub	r18, r22
     85c:	37 0b       	sbc	r19, r23
     85e:	2a 31       	cpi	r18, 0x1A	; 26
     860:	31 05       	cpc	r19, r1
     862:	2c f0       	brlt	.+10     	; 0x86e <__stack+0xf>
     864:	20 e0       	ldi	r18, 0x00	; 0
     866:	30 e0       	ldi	r19, 0x00	; 0
     868:	40 e0       	ldi	r20, 0x00	; 0
     86a:	50 e0       	ldi	r21, 0x00	; 0
     86c:	2a c0       	rjmp	.+84     	; 0x8c2 <__stack+0x63>
     86e:	b8 01       	movw	r22, r16
     870:	a7 01       	movw	r20, r14
     872:	02 2e       	mov	r0, r18
     874:	04 c0       	rjmp	.+8      	; 0x87e <__stack+0x1f>
     876:	76 95       	lsr	r23
     878:	67 95       	ror	r22
     87a:	57 95       	ror	r21
     87c:	47 95       	ror	r20
     87e:	0a 94       	dec	r0
     880:	d2 f7       	brpl	.-12     	; 0x876 <__stack+0x17>
     882:	81 e0       	ldi	r24, 0x01	; 1
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	a0 e0       	ldi	r26, 0x00	; 0
     888:	b0 e0       	ldi	r27, 0x00	; 0
     88a:	04 c0       	rjmp	.+8      	; 0x894 <__stack+0x35>
     88c:	88 0f       	add	r24, r24
     88e:	99 1f       	adc	r25, r25
     890:	aa 1f       	adc	r26, r26
     892:	bb 1f       	adc	r27, r27
     894:	2a 95       	dec	r18
     896:	d2 f7       	brpl	.-12     	; 0x88c <__stack+0x2d>
     898:	01 97       	sbiw	r24, 0x01	; 1
     89a:	a1 09       	sbc	r26, r1
     89c:	b1 09       	sbc	r27, r1
     89e:	8e 21       	and	r24, r14
     8a0:	9f 21       	and	r25, r15
     8a2:	a0 23       	and	r26, r16
     8a4:	b1 23       	and	r27, r17
     8a6:	00 97       	sbiw	r24, 0x00	; 0
     8a8:	a1 05       	cpc	r26, r1
     8aa:	b1 05       	cpc	r27, r1
     8ac:	21 f0       	breq	.+8      	; 0x8b6 <__stack+0x57>
     8ae:	81 e0       	ldi	r24, 0x01	; 1
     8b0:	90 e0       	ldi	r25, 0x00	; 0
     8b2:	a0 e0       	ldi	r26, 0x00	; 0
     8b4:	b0 e0       	ldi	r27, 0x00	; 0
     8b6:	9a 01       	movw	r18, r20
     8b8:	ab 01       	movw	r20, r22
     8ba:	28 2b       	or	r18, r24
     8bc:	39 2b       	or	r19, r25
     8be:	4a 2b       	or	r20, r26
     8c0:	5b 2b       	or	r21, r27
     8c2:	da 01       	movw	r26, r20
     8c4:	c9 01       	movw	r24, r18
     8c6:	8f 77       	andi	r24, 0x7F	; 127
     8c8:	90 70       	andi	r25, 0x00	; 0
     8ca:	a0 70       	andi	r26, 0x00	; 0
     8cc:	b0 70       	andi	r27, 0x00	; 0
     8ce:	80 34       	cpi	r24, 0x40	; 64
     8d0:	91 05       	cpc	r25, r1
     8d2:	a1 05       	cpc	r26, r1
     8d4:	b1 05       	cpc	r27, r1
     8d6:	39 f4       	brne	.+14     	; 0x8e6 <__stack+0x87>
     8d8:	27 ff       	sbrs	r18, 7
     8da:	09 c0       	rjmp	.+18     	; 0x8ee <__stack+0x8f>
     8dc:	20 5c       	subi	r18, 0xC0	; 192
     8de:	3f 4f       	sbci	r19, 0xFF	; 255
     8e0:	4f 4f       	sbci	r20, 0xFF	; 255
     8e2:	5f 4f       	sbci	r21, 0xFF	; 255
     8e4:	04 c0       	rjmp	.+8      	; 0x8ee <__stack+0x8f>
     8e6:	21 5c       	subi	r18, 0xC1	; 193
     8e8:	3f 4f       	sbci	r19, 0xFF	; 255
     8ea:	4f 4f       	sbci	r20, 0xFF	; 255
     8ec:	5f 4f       	sbci	r21, 0xFF	; 255
     8ee:	e0 e0       	ldi	r30, 0x00	; 0
     8f0:	f0 e0       	ldi	r31, 0x00	; 0
     8f2:	20 30       	cpi	r18, 0x00	; 0
     8f4:	a0 e0       	ldi	r26, 0x00	; 0
     8f6:	3a 07       	cpc	r19, r26
     8f8:	a0 e0       	ldi	r26, 0x00	; 0
     8fa:	4a 07       	cpc	r20, r26
     8fc:	a0 e4       	ldi	r26, 0x40	; 64
     8fe:	5a 07       	cpc	r21, r26
     900:	10 f0       	brcs	.+4      	; 0x906 <__stack+0xa7>
     902:	e1 e0       	ldi	r30, 0x01	; 1
     904:	f0 e0       	ldi	r31, 0x00	; 0
     906:	79 01       	movw	r14, r18
     908:	8a 01       	movw	r16, r20
     90a:	27 c0       	rjmp	.+78     	; 0x95a <__stack+0xfb>
     90c:	60 38       	cpi	r22, 0x80	; 128
     90e:	71 05       	cpc	r23, r1
     910:	64 f5       	brge	.+88     	; 0x96a <__stack+0x10b>
     912:	fb 01       	movw	r30, r22
     914:	e1 58       	subi	r30, 0x81	; 129
     916:	ff 4f       	sbci	r31, 0xFF	; 255
     918:	d8 01       	movw	r26, r16
     91a:	c7 01       	movw	r24, r14
     91c:	8f 77       	andi	r24, 0x7F	; 127
     91e:	90 70       	andi	r25, 0x00	; 0
     920:	a0 70       	andi	r26, 0x00	; 0
     922:	b0 70       	andi	r27, 0x00	; 0
     924:	80 34       	cpi	r24, 0x40	; 64
     926:	91 05       	cpc	r25, r1
     928:	a1 05       	cpc	r26, r1
     92a:	b1 05       	cpc	r27, r1
     92c:	39 f4       	brne	.+14     	; 0x93c <__stack+0xdd>
     92e:	e7 fe       	sbrs	r14, 7
     930:	0d c0       	rjmp	.+26     	; 0x94c <__stack+0xed>
     932:	80 e4       	ldi	r24, 0x40	; 64
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	a0 e0       	ldi	r26, 0x00	; 0
     938:	b0 e0       	ldi	r27, 0x00	; 0
     93a:	04 c0       	rjmp	.+8      	; 0x944 <__stack+0xe5>
     93c:	8f e3       	ldi	r24, 0x3F	; 63
     93e:	90 e0       	ldi	r25, 0x00	; 0
     940:	a0 e0       	ldi	r26, 0x00	; 0
     942:	b0 e0       	ldi	r27, 0x00	; 0
     944:	e8 0e       	add	r14, r24
     946:	f9 1e       	adc	r15, r25
     948:	0a 1f       	adc	r16, r26
     94a:	1b 1f       	adc	r17, r27
     94c:	17 ff       	sbrs	r17, 7
     94e:	05 c0       	rjmp	.+10     	; 0x95a <__stack+0xfb>
     950:	16 95       	lsr	r17
     952:	07 95       	ror	r16
     954:	f7 94       	ror	r15
     956:	e7 94       	ror	r14
     958:	31 96       	adiw	r30, 0x01	; 1
     95a:	87 e0       	ldi	r24, 0x07	; 7
     95c:	16 95       	lsr	r17
     95e:	07 95       	ror	r16
     960:	f7 94       	ror	r15
     962:	e7 94       	ror	r14
     964:	8a 95       	dec	r24
     966:	d1 f7       	brne	.-12     	; 0x95c <__stack+0xfd>
     968:	05 c0       	rjmp	.+10     	; 0x974 <__stack+0x115>
     96a:	ee 24       	eor	r14, r14
     96c:	ff 24       	eor	r15, r15
     96e:	87 01       	movw	r16, r14
     970:	ef ef       	ldi	r30, 0xFF	; 255
     972:	f0 e0       	ldi	r31, 0x00	; 0
     974:	6e 2f       	mov	r22, r30
     976:	67 95       	ror	r22
     978:	66 27       	eor	r22, r22
     97a:	67 95       	ror	r22
     97c:	90 2f       	mov	r25, r16
     97e:	9f 77       	andi	r25, 0x7F	; 127
     980:	d7 94       	ror	r13
     982:	dd 24       	eor	r13, r13
     984:	d7 94       	ror	r13
     986:	8e 2f       	mov	r24, r30
     988:	86 95       	lsr	r24
     98a:	49 2f       	mov	r20, r25
     98c:	46 2b       	or	r20, r22
     98e:	58 2f       	mov	r21, r24
     990:	5d 29       	or	r21, r13
     992:	b7 01       	movw	r22, r14
     994:	ca 01       	movw	r24, r20
     996:	1f 91       	pop	r17
     998:	0f 91       	pop	r16
     99a:	ff 90       	pop	r15
     99c:	ef 90       	pop	r14
     99e:	df 90       	pop	r13
     9a0:	08 95       	ret

000009a2 <__unpack_f>:
     9a2:	fc 01       	movw	r30, r24
     9a4:	db 01       	movw	r26, r22
     9a6:	40 81       	ld	r20, Z
     9a8:	51 81       	ldd	r21, Z+1	; 0x01
     9aa:	22 81       	ldd	r18, Z+2	; 0x02
     9ac:	62 2f       	mov	r22, r18
     9ae:	6f 77       	andi	r22, 0x7F	; 127
     9b0:	70 e0       	ldi	r23, 0x00	; 0
     9b2:	22 1f       	adc	r18, r18
     9b4:	22 27       	eor	r18, r18
     9b6:	22 1f       	adc	r18, r18
     9b8:	93 81       	ldd	r25, Z+3	; 0x03
     9ba:	89 2f       	mov	r24, r25
     9bc:	88 0f       	add	r24, r24
     9be:	82 2b       	or	r24, r18
     9c0:	28 2f       	mov	r18, r24
     9c2:	30 e0       	ldi	r19, 0x00	; 0
     9c4:	99 1f       	adc	r25, r25
     9c6:	99 27       	eor	r25, r25
     9c8:	99 1f       	adc	r25, r25
     9ca:	11 96       	adiw	r26, 0x01	; 1
     9cc:	9c 93       	st	X, r25
     9ce:	11 97       	sbiw	r26, 0x01	; 1
     9d0:	21 15       	cp	r18, r1
     9d2:	31 05       	cpc	r19, r1
     9d4:	a9 f5       	brne	.+106    	; 0xa40 <__unpack_f+0x9e>
     9d6:	41 15       	cp	r20, r1
     9d8:	51 05       	cpc	r21, r1
     9da:	61 05       	cpc	r22, r1
     9dc:	71 05       	cpc	r23, r1
     9de:	11 f4       	brne	.+4      	; 0x9e4 <__unpack_f+0x42>
     9e0:	82 e0       	ldi	r24, 0x02	; 2
     9e2:	37 c0       	rjmp	.+110    	; 0xa52 <__unpack_f+0xb0>
     9e4:	82 e8       	ldi	r24, 0x82	; 130
     9e6:	9f ef       	ldi	r25, 0xFF	; 255
     9e8:	13 96       	adiw	r26, 0x03	; 3
     9ea:	9c 93       	st	X, r25
     9ec:	8e 93       	st	-X, r24
     9ee:	12 97       	sbiw	r26, 0x02	; 2
     9f0:	9a 01       	movw	r18, r20
     9f2:	ab 01       	movw	r20, r22
     9f4:	67 e0       	ldi	r22, 0x07	; 7
     9f6:	22 0f       	add	r18, r18
     9f8:	33 1f       	adc	r19, r19
     9fa:	44 1f       	adc	r20, r20
     9fc:	55 1f       	adc	r21, r21
     9fe:	6a 95       	dec	r22
     a00:	d1 f7       	brne	.-12     	; 0x9f6 <__unpack_f+0x54>
     a02:	83 e0       	ldi	r24, 0x03	; 3
     a04:	8c 93       	st	X, r24
     a06:	0d c0       	rjmp	.+26     	; 0xa22 <__unpack_f+0x80>
     a08:	22 0f       	add	r18, r18
     a0a:	33 1f       	adc	r19, r19
     a0c:	44 1f       	adc	r20, r20
     a0e:	55 1f       	adc	r21, r21
     a10:	12 96       	adiw	r26, 0x02	; 2
     a12:	8d 91       	ld	r24, X+
     a14:	9c 91       	ld	r25, X
     a16:	13 97       	sbiw	r26, 0x03	; 3
     a18:	01 97       	sbiw	r24, 0x01	; 1
     a1a:	13 96       	adiw	r26, 0x03	; 3
     a1c:	9c 93       	st	X, r25
     a1e:	8e 93       	st	-X, r24
     a20:	12 97       	sbiw	r26, 0x02	; 2
     a22:	20 30       	cpi	r18, 0x00	; 0
     a24:	80 e0       	ldi	r24, 0x00	; 0
     a26:	38 07       	cpc	r19, r24
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	48 07       	cpc	r20, r24
     a2c:	80 e4       	ldi	r24, 0x40	; 64
     a2e:	58 07       	cpc	r21, r24
     a30:	58 f3       	brcs	.-42     	; 0xa08 <__unpack_f+0x66>
     a32:	14 96       	adiw	r26, 0x04	; 4
     a34:	2d 93       	st	X+, r18
     a36:	3d 93       	st	X+, r19
     a38:	4d 93       	st	X+, r20
     a3a:	5c 93       	st	X, r21
     a3c:	17 97       	sbiw	r26, 0x07	; 7
     a3e:	08 95       	ret
     a40:	2f 3f       	cpi	r18, 0xFF	; 255
     a42:	31 05       	cpc	r19, r1
     a44:	79 f4       	brne	.+30     	; 0xa64 <__unpack_f+0xc2>
     a46:	41 15       	cp	r20, r1
     a48:	51 05       	cpc	r21, r1
     a4a:	61 05       	cpc	r22, r1
     a4c:	71 05       	cpc	r23, r1
     a4e:	19 f4       	brne	.+6      	; 0xa56 <__unpack_f+0xb4>
     a50:	84 e0       	ldi	r24, 0x04	; 4
     a52:	8c 93       	st	X, r24
     a54:	08 95       	ret
     a56:	64 ff       	sbrs	r22, 4
     a58:	03 c0       	rjmp	.+6      	; 0xa60 <__unpack_f+0xbe>
     a5a:	81 e0       	ldi	r24, 0x01	; 1
     a5c:	8c 93       	st	X, r24
     a5e:	12 c0       	rjmp	.+36     	; 0xa84 <__unpack_f+0xe2>
     a60:	1c 92       	st	X, r1
     a62:	10 c0       	rjmp	.+32     	; 0xa84 <__unpack_f+0xe2>
     a64:	2f 57       	subi	r18, 0x7F	; 127
     a66:	30 40       	sbci	r19, 0x00	; 0
     a68:	13 96       	adiw	r26, 0x03	; 3
     a6a:	3c 93       	st	X, r19
     a6c:	2e 93       	st	-X, r18
     a6e:	12 97       	sbiw	r26, 0x02	; 2
     a70:	83 e0       	ldi	r24, 0x03	; 3
     a72:	8c 93       	st	X, r24
     a74:	87 e0       	ldi	r24, 0x07	; 7
     a76:	44 0f       	add	r20, r20
     a78:	55 1f       	adc	r21, r21
     a7a:	66 1f       	adc	r22, r22
     a7c:	77 1f       	adc	r23, r23
     a7e:	8a 95       	dec	r24
     a80:	d1 f7       	brne	.-12     	; 0xa76 <__unpack_f+0xd4>
     a82:	70 64       	ori	r23, 0x40	; 64
     a84:	14 96       	adiw	r26, 0x04	; 4
     a86:	4d 93       	st	X+, r20
     a88:	5d 93       	st	X+, r21
     a8a:	6d 93       	st	X+, r22
     a8c:	7c 93       	st	X, r23
     a8e:	17 97       	sbiw	r26, 0x07	; 7
     a90:	08 95       	ret

00000a92 <__fpcmp_parts_f>:
     a92:	1f 93       	push	r17
     a94:	dc 01       	movw	r26, r24
     a96:	fb 01       	movw	r30, r22
     a98:	9c 91       	ld	r25, X
     a9a:	92 30       	cpi	r25, 0x02	; 2
     a9c:	08 f4       	brcc	.+2      	; 0xaa0 <__fpcmp_parts_f+0xe>
     a9e:	47 c0       	rjmp	.+142    	; 0xb2e <__fpcmp_parts_f+0x9c>
     aa0:	80 81       	ld	r24, Z
     aa2:	82 30       	cpi	r24, 0x02	; 2
     aa4:	08 f4       	brcc	.+2      	; 0xaa8 <__fpcmp_parts_f+0x16>
     aa6:	43 c0       	rjmp	.+134    	; 0xb2e <__fpcmp_parts_f+0x9c>
     aa8:	94 30       	cpi	r25, 0x04	; 4
     aaa:	51 f4       	brne	.+20     	; 0xac0 <__fpcmp_parts_f+0x2e>
     aac:	11 96       	adiw	r26, 0x01	; 1
     aae:	1c 91       	ld	r17, X
     ab0:	84 30       	cpi	r24, 0x04	; 4
     ab2:	99 f5       	brne	.+102    	; 0xb1a <__fpcmp_parts_f+0x88>
     ab4:	81 81       	ldd	r24, Z+1	; 0x01
     ab6:	68 2f       	mov	r22, r24
     ab8:	70 e0       	ldi	r23, 0x00	; 0
     aba:	61 1b       	sub	r22, r17
     abc:	71 09       	sbc	r23, r1
     abe:	3f c0       	rjmp	.+126    	; 0xb3e <__fpcmp_parts_f+0xac>
     ac0:	84 30       	cpi	r24, 0x04	; 4
     ac2:	21 f0       	breq	.+8      	; 0xacc <__fpcmp_parts_f+0x3a>
     ac4:	92 30       	cpi	r25, 0x02	; 2
     ac6:	31 f4       	brne	.+12     	; 0xad4 <__fpcmp_parts_f+0x42>
     ac8:	82 30       	cpi	r24, 0x02	; 2
     aca:	b9 f1       	breq	.+110    	; 0xb3a <__fpcmp_parts_f+0xa8>
     acc:	81 81       	ldd	r24, Z+1	; 0x01
     ace:	88 23       	and	r24, r24
     ad0:	89 f1       	breq	.+98     	; 0xb34 <__fpcmp_parts_f+0xa2>
     ad2:	2d c0       	rjmp	.+90     	; 0xb2e <__fpcmp_parts_f+0x9c>
     ad4:	11 96       	adiw	r26, 0x01	; 1
     ad6:	1c 91       	ld	r17, X
     ad8:	11 97       	sbiw	r26, 0x01	; 1
     ada:	82 30       	cpi	r24, 0x02	; 2
     adc:	f1 f0       	breq	.+60     	; 0xb1a <__fpcmp_parts_f+0x88>
     ade:	81 81       	ldd	r24, Z+1	; 0x01
     ae0:	18 17       	cp	r17, r24
     ae2:	d9 f4       	brne	.+54     	; 0xb1a <__fpcmp_parts_f+0x88>
     ae4:	12 96       	adiw	r26, 0x02	; 2
     ae6:	2d 91       	ld	r18, X+
     ae8:	3c 91       	ld	r19, X
     aea:	13 97       	sbiw	r26, 0x03	; 3
     aec:	82 81       	ldd	r24, Z+2	; 0x02
     aee:	93 81       	ldd	r25, Z+3	; 0x03
     af0:	82 17       	cp	r24, r18
     af2:	93 07       	cpc	r25, r19
     af4:	94 f0       	brlt	.+36     	; 0xb1a <__fpcmp_parts_f+0x88>
     af6:	28 17       	cp	r18, r24
     af8:	39 07       	cpc	r19, r25
     afa:	bc f0       	brlt	.+46     	; 0xb2a <__fpcmp_parts_f+0x98>
     afc:	14 96       	adiw	r26, 0x04	; 4
     afe:	8d 91       	ld	r24, X+
     b00:	9d 91       	ld	r25, X+
     b02:	0d 90       	ld	r0, X+
     b04:	bc 91       	ld	r27, X
     b06:	a0 2d       	mov	r26, r0
     b08:	24 81       	ldd	r18, Z+4	; 0x04
     b0a:	35 81       	ldd	r19, Z+5	; 0x05
     b0c:	46 81       	ldd	r20, Z+6	; 0x06
     b0e:	57 81       	ldd	r21, Z+7	; 0x07
     b10:	28 17       	cp	r18, r24
     b12:	39 07       	cpc	r19, r25
     b14:	4a 07       	cpc	r20, r26
     b16:	5b 07       	cpc	r21, r27
     b18:	18 f4       	brcc	.+6      	; 0xb20 <__fpcmp_parts_f+0x8e>
     b1a:	11 23       	and	r17, r17
     b1c:	41 f0       	breq	.+16     	; 0xb2e <__fpcmp_parts_f+0x9c>
     b1e:	0a c0       	rjmp	.+20     	; 0xb34 <__fpcmp_parts_f+0xa2>
     b20:	82 17       	cp	r24, r18
     b22:	93 07       	cpc	r25, r19
     b24:	a4 07       	cpc	r26, r20
     b26:	b5 07       	cpc	r27, r21
     b28:	40 f4       	brcc	.+16     	; 0xb3a <__fpcmp_parts_f+0xa8>
     b2a:	11 23       	and	r17, r17
     b2c:	19 f0       	breq	.+6      	; 0xb34 <__fpcmp_parts_f+0xa2>
     b2e:	61 e0       	ldi	r22, 0x01	; 1
     b30:	70 e0       	ldi	r23, 0x00	; 0
     b32:	05 c0       	rjmp	.+10     	; 0xb3e <__fpcmp_parts_f+0xac>
     b34:	6f ef       	ldi	r22, 0xFF	; 255
     b36:	7f ef       	ldi	r23, 0xFF	; 255
     b38:	02 c0       	rjmp	.+4      	; 0xb3e <__fpcmp_parts_f+0xac>
     b3a:	60 e0       	ldi	r22, 0x00	; 0
     b3c:	70 e0       	ldi	r23, 0x00	; 0
     b3e:	cb 01       	movw	r24, r22
     b40:	1f 91       	pop	r17
     b42:	08 95       	ret

00000b44 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
     b44:	80 91 28 02 	lds	r24, 0x0228
     b48:	88 23       	and	r24, r24
     b4a:	21 f0       	breq	.+8      	; 0xb54 <xArePollingQueuesStillRunning+0x10>
     b4c:	80 91 29 02 	lds	r24, 0x0229
     b50:	81 11       	cpse	r24, r1
     b52:	81 e0       	ldi	r24, 0x01	; 1
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
     b54:	10 92 28 02 	sts	0x0228, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
     b58:	10 92 29 02 	sts	0x0229, r1

	return xReturn;
}
     b5c:	08 95       	ret

00000b5e <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
     b5e:	8f 92       	push	r8
     b60:	9f 92       	push	r9
     b62:	af 92       	push	r10
     b64:	bf 92       	push	r11
     b66:	cf 92       	push	r12
     b68:	df 92       	push	r13
     b6a:	ef 92       	push	r14
     b6c:	ff 92       	push	r15
     b6e:	0f 93       	push	r16
     b70:	1f 93       	push	r17
     b72:	18 2f       	mov	r17, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
     b74:	8a e0       	ldi	r24, 0x0A	; 10
     b76:	62 e0       	ldi	r22, 0x02	; 2
     b78:	40 e0       	ldi	r20, 0x00	; 0
     b7a:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueGenericCreate>
     b7e:	90 93 2b 02 	sts	0x022B, r25
     b82:	80 93 2a 02 	sts	0x022A, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     b86:	8a e2       	ldi	r24, 0x2A	; 42
     b88:	88 2e       	mov	r8, r24
     b8a:	82 e0       	ldi	r24, 0x02	; 2
     b8c:	98 2e       	mov	r9, r24
     b8e:	87 e2       	ldi	r24, 0x27	; 39
     b90:	96 e0       	ldi	r25, 0x06	; 6
     b92:	60 e6       	ldi	r22, 0x60	; 96
     b94:	70 e0       	ldi	r23, 0x00	; 0
     b96:	45 e5       	ldi	r20, 0x55	; 85
     b98:	50 e0       	ldi	r21, 0x00	; 0
     b9a:	94 01       	movw	r18, r8
     b9c:	01 2f       	mov	r16, r17
     b9e:	ee 24       	eor	r14, r14
     ba0:	ff 24       	eor	r15, r15
     ba2:	cc 24       	eor	r12, r12
     ba4:	dd 24       	eor	r13, r13
     ba6:	aa 24       	eor	r10, r10
     ba8:	bb 24       	eor	r11, r11
     baa:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
     bae:	8b ee       	ldi	r24, 0xEB	; 235
     bb0:	95 e0       	ldi	r25, 0x05	; 5
     bb2:	68 e6       	ldi	r22, 0x68	; 104
     bb4:	70 e0       	ldi	r23, 0x00	; 0
     bb6:	45 e5       	ldi	r20, 0x55	; 85
     bb8:	50 e0       	ldi	r21, 0x00	; 0
     bba:	94 01       	movw	r18, r8
     bbc:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>
}
     bc0:	1f 91       	pop	r17
     bc2:	0f 91       	pop	r16
     bc4:	ff 90       	pop	r15
     bc6:	ef 90       	pop	r14
     bc8:	df 90       	pop	r13
     bca:	cf 90       	pop	r12
     bcc:	bf 90       	pop	r11
     bce:	af 90       	pop	r10
     bd0:	9f 90       	pop	r9
     bd2:	8f 90       	pop	r8
     bd4:	08 95       	ret

00000bd6 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     bd6:	cf 92       	push	r12
     bd8:	df 92       	push	r13
     bda:	ef 92       	push	r14
     bdc:	ff 92       	push	r15
     bde:	0f 93       	push	r16
     be0:	1f 93       	push	r17
     be2:	df 93       	push	r29
     be4:	cf 93       	push	r28
     be6:	00 d0       	rcall	.+0      	; 0xbe8 <vPolledQueueProducer+0x12>
     be8:	cd b7       	in	r28, 0x3d	; 61
     bea:	de b7       	in	r29, 0x3e	; 62
     bec:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
     bee:	1a 82       	std	Y+2, r1	; 0x02
     bf0:	19 82       	std	Y+1, r1	; 0x01
     bf2:	00 e0       	ldi	r16, 0x00	; 0
     bf4:	10 e0       	ldi	r17, 0x00	; 0
	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     bf6:	6e 01       	movw	r12, r28
     bf8:	08 94       	sec
     bfa:	c1 1c       	adc	r12, r1
     bfc:	d1 1c       	adc	r13, r1
     bfe:	1f c0       	rjmp	.+62     	; 0xc3e <vPolledQueueProducer+0x68>
     c00:	f7 01       	movw	r30, r14
     c02:	80 81       	ld	r24, Z
     c04:	91 81       	ldd	r25, Z+1	; 0x01
     c06:	b6 01       	movw	r22, r12
     c08:	40 e0       	ldi	r20, 0x00	; 0
     c0a:	50 e0       	ldi	r21, 0x00	; 0
     c0c:	20 e0       	ldi	r18, 0x00	; 0
     c0e:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <xQueueGenericSend>
     c12:	81 30       	cpi	r24, 0x01	; 1
     c14:	11 f0       	breq	.+4      	; 0xc1a <vPolledQueueProducer+0x44>
     c16:	01 e0       	ldi	r16, 0x01	; 1
     c18:	11 c0       	rjmp	.+34     	; 0xc3c <vPolledQueueProducer+0x66>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
     c1a:	00 23       	and	r16, r16
     c1c:	51 f4       	brne	.+20     	; 0xc32 <vPolledQueueProducer+0x5c>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     c1e:	0f b6       	in	r0, 0x3f	; 63
     c20:	f8 94       	cli
     c22:	0f 92       	push	r0
						xPollingProducerCount++;
     c24:	80 91 29 02 	lds	r24, 0x0229
     c28:	8f 5f       	subi	r24, 0xFF	; 255
     c2a:	80 93 29 02 	sts	0x0229, r24
					portEXIT_CRITICAL();
     c2e:	0f 90       	pop	r0
     c30:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	9a 81       	ldd	r25, Y+2	; 0x02
     c36:	01 96       	adiw	r24, 0x01	; 1
     c38:	9a 83       	std	Y+2, r25	; 0x02
     c3a:	89 83       	std	Y+1, r24	; 0x01
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     c3c:	1f 5f       	subi	r17, 0xFF	; 255
     c3e:	13 30       	cpi	r17, 0x03	; 3
     c40:	fc f2       	brlt	.-66     	; 0xc00 <vPolledQueueProducer+0x2a>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     c42:	88 ec       	ldi	r24, 0xC8	; 200
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
     c4a:	10 e0       	ldi	r17, 0x00	; 0
     c4c:	d9 cf       	rjmp	.-78     	; 0xc00 <vPolledQueueProducer+0x2a>

00000c4e <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     c4e:	9f 92       	push	r9
     c50:	af 92       	push	r10
     c52:	bf 92       	push	r11
     c54:	cf 92       	push	r12
     c56:	df 92       	push	r13
     c58:	ef 92       	push	r14
     c5a:	ff 92       	push	r15
     c5c:	0f 93       	push	r16
     c5e:	1f 93       	push	r17
     c60:	df 93       	push	r29
     c62:	cf 93       	push	r28
     c64:	00 d0       	rcall	.+0      	; 0xc66 <vPolledQueueConsumer+0x18>
     c66:	cd b7       	in	r28, 0x3d	; 61
     c68:	de b7       	in	r29, 0x3e	; 62
     c6a:	98 2e       	mov	r9, r24
     c6c:	c9 2e       	mov	r12, r25
     c6e:	ee 24       	eor	r14, r14
     c70:	ff 24       	eor	r15, r15
     c72:	dd 24       	eor	r13, r13
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     c74:	5e 01       	movw	r10, r28
     c76:	08 94       	sec
     c78:	a1 1c       	adc	r10, r1
     c7a:	b1 1c       	adc	r11, r1
     c7c:	23 c0       	rjmp	.+70     	; 0xcc4 <vPolledQueueConsumer+0x76>
     c7e:	f8 01       	movw	r30, r16
     c80:	80 81       	ld	r24, Z
     c82:	91 81       	ldd	r25, Z+1	; 0x01
     c84:	b5 01       	movw	r22, r10
     c86:	40 e0       	ldi	r20, 0x00	; 0
     c88:	50 e0       	ldi	r21, 0x00	; 0
     c8a:	20 e0       	ldi	r18, 0x00	; 0
     c8c:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <xQueueGenericReceive>
     c90:	81 30       	cpi	r24, 0x01	; 1
     c92:	c1 f4       	brne	.+48     	; 0xcc4 <vPolledQueueConsumer+0x76>
			{
				if( usData != usExpectedValue )
     c94:	29 81       	ldd	r18, Y+1	; 0x01
     c96:	3a 81       	ldd	r19, Y+2	; 0x02
     c98:	2e 15       	cp	r18, r14
     c9a:	3f 05       	cpc	r19, r15
     c9c:	19 f0       	breq	.+6      	; 0xca4 <vPolledQueueConsumer+0x56>
     c9e:	dd 24       	eor	r13, r13
     ca0:	d3 94       	inc	r13
     ca2:	0c c0       	rjmp	.+24     	; 0xcbc <vPolledQueueConsumer+0x6e>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
     ca4:	dd 20       	and	r13, r13
     ca6:	51 f4       	brne	.+20     	; 0xcbc <vPolledQueueConsumer+0x6e>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	0f 92       	push	r0
							xPollingConsumerCount++;
     cae:	80 91 28 02 	lds	r24, 0x0228
     cb2:	8f 5f       	subi	r24, 0xFF	; 255
     cb4:	80 93 28 02 	sts	0x0228, r24
						portEXIT_CRITICAL();
     cb8:	0f 90       	pop	r0
     cba:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     cbc:	79 01       	movw	r14, r18
     cbe:	08 94       	sec
     cc0:	e1 1c       	adc	r14, r1
     cc2:	f1 1c       	adc	r15, r1
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
     cc4:	09 2d       	mov	r16, r9
     cc6:	1c 2d       	mov	r17, r12
     cc8:	f8 01       	movw	r30, r16
     cca:	80 81       	ld	r24, Z
     ccc:	91 81       	ldd	r25, Z+1	; 0x01
     cce:	0e 94 4f 0c 	call	0x189e	; 0x189e <uxQueueMessagesWaiting>
     cd2:	88 23       	and	r24, r24
     cd4:	a1 f6       	brne	.-88     	; 0xc7e <vPolledQueueConsumer+0x30>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
     cd6:	84 eb       	ldi	r24, 0xB4	; 180
     cd8:	90 e0       	ldi	r25, 0x00	; 0
     cda:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
     cde:	f2 cf       	rjmp	.-28     	; 0xcc4 <vPolledQueueConsumer+0x76>

00000ce0 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     ce0:	ef 92       	push	r14
     ce2:	ff 92       	push	r15
     ce4:	0f 93       	push	r16
     ce6:	1f 93       	push	r17
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     ce8:	dc 01       	movw	r26, r24
     cea:	15 96       	adiw	r26, 0x05	; 5
     cec:	ed 91       	ld	r30, X+
     cee:	fc 91       	ld	r31, X
     cf0:	16 97       	sbiw	r26, 0x06	; 6
     cf2:	e6 80       	ldd	r14, Z+6	; 0x06
     cf4:	f7 80       	ldd	r15, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     cf6:	87 01       	movw	r16, r14
     cf8:	04 5f       	subi	r16, 0xF4	; 244
     cfa:	1f 4f       	sbci	r17, 0xFF	; 255
     cfc:	c8 01       	movw	r24, r16
     cfe:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     d02:	8d e5       	ldi	r24, 0x5D	; 93
     d04:	92 e0       	ldi	r25, 0x02	; 2
     d06:	b8 01       	movw	r22, r16
     d08:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>
     d0c:	20 e0       	ldi	r18, 0x00	; 0
     d0e:	e0 91 2c 02 	lds	r30, 0x022C
     d12:	f0 91 2d 02 	lds	r31, 0x022D
     d16:	d7 01       	movw	r26, r14
     d18:	56 96       	adiw	r26, 0x16	; 22
     d1a:	9c 91       	ld	r25, X
     d1c:	86 89       	ldd	r24, Z+22	; 0x16
     d1e:	98 17       	cp	r25, r24
     d20:	08 f0       	brcs	.+2      	; 0xd24 <xCoRoutineRemoveFromEventList+0x44>
     d22:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     d24:	82 2f       	mov	r24, r18
     d26:	1f 91       	pop	r17
     d28:	0f 91       	pop	r16
     d2a:	ff 90       	pop	r15
     d2c:	ef 90       	pop	r14
     d2e:	08 95       	ret

00000d30 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     d30:	ff 92       	push	r15
     d32:	0f 93       	push	r16
     d34:	1f 93       	push	r17
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     d3a:	99 e0       	ldi	r25, 0x09	; 9
     d3c:	f9 2e       	mov	r15, r25
     d3e:	21 c0       	rjmp	.+66     	; 0xd82 <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     d40:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     d42:	e0 91 62 02 	lds	r30, 0x0262
     d46:	f0 91 63 02 	lds	r31, 0x0263
     d4a:	06 81       	ldd	r16, Z+6	; 0x06
     d4c:	17 81       	ldd	r17, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d4e:	c8 01       	movw	r24, r16
     d50:	0c 96       	adiw	r24, 0x0c	; 12
     d52:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     d56:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     d58:	e8 01       	movw	r28, r16
     d5a:	22 96       	adiw	r28, 0x02	; 2
     d5c:	ce 01       	movw	r24, r28
     d5e:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     d62:	f8 01       	movw	r30, r16
     d64:	96 89       	ldd	r25, Z+22	; 0x16
     d66:	80 91 2e 02 	lds	r24, 0x022E
     d6a:	89 17       	cp	r24, r25
     d6c:	10 f4       	brcc	.+4      	; 0xd72 <vCoRoutineSchedule+0x42>
     d6e:	90 93 2e 02 	sts	0x022E, r25
     d72:	9f 9d       	mul	r25, r15
     d74:	c0 01       	movw	r24, r0
     d76:	11 24       	eor	r1, r1
     d78:	8b 5c       	subi	r24, 0xCB	; 203
     d7a:	9d 4f       	sbci	r25, 0xFD	; 253
     d7c:	be 01       	movw	r22, r28
     d7e:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     d82:	80 91 5d 02 	lds	r24, 0x025D
     d86:	88 23       	and	r24, r24
     d88:	d9 f6       	brne	.-74     	; 0xd40 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     d8a:	0e 94 4b 10 	call	0x2096	; 0x2096 <xTaskGetTickCount>
     d8e:	20 91 2f 02 	lds	r18, 0x022F
     d92:	30 91 30 02 	lds	r19, 0x0230
     d96:	82 1b       	sub	r24, r18
     d98:	93 0b       	sbc	r25, r19
     d9a:	90 93 32 02 	sts	0x0232, r25
     d9e:	80 93 31 02 	sts	0x0231, r24
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
     da2:	89 e0       	ldi	r24, 0x09	; 9
     da4:	f8 2e       	mov	r15, r24
     da6:	53 c0       	rjmp	.+166    	; 0xe4e <vCoRoutineSchedule+0x11e>
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     da8:	01 96       	adiw	r24, 0x01	; 1
     daa:	90 93 34 02 	sts	0x0234, r25
     dae:	80 93 33 02 	sts	0x0233, r24
		xPassedTicks--;
     db2:	21 50       	subi	r18, 0x01	; 1
     db4:	30 40       	sbci	r19, 0x00	; 0
     db6:	30 93 32 02 	sts	0x0232, r19
     dba:	20 93 31 02 	sts	0x0231, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     dbe:	89 2b       	or	r24, r25
     dc0:	09 f0       	breq	.+2      	; 0xdc4 <vCoRoutineSchedule+0x94>
     dc2:	3e c0       	rjmp	.+124    	; 0xe40 <vCoRoutineSchedule+0x110>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     dc4:	20 91 59 02 	lds	r18, 0x0259
     dc8:	30 91 5a 02 	lds	r19, 0x025A
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     dcc:	80 91 5b 02 	lds	r24, 0x025B
     dd0:	90 91 5c 02 	lds	r25, 0x025C
     dd4:	90 93 5a 02 	sts	0x025A, r25
     dd8:	80 93 59 02 	sts	0x0259, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     ddc:	30 93 5c 02 	sts	0x025C, r19
     de0:	20 93 5b 02 	sts	0x025B, r18
     de4:	2d c0       	rjmp	.+90     	; 0xe40 <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     de6:	05 80       	ldd	r0, Z+5	; 0x05
     de8:	f6 81       	ldd	r31, Z+6	; 0x06
     dea:	e0 2d       	mov	r30, r0
     dec:	c6 81       	ldd	r28, Z+6	; 0x06
     dee:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     df0:	20 91 33 02 	lds	r18, 0x0233
     df4:	30 91 34 02 	lds	r19, 0x0234
     df8:	8a 81       	ldd	r24, Y+2	; 0x02
     dfa:	9b 81       	ldd	r25, Y+3	; 0x03
     dfc:	28 17       	cp	r18, r24
     dfe:	39 07       	cpc	r19, r25
     e00:	30 f1       	brcs	.+76     	; 0xe4e <vCoRoutineSchedule+0x11e>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     e02:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     e04:	8e 01       	movw	r16, r28
     e06:	0e 5f       	subi	r16, 0xFE	; 254
     e08:	1f 4f       	sbci	r17, 0xFF	; 255
     e0a:	c8 01       	movw	r24, r16
     e0c:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     e10:	8c 89       	ldd	r24, Y+20	; 0x14
     e12:	9d 89       	ldd	r25, Y+21	; 0x15
     e14:	89 2b       	or	r24, r25
     e16:	21 f0       	breq	.+8      	; 0xe20 <vCoRoutineSchedule+0xf0>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     e18:	ce 01       	movw	r24, r28
     e1a:	0c 96       	adiw	r24, 0x0c	; 12
     e1c:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     e20:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     e22:	9e 89       	ldd	r25, Y+22	; 0x16
     e24:	80 91 2e 02 	lds	r24, 0x022E
     e28:	89 17       	cp	r24, r25
     e2a:	10 f4       	brcc	.+4      	; 0xe30 <vCoRoutineSchedule+0x100>
     e2c:	90 93 2e 02 	sts	0x022E, r25
     e30:	9f 9d       	mul	r25, r15
     e32:	c0 01       	movw	r24, r0
     e34:	11 24       	eor	r1, r1
     e36:	8b 5c       	subi	r24, 0xCB	; 203
     e38:	9d 4f       	sbci	r25, 0xFD	; 253
     e3a:	b8 01       	movw	r22, r16
     e3c:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     e40:	e0 91 59 02 	lds	r30, 0x0259
     e44:	f0 91 5a 02 	lds	r31, 0x025A
     e48:	80 81       	ld	r24, Z
     e4a:	88 23       	and	r24, r24
     e4c:	61 f6       	brne	.-104    	; 0xde6 <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     e4e:	20 91 31 02 	lds	r18, 0x0231
     e52:	30 91 32 02 	lds	r19, 0x0232
     e56:	80 91 33 02 	lds	r24, 0x0233
     e5a:	90 91 34 02 	lds	r25, 0x0234
     e5e:	21 15       	cp	r18, r1
     e60:	31 05       	cpc	r19, r1
     e62:	09 f0       	breq	.+2      	; 0xe66 <vCoRoutineSchedule+0x136>
     e64:	a1 cf       	rjmp	.-190    	; 0xda8 <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     e66:	90 93 30 02 	sts	0x0230, r25
     e6a:	80 93 2f 02 	sts	0x022F, r24
     e6e:	90 91 2e 02 	lds	r25, 0x022E

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     e72:	29 e0       	ldi	r18, 0x09	; 9
     e74:	06 c0       	rjmp	.+12     	; 0xe82 <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     e76:	99 23       	and	r25, r25
     e78:	19 f4       	brne	.+6      	; 0xe80 <vCoRoutineSchedule+0x150>
     e7a:	10 92 2e 02 	sts	0x022E, r1
     e7e:	32 c0       	rjmp	.+100    	; 0xee4 <vCoRoutineSchedule+0x1b4>
     e80:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     e82:	92 9f       	mul	r25, r18
     e84:	d0 01       	movw	r26, r0
     e86:	11 24       	eor	r1, r1
     e88:	ab 5c       	subi	r26, 0xCB	; 203
     e8a:	bd 4f       	sbci	r27, 0xFD	; 253
     e8c:	8c 91       	ld	r24, X
     e8e:	88 23       	and	r24, r24
     e90:	91 f3       	breq	.-28     	; 0xe76 <vCoRoutineSchedule+0x146>
     e92:	90 93 2e 02 	sts	0x022E, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     e96:	11 96       	adiw	r26, 0x01	; 1
     e98:	ed 91       	ld	r30, X+
     e9a:	fc 91       	ld	r31, X
     e9c:	12 97       	sbiw	r26, 0x02	; 2
     e9e:	02 80       	ldd	r0, Z+2	; 0x02
     ea0:	f3 81       	ldd	r31, Z+3	; 0x03
     ea2:	e0 2d       	mov	r30, r0
     ea4:	12 96       	adiw	r26, 0x02	; 2
     ea6:	fc 93       	st	X, r31
     ea8:	ee 93       	st	-X, r30
     eaa:	11 97       	sbiw	r26, 0x01	; 1
     eac:	cd 01       	movw	r24, r26
     eae:	03 96       	adiw	r24, 0x03	; 3
     eb0:	e8 17       	cp	r30, r24
     eb2:	f9 07       	cpc	r31, r25
     eb4:	31 f4       	brne	.+12     	; 0xec2 <vCoRoutineSchedule+0x192>
     eb6:	82 81       	ldd	r24, Z+2	; 0x02
     eb8:	93 81       	ldd	r25, Z+3	; 0x03
     eba:	12 96       	adiw	r26, 0x02	; 2
     ebc:	9c 93       	st	X, r25
     ebe:	8e 93       	st	-X, r24
     ec0:	11 97       	sbiw	r26, 0x01	; 1
     ec2:	11 96       	adiw	r26, 0x01	; 1
     ec4:	ed 91       	ld	r30, X+
     ec6:	fc 91       	ld	r31, X
     ec8:	12 97       	sbiw	r26, 0x02	; 2
     eca:	06 80       	ldd	r0, Z+6	; 0x06
     ecc:	f7 81       	ldd	r31, Z+7	; 0x07
     ece:	e0 2d       	mov	r30, r0
     ed0:	f0 93 2d 02 	sts	0x022D, r31
     ed4:	e0 93 2c 02 	sts	0x022C, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     ed8:	20 81       	ld	r18, Z
     eda:	31 81       	ldd	r19, Z+1	; 0x01
     edc:	cf 01       	movw	r24, r30
     ede:	67 89       	ldd	r22, Z+23	; 0x17
     ee0:	f9 01       	movw	r30, r18
     ee2:	09 95       	icall

	return;
}
     ee4:	df 91       	pop	r29
     ee6:	cf 91       	pop	r28
     ee8:	1f 91       	pop	r17
     eea:	0f 91       	pop	r16
     eec:	ff 90       	pop	r15
     eee:	08 95       	ret

00000ef0 <vCoRoutineAddToDelayedList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     ef0:	0f 93       	push	r16
     ef2:	1f 93       	push	r17
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	eb 01       	movw	r28, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     efa:	00 91 33 02 	lds	r16, 0x0233
     efe:	10 91 34 02 	lds	r17, 0x0234
     f02:	08 0f       	add	r16, r24
     f04:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     f06:	80 91 2c 02 	lds	r24, 0x022C
     f0a:	90 91 2d 02 	lds	r25, 0x022D
     f0e:	02 96       	adiw	r24, 0x02	; 2
     f10:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     f14:	e0 91 2c 02 	lds	r30, 0x022C
     f18:	f0 91 2d 02 	lds	r31, 0x022D
     f1c:	13 83       	std	Z+3, r17	; 0x03
     f1e:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     f20:	80 91 33 02 	lds	r24, 0x0233
     f24:	90 91 34 02 	lds	r25, 0x0234
     f28:	bf 01       	movw	r22, r30
     f2a:	6e 5f       	subi	r22, 0xFE	; 254
     f2c:	7f 4f       	sbci	r23, 0xFF	; 255
     f2e:	08 17       	cp	r16, r24
     f30:	19 07       	cpc	r17, r25
     f32:	28 f4       	brcc	.+10     	; 0xf3e <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     f34:	80 91 5b 02 	lds	r24, 0x025B
     f38:	90 91 5c 02 	lds	r25, 0x025C
     f3c:	04 c0       	rjmp	.+8      	; 0xf46 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     f3e:	80 91 59 02 	lds	r24, 0x0259
     f42:	90 91 5a 02 	lds	r25, 0x025A
     f46:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInsert>
	}

	if( pxEventList )
     f4a:	20 97       	sbiw	r28, 0x00	; 0
     f4c:	49 f0       	breq	.+18     	; 0xf60 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     f4e:	60 91 2c 02 	lds	r22, 0x022C
     f52:	70 91 2d 02 	lds	r23, 0x022D
     f56:	64 5f       	subi	r22, 0xF4	; 244
     f58:	7f 4f       	sbci	r23, 0xFF	; 255
     f5a:	ce 01       	movw	r24, r28
     f5c:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInsert>
	}
}
     f60:	df 91       	pop	r29
     f62:	cf 91       	pop	r28
     f64:	1f 91       	pop	r17
     f66:	0f 91       	pop	r16
     f68:	08 95       	ret

00000f6a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     f6a:	af 92       	push	r10
     f6c:	bf 92       	push	r11
     f6e:	cf 92       	push	r12
     f70:	df 92       	push	r13
     f72:	ef 92       	push	r14
     f74:	ff 92       	push	r15
     f76:	0f 93       	push	r16
     f78:	1f 93       	push	r17
     f7a:	cf 93       	push	r28
     f7c:	df 93       	push	r29
     f7e:	6c 01       	movw	r12, r24
     f80:	b6 2e       	mov	r11, r22
     f82:	a4 2e       	mov	r10, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     f84:	8a e1       	ldi	r24, 0x1A	; 26
     f86:	90 e0       	ldi	r25, 0x00	; 0
     f88:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <pvPortMalloc>
     f8c:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     f8e:	00 97       	sbiw	r24, 0x00	; 0
     f90:	11 f4       	brne	.+4      	; 0xf96 <xCoRoutineCreate+0x2c>
     f92:	8f ef       	ldi	r24, 0xFF	; 255
     f94:	59 c0       	rjmp	.+178    	; 0x1048 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     f96:	80 91 2c 02 	lds	r24, 0x022C
     f9a:	90 91 2d 02 	lds	r25, 0x022D
     f9e:	89 2b       	or	r24, r25
     fa0:	21 f5       	brne	.+72     	; 0xfea <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     fa2:	d0 93 2d 02 	sts	0x022D, r29
     fa6:	c0 93 2c 02 	sts	0x022C, r28
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     faa:	85 e3       	ldi	r24, 0x35	; 53
     fac:	92 e0       	ldi	r25, 0x02	; 2
     fae:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
     fb2:	8e e3       	ldi	r24, 0x3E	; 62
     fb4:	92 e0       	ldi	r25, 0x02	; 2
     fb6:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     fba:	27 e4       	ldi	r18, 0x47	; 71
     fbc:	e2 2e       	mov	r14, r18
     fbe:	22 e0       	ldi	r18, 0x02	; 2
     fc0:	f2 2e       	mov	r15, r18
     fc2:	c7 01       	movw	r24, r14
     fc4:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     fc8:	00 e5       	ldi	r16, 0x50	; 80
     fca:	12 e0       	ldi	r17, 0x02	; 2
     fcc:	c8 01       	movw	r24, r16
     fce:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     fd2:	8d e5       	ldi	r24, 0x5D	; 93
     fd4:	92 e0       	ldi	r25, 0x02	; 2
     fd6:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     fda:	f0 92 5a 02 	sts	0x025A, r15
     fde:	e0 92 59 02 	sts	0x0259, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     fe2:	10 93 5c 02 	sts	0x025C, r17
     fe6:	00 93 5b 02 	sts	0x025B, r16
     fea:	eb 2c       	mov	r14, r11
     fec:	bb 20       	and	r11, r11
     fee:	11 f0       	breq	.+4      	; 0xff4 <xCoRoutineCreate+0x8a>
     ff0:	ee 24       	eor	r14, r14
     ff2:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     ff4:	19 8e       	std	Y+25, r1	; 0x19
     ff6:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     ff8:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     ffa:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     ffc:	fe 01       	movw	r30, r28
     ffe:	c1 92       	st	Z+, r12
    1000:	d1 92       	st	Z+, r13
    1002:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1004:	cf 01       	movw	r24, r30
    1006:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    100a:	ce 01       	movw	r24, r28
    100c:	0c 96       	adiw	r24, 0x0c	; 12
    100e:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1012:	d9 87       	std	Y+9, r29	; 0x09
    1014:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1016:	db 8b       	std	Y+19, r29	; 0x13
    1018:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    101a:	82 e0       	ldi	r24, 0x02	; 2
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	8e 19       	sub	r24, r14
    1020:	91 09       	sbc	r25, r1
    1022:	9d 87       	std	Y+13, r25	; 0x0d
    1024:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1026:	9e 89       	ldd	r25, Y+22	; 0x16
    1028:	80 91 2e 02 	lds	r24, 0x022E
    102c:	89 17       	cp	r24, r25
    102e:	10 f4       	brcc	.+4      	; 0x1034 <xCoRoutineCreate+0xca>
    1030:	90 93 2e 02 	sts	0x022E, r25
    1034:	89 e0       	ldi	r24, 0x09	; 9
    1036:	98 9f       	mul	r25, r24
    1038:	c0 01       	movw	r24, r0
    103a:	11 24       	eor	r1, r1
    103c:	8b 5c       	subi	r24, 0xCB	; 203
    103e:	9d 4f       	sbci	r25, 0xFD	; 253
    1040:	b8 01       	movw	r22, r16
    1042:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>
    1046:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	return xReturn;
}
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	1f 91       	pop	r17
    104e:	0f 91       	pop	r16
    1050:	ff 90       	pop	r15
    1052:	ef 90       	pop	r14
    1054:	df 90       	pop	r13
    1056:	cf 90       	pop	r12
    1058:	bf 90       	pop	r11
    105a:	af 90       	pop	r10
    105c:	08 95       	ret

0000105e <xEventGroupClearBits>:
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    105e:	fc 01       	movw	r30, r24

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1060:	0f b6       	in	r0, 0x3f	; 63
    1062:	f8 94       	cli
    1064:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1066:	20 81       	ld	r18, Z
    1068:	31 81       	ldd	r19, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    106a:	60 95       	com	r22
    106c:	70 95       	com	r23
    106e:	62 23       	and	r22, r18
    1070:	73 23       	and	r23, r19
    1072:	71 83       	std	Z+1, r23	; 0x01
    1074:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
    1076:	0f 90       	pop	r0
    1078:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    107a:	c9 01       	movw	r24, r18
    107c:	08 95       	ret

0000107e <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    107e:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
    1080:	80 81       	ld	r24, Z
    1082:	91 81       	ldd	r25, Z+1	; 0x01
    1084:	08 95       	ret

00001086 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    1086:	ba 01       	movw	r22, r20
    1088:	0e 94 2f 08 	call	0x105e	; 0x105e <xEventGroupClearBits>
}
    108c:	08 95       	ret

0000108e <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    108e:	cf 93       	push	r28
    1090:	df 93       	push	r29
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1092:	ec 01       	movw	r28, r24
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
    1094:	0e 94 45 10 	call	0x208a	; 0x208a <vTaskSuspendAll>
    1098:	06 c0       	rjmp	.+12     	; 0x10a6 <vEventGroupDelete+0x18>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    109a:	8f 81       	ldd	r24, Y+7	; 0x07
    109c:	98 85       	ldd	r25, Y+8	; 0x08
    109e:	60 e0       	ldi	r22, 0x00	; 0
    10a0:	72 e0       	ldi	r23, 0x02	; 2
    10a2:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    10a6:	8a 81       	ldd	r24, Y+2	; 0x02
    10a8:	88 23       	and	r24, r24
    10aa:	b9 f7       	brne	.-18     	; 0x109a <vEventGroupDelete+0xc>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    10ac:	ce 01       	movw	r24, r28
    10ae:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortFree>
	}
	( void ) xTaskResumeAll();
    10b2:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
}
    10b6:	df 91       	pop	r29
    10b8:	cf 91       	pop	r28
    10ba:	08 95       	ret

000010bc <xEventGroupSetBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    10bc:	cf 92       	push	r12
    10be:	df 92       	push	r13
    10c0:	ef 92       	push	r14
    10c2:	ff 92       	push	r15
    10c4:	0f 93       	push	r16
    10c6:	1f 93       	push	r17
    10c8:	cf 93       	push	r28
    10ca:	df 93       	push	r29
    10cc:	8b 01       	movw	r16, r22
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    10ce:	ec 01       	movw	r28, r24
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    10d0:	85 e0       	ldi	r24, 0x05	; 5
    10d2:	e8 2e       	mov	r14, r24
    10d4:	f1 2c       	mov	r15, r1
    10d6:	ec 0e       	add	r14, r28
    10d8:	fd 1e       	adc	r15, r29
	vTaskSuspendAll();
    10da:	0e 94 45 10 	call	0x208a	; 0x208a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    10de:	ef 81       	ldd	r30, Y+7	; 0x07
    10e0:	f8 85       	ldd	r31, Y+8	; 0x08

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    10e2:	88 81       	ld	r24, Y
    10e4:	99 81       	ldd	r25, Y+1	; 0x01
    10e6:	80 2b       	or	r24, r16
    10e8:	91 2b       	or	r25, r17
    10ea:	99 83       	std	Y+1, r25	; 0x01
    10ec:	88 83       	st	Y, r24
    10ee:	00 e0       	ldi	r16, 0x00	; 0
    10f0:	10 e0       	ldi	r17, 0x00	; 0
    10f2:	24 c0       	rjmp	.+72     	; 0x113c <xEventGroupSetBits+0x80>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    10f4:	d2 80       	ldd	r13, Z+2	; 0x02
    10f6:	c3 80       	ldd	r12, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    10f8:	80 81       	ld	r24, Z
    10fa:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    10fc:	bc 01       	movw	r22, r24
    10fe:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1100:	ac 01       	movw	r20, r24
    1102:	50 70       	andi	r21, 0x00	; 0
    1104:	28 81       	ld	r18, Y
    1106:	39 81       	ldd	r19, Y+1	; 0x01

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1108:	92 fd       	sbrc	r25, 2
    110a:	05 c0       	rjmp	.+10     	; 0x1116 <xEventGroupSetBits+0x5a>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    110c:	24 23       	and	r18, r20
    110e:	35 23       	and	r19, r21
    1110:	23 2b       	or	r18, r19
    1112:	31 f4       	brne	.+12     	; 0x1120 <xEventGroupSetBits+0x64>
    1114:	0f c0       	rjmp	.+30     	; 0x1134 <xEventGroupSetBits+0x78>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1116:	24 23       	and	r18, r20
    1118:	35 23       	and	r19, r21
    111a:	24 17       	cp	r18, r20
    111c:	35 07       	cpc	r19, r21
    111e:	51 f4       	brne	.+20     	; 0x1134 <xEventGroupSetBits+0x78>
			}

			if( xMatchFound != pdFALSE )
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1120:	70 ff       	sbrs	r23, 0
    1122:	02 c0       	rjmp	.+4      	; 0x1128 <xEventGroupSetBits+0x6c>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    1124:	04 2b       	or	r16, r20
    1126:	15 2b       	or	r17, r21
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1128:	68 81       	ld	r22, Y
    112a:	79 81       	ldd	r23, Y+1	; 0x01
    112c:	72 60       	ori	r23, 0x02	; 2
    112e:	cf 01       	movw	r24, r30
    1130:	0e 94 02 11 	call	0x2204	; 0x2204 <xTaskRemoveFromUnorderedEventList>
    1134:	8d 2d       	mov	r24, r13
    1136:	9c 2d       	mov	r25, r12
    1138:	9c 01       	movw	r18, r24
    113a:	f9 01       	movw	r30, r18

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    113c:	ee 15       	cp	r30, r14
    113e:	ff 05       	cpc	r31, r15
    1140:	c9 f6       	brne	.-78     	; 0x10f4 <xEventGroupSetBits+0x38>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1142:	00 95       	com	r16
    1144:	10 95       	com	r17
    1146:	88 81       	ld	r24, Y
    1148:	99 81       	ldd	r25, Y+1	; 0x01
    114a:	80 23       	and	r24, r16
    114c:	91 23       	and	r25, r17
    114e:	99 83       	std	Y+1, r25	; 0x01
    1150:	88 83       	st	Y, r24
	}
	( void ) xTaskResumeAll();
    1152:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
    1156:	88 81       	ld	r24, Y
    1158:	99 81       	ldd	r25, Y+1	; 0x01
    115a:	df 91       	pop	r29
    115c:	cf 91       	pop	r28
    115e:	1f 91       	pop	r17
    1160:	0f 91       	pop	r16
    1162:	ff 90       	pop	r15
    1164:	ef 90       	pop	r14
    1166:	df 90       	pop	r13
    1168:	cf 90       	pop	r12
    116a:	08 95       	ret

0000116c <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    116c:	ba 01       	movw	r22, r20
    116e:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
}
    1172:	08 95       	ret

00001174 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    1174:	af 92       	push	r10
    1176:	bf 92       	push	r11
    1178:	cf 92       	push	r12
    117a:	df 92       	push	r13
    117c:	ef 92       	push	r14
    117e:	ff 92       	push	r15
    1180:	0f 93       	push	r16
    1182:	1f 93       	push	r17
    1184:	cf 93       	push	r28
    1186:	df 93       	push	r29
    1188:	7b 01       	movw	r14, r22
    118a:	a4 2e       	mov	r10, r20
    118c:	b2 2e       	mov	r11, r18
    118e:	68 01       	movw	r12, r16
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1190:	8c 01       	movw	r16, r24
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1192:	0e 94 45 10 	call	0x208a	; 0x208a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1196:	f8 01       	movw	r30, r16
    1198:	20 81       	ld	r18, Z
    119a:	31 81       	ldd	r19, Z+1	; 0x01
    119c:	c7 01       	movw	r24, r14
    119e:	82 23       	and	r24, r18
    11a0:	93 23       	and	r25, r19

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
    11a2:	bb 20       	and	r11, r11
    11a4:	21 f4       	brne	.+8      	; 0x11ae <xEventGroupWaitBits+0x3a>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    11a6:	89 2b       	or	r24, r25
    11a8:	09 f0       	breq	.+2      	; 0x11ac <xEventGroupWaitBits+0x38>
    11aa:	5a c0       	rjmp	.+180    	; 0x1260 <xEventGroupWaitBits+0xec>
    11ac:	04 c0       	rjmp	.+8      	; 0x11b6 <xEventGroupWaitBits+0x42>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    11ae:	8e 15       	cp	r24, r14
    11b0:	9f 05       	cpc	r25, r15
    11b2:	09 f4       	brne	.+2      	; 0x11b6 <xEventGroupWaitBits+0x42>
    11b4:	55 c0       	rjmp	.+170    	; 0x1260 <xEventGroupWaitBits+0xec>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    11b6:	c1 14       	cp	r12, r1
    11b8:	d1 04       	cpc	r13, r1
    11ba:	59 f4       	brne	.+22     	; 0x11d2 <xEventGroupWaitBits+0x5e>
    11bc:	e9 01       	movw	r28, r18
    11be:	1b c0       	rjmp	.+54     	; 0x11f6 <xEventGroupWaitBits+0x82>
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    11c0:	c7 01       	movw	r24, r14
    11c2:	80 95       	com	r24
    11c4:	90 95       	com	r25
    11c6:	82 23       	and	r24, r18
    11c8:	93 23       	and	r25, r19
    11ca:	f8 01       	movw	r30, r16
    11cc:	91 83       	std	Z+1, r25	; 0x01
    11ce:	80 83       	st	Z, r24
    11d0:	4a c0       	rjmp	.+148    	; 0x1266 <xEventGroupWaitBits+0xf2>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    11d2:	aa 20       	and	r10, r10
    11d4:	19 f0       	breq	.+6      	; 0x11dc <xEventGroupWaitBits+0x68>
    11d6:	60 e0       	ldi	r22, 0x00	; 0
    11d8:	71 e0       	ldi	r23, 0x01	; 1
    11da:	02 c0       	rjmp	.+4      	; 0x11e0 <xEventGroupWaitBits+0x6c>
    11dc:	60 e0       	ldi	r22, 0x00	; 0
    11de:	70 e0       	ldi	r23, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    11e0:	b1 10       	cpse	r11, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    11e2:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    11e4:	6e 29       	or	r22, r14
    11e6:	7f 29       	or	r23, r15
    11e8:	c8 01       	movw	r24, r16
    11ea:	02 96       	adiw	r24, 0x02	; 2
    11ec:	a6 01       	movw	r20, r12
    11ee:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskPlaceOnUnorderedEventList>
    11f2:	c0 e0       	ldi	r28, 0x00	; 0
    11f4:	d0 e0       	ldi	r29, 0x00	; 0
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    11f6:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
    11fa:	cd 28       	or	r12, r13
    11fc:	29 f1       	breq	.+74     	; 0x1248 <xEventGroupWaitBits+0xd4>
	{
		if( xAlreadyYielded == pdFALSE )
    11fe:	88 23       	and	r24, r24
    1200:	11 f4       	brne	.+4      	; 0x1206 <xEventGroupWaitBits+0x92>
		{
			portYIELD_WITHIN_API();
    1202:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1206:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    120a:	91 fd       	sbrc	r25, 1
    120c:	1b c0       	rjmp	.+54     	; 0x1244 <xEventGroupWaitBits+0xd0>
		{
			taskENTER_CRITICAL();
    120e:	0f b6       	in	r0, 0x3f	; 63
    1210:	f8 94       	cli
    1212:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1214:	f8 01       	movw	r30, r16
    1216:	80 81       	ld	r24, Z
    1218:	91 81       	ldd	r25, Z+1	; 0x01
    121a:	97 01       	movw	r18, r14
    121c:	28 23       	and	r18, r24
    121e:	39 23       	and	r19, r25

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
    1220:	bb 20       	and	r11, r11
    1222:	19 f4       	brne	.+6      	; 0x122a <xEventGroupWaitBits+0xb6>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1224:	23 2b       	or	r18, r19
    1226:	19 f5       	brne	.+70     	; 0x126e <xEventGroupWaitBits+0xfa>
    1228:	0b c0       	rjmp	.+22     	; 0x1240 <xEventGroupWaitBits+0xcc>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    122a:	2e 15       	cp	r18, r14
    122c:	3f 05       	cpc	r19, r15
    122e:	41 f4       	brne	.+16     	; 0x1240 <xEventGroupWaitBits+0xcc>
    1230:	1e c0       	rjmp	.+60     	; 0x126e <xEventGroupWaitBits+0xfa>
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
				{
					if( xClearOnExit != pdFALSE )
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1232:	e0 94       	com	r14
    1234:	f0 94       	com	r15
    1236:	e8 22       	and	r14, r24
    1238:	f9 22       	and	r15, r25
    123a:	f8 01       	movw	r30, r16
    123c:	f1 82       	std	Z+1, r15	; 0x01
    123e:	e0 82       	st	Z, r14
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1240:	0f 90       	pop	r0
    1242:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1244:	ec 01       	movw	r28, r24
    1246:	d0 70       	andi	r29, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
    1248:	ce 01       	movw	r24, r28
    124a:	df 91       	pop	r29
    124c:	cf 91       	pop	r28
    124e:	1f 91       	pop	r17
    1250:	0f 91       	pop	r16
    1252:	ff 90       	pop	r15
    1254:	ef 90       	pop	r14
    1256:	df 90       	pop	r13
    1258:	cf 90       	pop	r12
    125a:	bf 90       	pop	r11
    125c:	af 90       	pop	r10
    125e:	08 95       	ret
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    1260:	aa 20       	and	r10, r10
    1262:	09 f0       	breq	.+2      	; 0x1266 <xEventGroupWaitBits+0xf2>
    1264:	ad cf       	rjmp	.-166    	; 0x11c0 <xEventGroupWaitBits+0x4c>
    1266:	e9 01       	movw	r28, r18
    1268:	cc 24       	eor	r12, r12
    126a:	dd 24       	eor	r13, r13
    126c:	c4 cf       	rjmp	.-120    	; 0x11f6 <xEventGroupWaitBits+0x82>

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
				{
					if( xClearOnExit != pdFALSE )
    126e:	aa 20       	and	r10, r10
    1270:	01 f7       	brne	.-64     	; 0x1232 <xEventGroupWaitBits+0xbe>
    1272:	e6 cf       	rjmp	.-52     	; 0x1240 <xEventGroupWaitBits+0xcc>

00001274 <xEventGroupSync>:
	return ( EventGroupHandle_t ) pxEventBits;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1274:	8f 92       	push	r8
    1276:	9f 92       	push	r9
    1278:	af 92       	push	r10
    127a:	bf 92       	push	r11
    127c:	cf 92       	push	r12
    127e:	df 92       	push	r13
    1280:	ef 92       	push	r14
    1282:	ff 92       	push	r15
    1284:	0f 93       	push	r16
    1286:	1f 93       	push	r17
    1288:	cf 93       	push	r28
    128a:	df 93       	push	r29
    128c:	f8 2e       	mov	r15, r24
    128e:	e9 2e       	mov	r14, r25
    1290:	8b 01       	movw	r16, r22
    1292:	5a 01       	movw	r10, r20
    1294:	49 01       	movw	r8, r18
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1296:	c8 2e       	mov	r12, r24
    1298:	d9 2e       	mov	r13, r25
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    129a:	0e 94 45 10 	call	0x208a	; 0x208a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    129e:	f6 01       	movw	r30, r12
    12a0:	c0 81       	ld	r28, Z
    12a2:	d1 81       	ldd	r29, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    12a4:	8f 2d       	mov	r24, r15
    12a6:	9e 2d       	mov	r25, r14
    12a8:	b8 01       	movw	r22, r16
    12aa:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    12ae:	c0 2b       	or	r28, r16
    12b0:	d1 2b       	or	r29, r17
    12b2:	c5 01       	movw	r24, r10
    12b4:	8c 23       	and	r24, r28
    12b6:	9d 23       	and	r25, r29
    12b8:	8a 15       	cp	r24, r10
    12ba:	9b 05       	cpc	r25, r11
    12bc:	69 f4       	brne	.+26     	; 0x12d8 <xEventGroupSync+0x64>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    12be:	95 01       	movw	r18, r10
    12c0:	20 95       	com	r18
    12c2:	30 95       	com	r19
    12c4:	f6 01       	movw	r30, r12
    12c6:	80 81       	ld	r24, Z
    12c8:	91 81       	ldd	r25, Z+1	; 0x01
    12ca:	82 23       	and	r24, r18
    12cc:	93 23       	and	r25, r19
    12ce:	91 83       	std	Z+1, r25	; 0x01
    12d0:	80 83       	st	Z, r24
    12d2:	88 24       	eor	r8, r8
    12d4:	99 24       	eor	r9, r9
    12d6:	10 c0       	rjmp	.+32     	; 0x12f8 <xEventGroupSync+0x84>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    12d8:	81 14       	cp	r8, r1
    12da:	91 04       	cpc	r9, r1
    12dc:	51 f0       	breq	.+20     	; 0x12f2 <xEventGroupSync+0x7e>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    12de:	b5 01       	movw	r22, r10
    12e0:	75 60       	ori	r23, 0x05	; 5
    12e2:	c6 01       	movw	r24, r12
    12e4:	02 96       	adiw	r24, 0x02	; 2
    12e6:	a4 01       	movw	r20, r8
    12e8:	0e 94 77 12 	call	0x24ee	; 0x24ee <vTaskPlaceOnUnorderedEventList>
    12ec:	c0 e0       	ldi	r28, 0x00	; 0
    12ee:	d0 e0       	ldi	r29, 0x00	; 0
    12f0:	03 c0       	rjmp	.+6      	; 0x12f8 <xEventGroupSync+0x84>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    12f2:	f6 01       	movw	r30, r12
    12f4:	c0 81       	ld	r28, Z
    12f6:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    12f8:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
    12fc:	89 28       	or	r8, r9
    12fe:	f9 f0       	breq	.+62     	; 0x133e <xEventGroupSync+0xca>
	{
		if( xAlreadyYielded == pdFALSE )
    1300:	88 23       	and	r24, r24
    1302:	11 f4       	brne	.+4      	; 0x1308 <xEventGroupSync+0x94>
		{
			portYIELD_WITHIN_API();
    1304:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1308:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <uxTaskResetEventItemValue>
    130c:	9c 01       	movw	r18, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    130e:	91 fd       	sbrc	r25, 1
    1310:	14 c0       	rjmp	.+40     	; 0x133a <xEventGroupSync+0xc6>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1312:	0f b6       	in	r0, 0x3f	; 63
    1314:	f8 94       	cli
    1316:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1318:	f6 01       	movw	r30, r12
    131a:	20 81       	ld	r18, Z
    131c:	31 81       	ldd	r19, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    131e:	c5 01       	movw	r24, r10
    1320:	82 23       	and	r24, r18
    1322:	93 23       	and	r25, r19
    1324:	8a 15       	cp	r24, r10
    1326:	9b 05       	cpc	r25, r11
    1328:	31 f4       	brne	.+12     	; 0x1336 <xEventGroupSync+0xc2>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    132a:	a0 94       	com	r10
    132c:	b0 94       	com	r11
    132e:	a2 22       	and	r10, r18
    1330:	b3 22       	and	r11, r19
    1332:	b1 82       	std	Z+1, r11	; 0x01
    1334:	a0 82       	st	Z, r10
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1336:	0f 90       	pop	r0
    1338:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    133a:	e9 01       	movw	r28, r18
    133c:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
    133e:	ce 01       	movw	r24, r28
    1340:	df 91       	pop	r29
    1342:	cf 91       	pop	r28
    1344:	1f 91       	pop	r17
    1346:	0f 91       	pop	r16
    1348:	ff 90       	pop	r15
    134a:	ef 90       	pop	r14
    134c:	df 90       	pop	r13
    134e:	cf 90       	pop	r12
    1350:	bf 90       	pop	r11
    1352:	af 90       	pop	r10
    1354:	9f 90       	pop	r9
    1356:	8f 90       	pop	r8
    1358:	08 95       	ret

0000135a <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    135a:	cf 93       	push	r28
    135c:	df 93       	push	r29
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
    135e:	8b e0       	ldi	r24, 0x0B	; 11
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <pvPortMalloc>
    1366:	ec 01       	movw	r28, r24
	if( pxEventBits != NULL )
    1368:	00 97       	sbiw	r24, 0x00	; 0
    136a:	31 f0       	breq	.+12     	; 0x1378 <xEventGroupCreate+0x1e>
	{
		pxEventBits->uxEventBits = 0;
    136c:	fc 01       	movw	r30, r24
    136e:	11 92       	st	Z+, r1
    1370:	11 92       	st	Z+, r1
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1372:	cf 01       	movw	r24, r30
    1374:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
}
    1378:	ce 01       	movw	r24, r28
    137a:	df 91       	pop	r29
    137c:	cf 91       	pop	r28
    137e:	08 95       	ret

00001380 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1380:	08 95       	ret

00001382 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1382:	10 92 67 02 	sts	0x0267, r1
    1386:	10 92 66 02 	sts	0x0266, r1
}
    138a:	08 95       	ret

0000138c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    138c:	27 ee       	ldi	r18, 0xE7	; 231
    138e:	33 e0       	ldi	r19, 0x03	; 3
    1390:	80 91 66 02 	lds	r24, 0x0266
    1394:	90 91 67 02 	lds	r25, 0x0267
    1398:	28 1b       	sub	r18, r24
    139a:	39 0b       	sbc	r19, r25
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    139c:	c9 01       	movw	r24, r18
    139e:	08 95       	ret

000013a0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    13a6:	0e 94 45 10 	call	0x208a	; 0x208a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    13aa:	80 91 68 02 	lds	r24, 0x0268
    13ae:	90 91 69 02 	lds	r25, 0x0269
    13b2:	89 2b       	or	r24, r25
    13b4:	31 f4       	brne	.+12     	; 0x13c2 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    13b6:	8b e6       	ldi	r24, 0x6B	; 107
    13b8:	92 e0       	ldi	r25, 0x02	; 2
    13ba:	90 93 69 02 	sts	0x0269, r25
    13be:	80 93 68 02 	sts	0x0268, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    13c2:	20 91 66 02 	lds	r18, 0x0266
    13c6:	30 91 67 02 	lds	r19, 0x0267
    13ca:	ce 01       	movw	r24, r28
    13cc:	82 0f       	add	r24, r18
    13ce:	93 1f       	adc	r25, r19
    13d0:	43 e0       	ldi	r20, 0x03	; 3
    13d2:	87 3e       	cpi	r24, 0xE7	; 231
    13d4:	94 07       	cpc	r25, r20
    13d6:	70 f4       	brcc	.+28     	; 0x13f4 <pvPortMalloc+0x54>
    13d8:	28 17       	cp	r18, r24
    13da:	39 07       	cpc	r19, r25
    13dc:	58 f4       	brcc	.+22     	; 0x13f4 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    13de:	c0 91 68 02 	lds	r28, 0x0268
    13e2:	d0 91 69 02 	lds	r29, 0x0269
    13e6:	c2 0f       	add	r28, r18
    13e8:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    13ea:	90 93 67 02 	sts	0x0267, r25
    13ee:	80 93 66 02 	sts	0x0266, r24
    13f2:	02 c0       	rjmp	.+4      	; 0x13f8 <pvPortMalloc+0x58>
    13f4:	c0 e0       	ldi	r28, 0x00	; 0
    13f6:	d0 e0       	ldi	r29, 0x00	; 0
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    13f8:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    13fc:	ce 01       	movw	r24, r28
    13fe:	df 91       	pop	r29
    1400:	cf 91       	pop	r28
    1402:	08 95       	ret

00001404 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    1404:	9f 92       	push	r9
    1406:	af 92       	push	r10
    1408:	bf 92       	push	r11
    140a:	cf 92       	push	r12
    140c:	df 92       	push	r13
    140e:	ef 92       	push	r14
    1410:	ff 92       	push	r15
    1412:	0f 93       	push	r16
    1414:	1f 93       	push	r17
    1416:	df 93       	push	r29
    1418:	cf 93       	push	r28
    141a:	00 d0       	rcall	.+0      	; 0x141c <vCompeteingIntMathTask+0x18>
    141c:	00 d0       	rcall	.+0      	; 0x141e <vCompeteingIntMathTask+0x1a>
    141e:	cd b7       	in	r28, 0x3d	; 61
    1420:	de b7       	in	r29, 0x3e	; 62
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1422:	8c 01       	movw	r16, r24
    1424:	ee 24       	eor	r14, r14
    1426:	ff 24       	eor	r15, r15
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    1428:	9b e7       	ldi	r25, 0x7B	; 123
    142a:	a9 2e       	mov	r10, r25
    142c:	b1 2c       	mov	r11, r1
    142e:	c1 2c       	mov	r12, r1
    1430:	d1 2c       	mov	r13, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    1432:	99 24       	eor	r9, r9
    1434:	93 94       	inc	r9
    1436:	03 c0       	rjmp	.+6      	; 0x143e <vCompeteingIntMathTask+0x3a>
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    1438:	81 e0       	ldi	r24, 0x01	; 1
    143a:	e8 2e       	mov	r14, r24
    143c:	f1 2c       	mov	r15, r1
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    143e:	a9 82       	std	Y+1, r10	; 0x01
    1440:	ba 82       	std	Y+2, r11	; 0x02
    1442:	cb 82       	std	Y+3, r12	; 0x03
    1444:	dc 82       	std	Y+4, r13	; 0x04
		lValue += intgCONST2;
    1446:	89 81       	ldd	r24, Y+1	; 0x01
    1448:	9a 81       	ldd	r25, Y+2	; 0x02
    144a:	ab 81       	ldd	r26, Y+3	; 0x03
    144c:	bc 81       	ldd	r27, Y+4	; 0x04
    144e:	89 5b       	subi	r24, 0xB9	; 185
    1450:	9b 46       	sbci	r25, 0x6B	; 107
    1452:	ac 4f       	sbci	r26, 0xFC	; 252
    1454:	bf 4f       	sbci	r27, 0xFF	; 255
    1456:	89 83       	std	Y+1, r24	; 0x01
    1458:	9a 83       	std	Y+2, r25	; 0x02
    145a:	ab 83       	std	Y+3, r26	; 0x03
    145c:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    145e:	69 81       	ldd	r22, Y+1	; 0x01
    1460:	7a 81       	ldd	r23, Y+2	; 0x02
    1462:	8b 81       	ldd	r24, Y+3	; 0x03
    1464:	9c 81       	ldd	r25, Y+4	; 0x04
    1466:	2d ef       	ldi	r18, 0xFD	; 253
    1468:	3f ef       	ldi	r19, 0xFF	; 255
    146a:	4f ef       	ldi	r20, 0xFF	; 255
    146c:	5f ef       	ldi	r21, 0xFF	; 255
    146e:	0e 94 84 1d 	call	0x3b08	; 0x3b08 <__mulsi3>
    1472:	69 83       	std	Y+1, r22	; 0x01
    1474:	7a 83       	std	Y+2, r23	; 0x02
    1476:	8b 83       	std	Y+3, r24	; 0x03
    1478:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    147a:	69 81       	ldd	r22, Y+1	; 0x01
    147c:	7a 81       	ldd	r23, Y+2	; 0x02
    147e:	8b 81       	ldd	r24, Y+3	; 0x03
    1480:	9c 81       	ldd	r25, Y+4	; 0x04
    1482:	27 e0       	ldi	r18, 0x07	; 7
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	40 e0       	ldi	r20, 0x00	; 0
    1488:	50 e0       	ldi	r21, 0x00	; 0
    148a:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__divmodsi4>
    148e:	c9 01       	movw	r24, r18
    1490:	da 01       	movw	r26, r20
    1492:	89 83       	std	Y+1, r24	; 0x01
    1494:	9a 83       	std	Y+2, r25	; 0x02
    1496:	ab 83       	std	Y+3, r26	; 0x03
    1498:	bc 83       	std	Y+4, r27	; 0x04

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    149a:	89 81       	ldd	r24, Y+1	; 0x01
    149c:	9a 81       	ldd	r25, Y+2	; 0x02
    149e:	ab 81       	ldd	r26, Y+3	; 0x03
    14a0:	bc 81       	ldd	r27, Y+4	; 0x04
    14a2:	8b 51       	subi	r24, 0x1B	; 27
    14a4:	97 47       	sbci	r25, 0x77	; 119
    14a6:	ae 4f       	sbci	r26, 0xFE	; 254
    14a8:	bf 4f       	sbci	r27, 0xFF	; 255
    14aa:	31 f6       	brne	.-116    	; 0x1438 <vCompeteingIntMathTask+0x34>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    14ac:	e1 14       	cp	r14, r1
    14ae:	f1 04       	cpc	r15, r1
    14b0:	09 f0       	breq	.+2      	; 0x14b4 <vCompeteingIntMathTask+0xb0>
    14b2:	c2 cf       	rjmp	.-124    	; 0x1438 <vCompeteingIntMathTask+0x34>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    14b4:	0f b6       	in	r0, 0x3f	; 63
    14b6:	f8 94       	cli
    14b8:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    14ba:	f8 01       	movw	r30, r16
    14bc:	90 82       	st	Z, r9
			portEXIT_CRITICAL();
    14be:	0f 90       	pop	r0
    14c0:	0f be       	out	0x3f, r0	; 63
    14c2:	bd cf       	rjmp	.-134    	; 0x143e <vCompeteingIntMathTask+0x3a>

000014c4 <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    14c4:	80 91 52 06 	lds	r24, 0x0652
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    14c8:	10 92 52 06 	sts	0x0652, r1
    14cc:	81 11       	cpse	r24, r1
    14ce:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    14d0:	08 95       	ret

000014d2 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    14d2:	af 92       	push	r10
    14d4:	bf 92       	push	r11
    14d6:	cf 92       	push	r12
    14d8:	df 92       	push	r13
    14da:	ef 92       	push	r14
    14dc:	ff 92       	push	r15
    14de:	0f 93       	push	r16
    14e0:	08 2f       	mov	r16, r24
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    14e2:	82 e0       	ldi	r24, 0x02	; 2
    14e4:	9a e0       	ldi	r25, 0x0A	; 10
    14e6:	60 e7       	ldi	r22, 0x70	; 112
    14e8:	70 e0       	ldi	r23, 0x00	; 0
    14ea:	45 e5       	ldi	r20, 0x55	; 85
    14ec:	50 e0       	ldi	r21, 0x00	; 0
    14ee:	22 e5       	ldi	r18, 0x52	; 82
    14f0:	36 e0       	ldi	r19, 0x06	; 6
    14f2:	ee 24       	eor	r14, r14
    14f4:	ff 24       	eor	r15, r15
    14f6:	cc 24       	eor	r12, r12
    14f8:	dd 24       	eor	r13, r13
    14fa:	aa 24       	eor	r10, r10
    14fc:	bb 24       	eor	r11, r11
    14fe:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>
	}
}
    1502:	0f 91       	pop	r16
    1504:	ff 90       	pop	r15
    1506:	ef 90       	pop	r14
    1508:	df 90       	pop	r13
    150a:	cf 90       	pop	r12
    150c:	bf 90       	pop	r11
    150e:	af 90       	pop	r10
    1510:	08 95       	ret

00001512 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1512:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1514:	9c 01       	movw	r18, r24
    1516:	2d 5f       	subi	r18, 0xFD	; 253
    1518:	3f 4f       	sbci	r19, 0xFF	; 255
    151a:	32 83       	std	Z+2, r19	; 0x02
    151c:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    151e:	8f ef       	ldi	r24, 0xFF	; 255
    1520:	9f ef       	ldi	r25, 0xFF	; 255
    1522:	94 83       	std	Z+4, r25	; 0x04
    1524:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1526:	36 83       	std	Z+6, r19	; 0x06
    1528:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    152a:	30 87       	std	Z+8, r19	; 0x08
    152c:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    152e:	10 82       	st	Z, r1
}
    1530:	08 95       	ret

00001532 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1532:	fc 01       	movw	r30, r24
    1534:	11 86       	std	Z+9, r1	; 0x09
    1536:	10 86       	std	Z+8, r1	; 0x08
}
    1538:	08 95       	ret

0000153a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    153a:	ac 01       	movw	r20, r24
ListItem_t * const pxIndex = pxList->pxIndex;
    153c:	fc 01       	movw	r30, r24
    153e:	a1 81       	ldd	r26, Z+1	; 0x01
    1540:	b2 81       	ldd	r27, Z+2	; 0x02

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1542:	fb 01       	movw	r30, r22
    1544:	b3 83       	std	Z+3, r27	; 0x03
    1546:	a2 83       	std	Z+2, r26	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1548:	14 96       	adiw	r26, 0x04	; 4
    154a:	8d 91       	ld	r24, X+
    154c:	9c 91       	ld	r25, X
    154e:	15 97       	sbiw	r26, 0x05	; 5
    1550:	95 83       	std	Z+5, r25	; 0x05
    1552:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1554:	14 96       	adiw	r26, 0x04	; 4
    1556:	ed 91       	ld	r30, X+
    1558:	fc 91       	ld	r31, X
    155a:	15 97       	sbiw	r26, 0x05	; 5
    155c:	73 83       	std	Z+3, r23	; 0x03
    155e:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1560:	15 96       	adiw	r26, 0x05	; 5
    1562:	7c 93       	st	X, r23
    1564:	6e 93       	st	-X, r22
    1566:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1568:	fb 01       	movw	r30, r22
    156a:	51 87       	std	Z+9, r21	; 0x09
    156c:	40 87       	std	Z+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    156e:	fa 01       	movw	r30, r20
    1570:	80 81       	ld	r24, Z
    1572:	8f 5f       	subi	r24, 0xFF	; 255
    1574:	80 83       	st	Z, r24
}
    1576:	08 95       	ret

00001578 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	9c 01       	movw	r18, r24
    157e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1580:	48 81       	ld	r20, Y
    1582:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1584:	8f ef       	ldi	r24, 0xFF	; 255
    1586:	4f 3f       	cpi	r20, 0xFF	; 255
    1588:	58 07       	cpc	r21, r24
    158a:	21 f4       	brne	.+8      	; 0x1594 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    158c:	f9 01       	movw	r30, r18
    158e:	a7 81       	ldd	r26, Z+7	; 0x07
    1590:	b0 85       	ldd	r27, Z+8	; 0x08
    1592:	0d c0       	rjmp	.+26     	; 0x15ae <vListInsert+0x36>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1594:	d9 01       	movw	r26, r18
    1596:	13 96       	adiw	r26, 0x03	; 3
    1598:	12 96       	adiw	r26, 0x02	; 2
    159a:	ed 91       	ld	r30, X+
    159c:	fc 91       	ld	r31, X
    159e:	13 97       	sbiw	r26, 0x03	; 3
    15a0:	80 81       	ld	r24, Z
    15a2:	91 81       	ldd	r25, Z+1	; 0x01
    15a4:	48 17       	cp	r20, r24
    15a6:	59 07       	cpc	r21, r25
    15a8:	10 f0       	brcs	.+4      	; 0x15ae <vListInsert+0x36>
    15aa:	df 01       	movw	r26, r30
    15ac:	f5 cf       	rjmp	.-22     	; 0x1598 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    15ae:	12 96       	adiw	r26, 0x02	; 2
    15b0:	ed 91       	ld	r30, X+
    15b2:	fc 91       	ld	r31, X
    15b4:	13 97       	sbiw	r26, 0x03	; 3
    15b6:	fb 83       	std	Y+3, r31	; 0x03
    15b8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    15ba:	d5 83       	std	Z+5, r29	; 0x05
    15bc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    15be:	bd 83       	std	Y+5, r27	; 0x05
    15c0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    15c2:	13 96       	adiw	r26, 0x03	; 3
    15c4:	dc 93       	st	X, r29
    15c6:	ce 93       	st	-X, r28
    15c8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    15ca:	39 87       	std	Y+9, r19	; 0x09
    15cc:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    15ce:	f9 01       	movw	r30, r18
    15d0:	80 81       	ld	r24, Z
    15d2:	8f 5f       	subi	r24, 0xFF	; 255
    15d4:	80 83       	st	Z, r24
}
    15d6:	df 91       	pop	r29
    15d8:	cf 91       	pop	r28
    15da:	08 95       	ret

000015dc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    15dc:	cf 93       	push	r28
    15de:	df 93       	push	r29
    15e0:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    15e2:	18 96       	adiw	r26, 0x08	; 8
    15e4:	cd 91       	ld	r28, X+
    15e6:	dc 91       	ld	r29, X
    15e8:	19 97       	sbiw	r26, 0x09	; 9

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    15ea:	12 96       	adiw	r26, 0x02	; 2
    15ec:	4d 91       	ld	r20, X+
    15ee:	5c 91       	ld	r21, X
    15f0:	13 97       	sbiw	r26, 0x03	; 3
    15f2:	14 96       	adiw	r26, 0x04	; 4
    15f4:	8d 91       	ld	r24, X+
    15f6:	9c 91       	ld	r25, X
    15f8:	15 97       	sbiw	r26, 0x05	; 5
    15fa:	fa 01       	movw	r30, r20
    15fc:	95 83       	std	Z+5, r25	; 0x05
    15fe:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1600:	14 96       	adiw	r26, 0x04	; 4
    1602:	2d 91       	ld	r18, X+
    1604:	3c 91       	ld	r19, X
    1606:	15 97       	sbiw	r26, 0x05	; 5
    1608:	f9 01       	movw	r30, r18
    160a:	53 83       	std	Z+3, r21	; 0x03
    160c:	42 83       	std	Z+2, r20	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    160e:	89 81       	ldd	r24, Y+1	; 0x01
    1610:	9a 81       	ldd	r25, Y+2	; 0x02
    1612:	8a 17       	cp	r24, r26
    1614:	9b 07       	cpc	r25, r27
    1616:	11 f4       	brne	.+4      	; 0x161c <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1618:	3a 83       	std	Y+2, r19	; 0x02
    161a:	29 83       	std	Y+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    161c:	19 96       	adiw	r26, 0x09	; 9
    161e:	1c 92       	st	X, r1
    1620:	1e 92       	st	-X, r1
    1622:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    1624:	88 81       	ld	r24, Y
    1626:	81 50       	subi	r24, 0x01	; 1
    1628:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
    162a:	df 91       	pop	r29
    162c:	cf 91       	pop	r28
    162e:	08 95       	ret

00001630 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1630:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1632:	91 e1       	ldi	r25, 0x11	; 17
    1634:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1636:	22 e2       	ldi	r18, 0x22	; 34
    1638:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    163a:	83 e3       	ldi	r24, 0x33	; 51
    163c:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    163e:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1640:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1642:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1644:	80 e8       	ldi	r24, 0x80	; 128
    1646:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1648:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    164a:	82 e0       	ldi	r24, 0x02	; 2
    164c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    164e:	83 e0       	ldi	r24, 0x03	; 3
    1650:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1652:	84 e0       	ldi	r24, 0x04	; 4
    1654:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1656:	85 e0       	ldi	r24, 0x05	; 5
    1658:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    165a:	86 e0       	ldi	r24, 0x06	; 6
    165c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    165e:	87 e0       	ldi	r24, 0x07	; 7
    1660:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1662:	88 e0       	ldi	r24, 0x08	; 8
    1664:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1666:	89 e0       	ldi	r24, 0x09	; 9
    1668:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    166a:	80 e1       	ldi	r24, 0x10	; 16
    166c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    166e:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1670:	82 e1       	ldi	r24, 0x12	; 18
    1672:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1674:	83 e1       	ldi	r24, 0x13	; 19
    1676:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1678:	84 e1       	ldi	r24, 0x14	; 20
    167a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    167c:	85 e1       	ldi	r24, 0x15	; 21
    167e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1680:	86 e1       	ldi	r24, 0x16	; 22
    1682:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1684:	87 e1       	ldi	r24, 0x17	; 23
    1686:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1688:	88 e1       	ldi	r24, 0x18	; 24
    168a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    168c:	89 e1       	ldi	r24, 0x19	; 25
    168e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1690:	80 e2       	ldi	r24, 0x20	; 32
    1692:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1694:	81 e2       	ldi	r24, 0x21	; 33
    1696:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1698:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    169a:	83 e2       	ldi	r24, 0x23	; 35
    169c:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    169e:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    16a0:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    16a2:	86 e2       	ldi	r24, 0x26	; 38
    16a4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    16a6:	87 e2       	ldi	r24, 0x27	; 39
    16a8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    16aa:	88 e2       	ldi	r24, 0x28	; 40
    16ac:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    16ae:	89 e2       	ldi	r24, 0x29	; 41
    16b0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    16b2:	80 e3       	ldi	r24, 0x30	; 48
    16b4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    16b6:	81 e3       	ldi	r24, 0x31	; 49
    16b8:	82 93       	st	-Z, r24
    16ba:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    16bc:	cf 01       	movw	r24, r30
    16be:	08 95       	ret

000016c0 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    16c0:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    16c2:	8c e7       	ldi	r24, 0x7C	; 124
    16c4:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    16c6:	8b e0       	ldi	r24, 0x0B	; 11
    16c8:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    16ca:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    16cc:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    16ce:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    16d0:	a0 91 53 06 	lds	r26, 0x0653
    16d4:	b0 91 54 06 	lds	r27, 0x0654
    16d8:	cd 91       	ld	r28, X+
    16da:	cd bf       	out	0x3d, r28	; 61
    16dc:	dd 91       	ld	r29, X+
    16de:	de bf       	out	0x3e, r29	; 62
    16e0:	ff 91       	pop	r31
    16e2:	ef 91       	pop	r30
    16e4:	df 91       	pop	r29
    16e6:	cf 91       	pop	r28
    16e8:	bf 91       	pop	r27
    16ea:	af 91       	pop	r26
    16ec:	9f 91       	pop	r25
    16ee:	8f 91       	pop	r24
    16f0:	7f 91       	pop	r23
    16f2:	6f 91       	pop	r22
    16f4:	5f 91       	pop	r21
    16f6:	4f 91       	pop	r20
    16f8:	3f 91       	pop	r19
    16fa:	2f 91       	pop	r18
    16fc:	1f 91       	pop	r17
    16fe:	0f 91       	pop	r16
    1700:	ff 90       	pop	r15
    1702:	ef 90       	pop	r14
    1704:	df 90       	pop	r13
    1706:	cf 90       	pop	r12
    1708:	bf 90       	pop	r11
    170a:	af 90       	pop	r10
    170c:	9f 90       	pop	r9
    170e:	8f 90       	pop	r8
    1710:	7f 90       	pop	r7
    1712:	6f 90       	pop	r6
    1714:	5f 90       	pop	r5
    1716:	4f 90       	pop	r4
    1718:	3f 90       	pop	r3
    171a:	2f 90       	pop	r2
    171c:	1f 90       	pop	r1
    171e:	0f 90       	pop	r0
    1720:	0f be       	out	0x3f, r0	; 63
    1722:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1724:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1726:	81 e0       	ldi	r24, 0x01	; 1
    1728:	08 95       	ret

0000172a <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    172a:	08 95       	ret

0000172c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    172c:	0f 92       	push	r0
    172e:	0f b6       	in	r0, 0x3f	; 63
    1730:	f8 94       	cli
    1732:	0f 92       	push	r0
    1734:	1f 92       	push	r1
    1736:	11 24       	eor	r1, r1
    1738:	2f 92       	push	r2
    173a:	3f 92       	push	r3
    173c:	4f 92       	push	r4
    173e:	5f 92       	push	r5
    1740:	6f 92       	push	r6
    1742:	7f 92       	push	r7
    1744:	8f 92       	push	r8
    1746:	9f 92       	push	r9
    1748:	af 92       	push	r10
    174a:	bf 92       	push	r11
    174c:	cf 92       	push	r12
    174e:	df 92       	push	r13
    1750:	ef 92       	push	r14
    1752:	ff 92       	push	r15
    1754:	0f 93       	push	r16
    1756:	1f 93       	push	r17
    1758:	2f 93       	push	r18
    175a:	3f 93       	push	r19
    175c:	4f 93       	push	r20
    175e:	5f 93       	push	r21
    1760:	6f 93       	push	r22
    1762:	7f 93       	push	r23
    1764:	8f 93       	push	r24
    1766:	9f 93       	push	r25
    1768:	af 93       	push	r26
    176a:	bf 93       	push	r27
    176c:	cf 93       	push	r28
    176e:	df 93       	push	r29
    1770:	ef 93       	push	r30
    1772:	ff 93       	push	r31
    1774:	a0 91 53 06 	lds	r26, 0x0653
    1778:	b0 91 54 06 	lds	r27, 0x0654
    177c:	0d b6       	in	r0, 0x3d	; 61
    177e:	0d 92       	st	X+, r0
    1780:	0e b6       	in	r0, 0x3e	; 62
    1782:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1784:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskIncrementTick>
    1788:	88 23       	and	r24, r24
    178a:	11 f0       	breq	.+4      	; 0x1790 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    178c:	0e 94 5f 10 	call	0x20be	; 0x20be <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1790:	a0 91 53 06 	lds	r26, 0x0653
    1794:	b0 91 54 06 	lds	r27, 0x0654
    1798:	cd 91       	ld	r28, X+
    179a:	cd bf       	out	0x3d, r28	; 61
    179c:	dd 91       	ld	r29, X+
    179e:	de bf       	out	0x3e, r29	; 62
    17a0:	ff 91       	pop	r31
    17a2:	ef 91       	pop	r30
    17a4:	df 91       	pop	r29
    17a6:	cf 91       	pop	r28
    17a8:	bf 91       	pop	r27
    17aa:	af 91       	pop	r26
    17ac:	9f 91       	pop	r25
    17ae:	8f 91       	pop	r24
    17b0:	7f 91       	pop	r23
    17b2:	6f 91       	pop	r22
    17b4:	5f 91       	pop	r21
    17b6:	4f 91       	pop	r20
    17b8:	3f 91       	pop	r19
    17ba:	2f 91       	pop	r18
    17bc:	1f 91       	pop	r17
    17be:	0f 91       	pop	r16
    17c0:	ff 90       	pop	r15
    17c2:	ef 90       	pop	r14
    17c4:	df 90       	pop	r13
    17c6:	cf 90       	pop	r12
    17c8:	bf 90       	pop	r11
    17ca:	af 90       	pop	r10
    17cc:	9f 90       	pop	r9
    17ce:	8f 90       	pop	r8
    17d0:	7f 90       	pop	r7
    17d2:	6f 90       	pop	r6
    17d4:	5f 90       	pop	r5
    17d6:	4f 90       	pop	r4
    17d8:	3f 90       	pop	r3
    17da:	2f 90       	pop	r2
    17dc:	1f 90       	pop	r1
    17de:	0f 90       	pop	r0
    17e0:	0f be       	out	0x3f, r0	; 63
    17e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17e4:	08 95       	ret

000017e6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    17e6:	0e 94 96 0b 	call	0x172c	; 0x172c <vPortYieldFromTick>
		asm volatile ( "reti" );
    17ea:	18 95       	reti

000017ec <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    17ec:	0f 92       	push	r0
    17ee:	0f b6       	in	r0, 0x3f	; 63
    17f0:	f8 94       	cli
    17f2:	0f 92       	push	r0
    17f4:	1f 92       	push	r1
    17f6:	11 24       	eor	r1, r1
    17f8:	2f 92       	push	r2
    17fa:	3f 92       	push	r3
    17fc:	4f 92       	push	r4
    17fe:	5f 92       	push	r5
    1800:	6f 92       	push	r6
    1802:	7f 92       	push	r7
    1804:	8f 92       	push	r8
    1806:	9f 92       	push	r9
    1808:	af 92       	push	r10
    180a:	bf 92       	push	r11
    180c:	cf 92       	push	r12
    180e:	df 92       	push	r13
    1810:	ef 92       	push	r14
    1812:	ff 92       	push	r15
    1814:	0f 93       	push	r16
    1816:	1f 93       	push	r17
    1818:	2f 93       	push	r18
    181a:	3f 93       	push	r19
    181c:	4f 93       	push	r20
    181e:	5f 93       	push	r21
    1820:	6f 93       	push	r22
    1822:	7f 93       	push	r23
    1824:	8f 93       	push	r24
    1826:	9f 93       	push	r25
    1828:	af 93       	push	r26
    182a:	bf 93       	push	r27
    182c:	cf 93       	push	r28
    182e:	df 93       	push	r29
    1830:	ef 93       	push	r30
    1832:	ff 93       	push	r31
    1834:	a0 91 53 06 	lds	r26, 0x0653
    1838:	b0 91 54 06 	lds	r27, 0x0654
    183c:	0d b6       	in	r0, 0x3d	; 61
    183e:	0d 92       	st	X+, r0
    1840:	0e b6       	in	r0, 0x3e	; 62
    1842:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1844:	0e 94 5f 10 	call	0x20be	; 0x20be <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1848:	a0 91 53 06 	lds	r26, 0x0653
    184c:	b0 91 54 06 	lds	r27, 0x0654
    1850:	cd 91       	ld	r28, X+
    1852:	cd bf       	out	0x3d, r28	; 61
    1854:	dd 91       	ld	r29, X+
    1856:	de bf       	out	0x3e, r29	; 62
    1858:	ff 91       	pop	r31
    185a:	ef 91       	pop	r30
    185c:	df 91       	pop	r29
    185e:	cf 91       	pop	r28
    1860:	bf 91       	pop	r27
    1862:	af 91       	pop	r26
    1864:	9f 91       	pop	r25
    1866:	8f 91       	pop	r24
    1868:	7f 91       	pop	r23
    186a:	6f 91       	pop	r22
    186c:	5f 91       	pop	r21
    186e:	4f 91       	pop	r20
    1870:	3f 91       	pop	r19
    1872:	2f 91       	pop	r18
    1874:	1f 91       	pop	r17
    1876:	0f 91       	pop	r16
    1878:	ff 90       	pop	r15
    187a:	ef 90       	pop	r14
    187c:	df 90       	pop	r13
    187e:	cf 90       	pop	r12
    1880:	bf 90       	pop	r11
    1882:	af 90       	pop	r10
    1884:	9f 90       	pop	r9
    1886:	8f 90       	pop	r8
    1888:	7f 90       	pop	r7
    188a:	6f 90       	pop	r6
    188c:	5f 90       	pop	r5
    188e:	4f 90       	pop	r4
    1890:	3f 90       	pop	r3
    1892:	2f 90       	pop	r2
    1894:	1f 90       	pop	r1
    1896:	0f 90       	pop	r0
    1898:	0f be       	out	0x3f, r0	; 63
    189a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    189c:	08 95       	ret

0000189e <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    189e:	0f b6       	in	r0, 0x3f	; 63
    18a0:	f8 94       	cli
    18a2:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    18a4:	fc 01       	movw	r30, r24
    18a6:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    18a8:	0f 90       	pop	r0
    18aa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    18ac:	08 95       	ret

000018ae <uxQueueSpacesAvailable>:
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    18ae:	fc 01       	movw	r30, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    18b0:	0f b6       	in	r0, 0x3f	; 63
    18b2:	f8 94       	cli
    18b4:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    18b6:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    18b8:	0f 90       	pop	r0
    18ba:	0f be       	out	0x3f, r0	; 63
    18bc:	83 8d       	ldd	r24, Z+27	; 0x1b

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    18be:	89 1b       	sub	r24, r25
    18c0:	08 95       	ret

000018c2 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    18c2:	fc 01       	movw	r30, r24
    18c4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    18c6:	08 95       	ret

000018c8 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    18c8:	fc 01       	movw	r30, r24
    18ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    18cc:	90 e0       	ldi	r25, 0x00	; 0
    18ce:	88 23       	and	r24, r24
    18d0:	09 f4       	brne	.+2      	; 0x18d4 <xQueueIsQueueEmptyFromISR+0xc>
    18d2:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    18d4:	89 2f       	mov	r24, r25
    18d6:	08 95       	ret

000018d8 <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    18d8:	fc 01       	movw	r30, r24
    18da:	92 8d       	ldd	r25, Z+26	; 0x1a
    18dc:	20 e0       	ldi	r18, 0x00	; 0
    18de:	83 8d       	ldd	r24, Z+27	; 0x1b
    18e0:	98 17       	cp	r25, r24
    18e2:	09 f4       	brne	.+2      	; 0x18e6 <xQueueIsQueueFullFromISR+0xe>
    18e4:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    18e6:	82 2f       	mov	r24, r18
    18e8:	08 95       	ret

000018ea <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    18ea:	1f 93       	push	r17
    18ec:	cf 93       	push	r28
    18ee:	df 93       	push	r29
    18f0:	ec 01       	movw	r28, r24
    18f2:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    18f4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    18f6:	44 23       	and	r20, r20
    18f8:	e1 f1       	breq	.+120    	; 0x1972 <prvCopyDataToQueue+0x88>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    18fa:	11 23       	and	r17, r17
    18fc:	b1 f4       	brne	.+44     	; 0x192a <prvCopyDataToQueue+0x40>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    18fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1900:	9d 81       	ldd	r25, Y+5	; 0x05
    1902:	50 e0       	ldi	r21, 0x00	; 0
    1904:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1908:	8c 8d       	ldd	r24, Y+28	; 0x1c
    190a:	2c 81       	ldd	r18, Y+4	; 0x04
    190c:	3d 81       	ldd	r19, Y+5	; 0x05
    190e:	28 0f       	add	r18, r24
    1910:	31 1d       	adc	r19, r1
    1912:	3d 83       	std	Y+5, r19	; 0x05
    1914:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1916:	8a 81       	ldd	r24, Y+2	; 0x02
    1918:	9b 81       	ldd	r25, Y+3	; 0x03
    191a:	28 17       	cp	r18, r24
    191c:	39 07       	cpc	r19, r25
    191e:	48 f1       	brcs	.+82     	; 0x1972 <prvCopyDataToQueue+0x88>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1920:	88 81       	ld	r24, Y
    1922:	99 81       	ldd	r25, Y+1	; 0x01
    1924:	9d 83       	std	Y+5, r25	; 0x05
    1926:	8c 83       	std	Y+4, r24	; 0x04
    1928:	24 c0       	rjmp	.+72     	; 0x1972 <prvCopyDataToQueue+0x88>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    192a:	8e 81       	ldd	r24, Y+6	; 0x06
    192c:	9f 81       	ldd	r25, Y+7	; 0x07
    192e:	50 e0       	ldi	r21, 0x00	; 0
    1930:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1934:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	44 27       	eor	r20, r20
    193a:	55 27       	eor	r21, r21
    193c:	48 1b       	sub	r20, r24
    193e:	59 0b       	sbc	r21, r25
    1940:	8e 81       	ldd	r24, Y+6	; 0x06
    1942:	9f 81       	ldd	r25, Y+7	; 0x07
    1944:	84 0f       	add	r24, r20
    1946:	95 1f       	adc	r25, r21
    1948:	9f 83       	std	Y+7, r25	; 0x07
    194a:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    194c:	28 81       	ld	r18, Y
    194e:	39 81       	ldd	r19, Y+1	; 0x01
    1950:	82 17       	cp	r24, r18
    1952:	93 07       	cpc	r25, r19
    1954:	30 f4       	brcc	.+12     	; 0x1962 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1956:	8a 81       	ldd	r24, Y+2	; 0x02
    1958:	9b 81       	ldd	r25, Y+3	; 0x03
    195a:	84 0f       	add	r24, r20
    195c:	95 1f       	adc	r25, r21
    195e:	9f 83       	std	Y+7, r25	; 0x07
    1960:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1962:	12 30       	cpi	r17, 0x02	; 2
    1964:	31 f4       	brne	.+12     	; 0x1972 <prvCopyDataToQueue+0x88>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1966:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1968:	88 23       	and	r24, r24
    196a:	19 f0       	breq	.+6      	; 0x1972 <prvCopyDataToQueue+0x88>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    196c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    196e:	81 50       	subi	r24, 0x01	; 1
    1970:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1972:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1974:	8f 5f       	subi	r24, 0xFF	; 255
    1976:	8a 8f       	std	Y+26, r24	; 0x1a

	return xReturn;
}
    1978:	80 e0       	ldi	r24, 0x00	; 0
    197a:	df 91       	pop	r29
    197c:	cf 91       	pop	r28
    197e:	1f 91       	pop	r17
    1980:	08 95       	ret

00001982 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1982:	fc 01       	movw	r30, r24
    1984:	56 2f       	mov	r21, r22
    1986:	a7 2f       	mov	r26, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1988:	24 8d       	ldd	r18, Z+28	; 0x1c
    198a:	22 23       	and	r18, r18
    198c:	b9 f0       	breq	.+46     	; 0x19bc <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    198e:	86 81       	ldd	r24, Z+6	; 0x06
    1990:	97 81       	ldd	r25, Z+7	; 0x07
    1992:	82 0f       	add	r24, r18
    1994:	91 1d       	adc	r25, r1
    1996:	97 83       	std	Z+7, r25	; 0x07
    1998:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    199a:	22 81       	ldd	r18, Z+2	; 0x02
    199c:	33 81       	ldd	r19, Z+3	; 0x03
    199e:	82 17       	cp	r24, r18
    19a0:	93 07       	cpc	r25, r19
    19a2:	20 f0       	brcs	.+8      	; 0x19ac <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    19a4:	80 81       	ld	r24, Z
    19a6:	91 81       	ldd	r25, Z+1	; 0x01
    19a8:	97 83       	std	Z+7, r25	; 0x07
    19aa:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    19ac:	44 8d       	ldd	r20, Z+28	; 0x1c
    19ae:	66 81       	ldd	r22, Z+6	; 0x06
    19b0:	77 81       	ldd	r23, Z+7	; 0x07
    19b2:	85 2f       	mov	r24, r21
    19b4:	9a 2f       	mov	r25, r26
    19b6:	50 e0       	ldi	r21, 0x00	; 0
    19b8:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <memcpy>
    19bc:	08 95       	ret

000019be <xQueuePeekFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    19be:	0f 93       	push	r16
    19c0:	1f 93       	push	r17
    19c2:	cf 93       	push	r28
    19c4:	df 93       	push	r29
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    19c6:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19c8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19ca:	88 23       	and	r24, r24
    19cc:	41 f0       	breq	.+16     	; 0x19de <xQueuePeekFromISR+0x20>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    19ce:	0e 81       	ldd	r16, Y+6	; 0x06
    19d0:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19d2:	ce 01       	movw	r24, r28
    19d4:	0e 94 c1 0c 	call	0x1982	; 0x1982 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    19d8:	1f 83       	std	Y+7, r17	; 0x07
    19da:	0e 83       	std	Y+6, r16	; 0x06
    19dc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19de:	df 91       	pop	r29
    19e0:	cf 91       	pop	r28
    19e2:	1f 91       	pop	r17
    19e4:	0f 91       	pop	r16
    19e6:	08 95       	ret

000019e8 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    19e8:	0f 93       	push	r16
    19ea:	1f 93       	push	r17
    19ec:	cf 93       	push	r28
    19ee:	df 93       	push	r29
    19f0:	fb 01       	movw	r30, r22
    19f2:	8a 01       	movw	r16, r20
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    19f4:	ec 01       	movw	r28, r24

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19f8:	88 23       	and	r24, r24
    19fa:	61 f1       	breq	.+88     	; 0x1a54 <xQueueCRReceiveFromISR+0x6c>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    19fc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    19fe:	2e 81       	ldd	r18, Y+6	; 0x06
    1a00:	3f 81       	ldd	r19, Y+7	; 0x07
    1a02:	28 0f       	add	r18, r24
    1a04:	31 1d       	adc	r19, r1
    1a06:	3f 83       	std	Y+7, r19	; 0x07
    1a08:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a0c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a0e:	28 17       	cp	r18, r24
    1a10:	39 07       	cpc	r19, r25
    1a12:	20 f0       	brcs	.+8      	; 0x1a1c <xQueueCRReceiveFromISR+0x34>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1a14:	88 81       	ld	r24, Y
    1a16:	99 81       	ldd	r25, Y+1	; 0x01
    1a18:	9f 83       	std	Y+7, r25	; 0x07
    1a1a:	8e 83       	std	Y+6, r24	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1a1c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a1e:	81 50       	subi	r24, 0x01	; 1
    1a20:	8a 8f       	std	Y+26, r24	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1a22:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a24:	6e 81       	ldd	r22, Y+6	; 0x06
    1a26:	7f 81       	ldd	r23, Y+7	; 0x07
    1a28:	cf 01       	movw	r24, r30
    1a2a:	50 e0       	ldi	r21, 0x00	; 0
    1a2c:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1a30:	f8 01       	movw	r30, r16
    1a32:	80 81       	ld	r24, Z
    1a34:	88 23       	and	r24, r24
    1a36:	69 f4       	brne	.+26     	; 0x1a52 <xQueueCRReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a38:	88 85       	ldd	r24, Y+8	; 0x08
    1a3a:	88 23       	and	r24, r24
    1a3c:	51 f0       	breq	.+20     	; 0x1a52 <xQueueCRReceiveFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a3e:	ce 01       	movw	r24, r28
    1a40:	08 96       	adiw	r24, 0x08	; 8
    1a42:	0e 94 70 06 	call	0xce0	; 0xce0 <xCoRoutineRemoveFromEventList>
    1a46:	88 23       	and	r24, r24
    1a48:	21 f0       	breq	.+8      	; 0x1a52 <xQueueCRReceiveFromISR+0x6a>
					{
						*pxCoRoutineWoken = pdTRUE;
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	f8 01       	movw	r30, r16
    1a4e:	80 83       	st	Z, r24
    1a50:	01 c0       	rjmp	.+2      	; 0x1a54 <xQueueCRReceiveFromISR+0x6c>
    1a52:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	08 95       	ret

00001a5e <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1a5e:	1f 93       	push	r17
    1a60:	cf 93       	push	r28
    1a62:	df 93       	push	r29
    1a64:	14 2f       	mov	r17, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1a66:	ec 01       	movw	r28, r24

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a68:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a6a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a6c:	98 17       	cp	r25, r24
    1a6e:	88 f4       	brcc	.+34     	; 0x1a92 <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1a70:	ce 01       	movw	r24, r28
    1a72:	40 e0       	ldi	r20, 0x00	; 0
    1a74:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1a78:	11 23       	and	r17, r17
    1a7a:	59 f4       	brne	.+22     	; 0x1a92 <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a7c:	89 89       	ldd	r24, Y+17	; 0x11
    1a7e:	88 23       	and	r24, r24
    1a80:	41 f0       	breq	.+16     	; 0x1a92 <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a82:	ce 01       	movw	r24, r28
    1a84:	41 96       	adiw	r24, 0x11	; 17
    1a86:	0e 94 70 06 	call	0xce0	; 0xce0 <xCoRoutineRemoveFromEventList>
    1a8a:	48 2f       	mov	r20, r24
    1a8c:	81 11       	cpse	r24, r1
    1a8e:	41 e0       	ldi	r20, 0x01	; 1
    1a90:	14 2f       	mov	r17, r20
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1a92:	81 2f       	mov	r24, r17
    1a94:	df 91       	pop	r29
    1a96:	cf 91       	pop	r28
    1a98:	1f 91       	pop	r17
    1a9a:	08 95       	ret

00001a9c <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1a9c:	cf 93       	push	r28
    1a9e:	df 93       	push	r29
    1aa0:	fb 01       	movw	r30, r22
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1aa2:	ec 01       	movw	r28, r24

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1aa4:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1aa6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1aa8:	88 23       	and	r24, r24
    1aaa:	71 f4       	brne	.+28     	; 0x1ac8 <xQueueCRReceive+0x2c>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1aac:	41 15       	cp	r20, r1
    1aae:	51 05       	cpc	r21, r1
    1ab0:	41 f0       	breq	.+16     	; 0x1ac2 <xQueueCRReceive+0x26>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1ab2:	61 96       	adiw	r28, 0x11	; 17
    1ab4:	ca 01       	movw	r24, r20
    1ab6:	be 01       	movw	r22, r28
    1ab8:	0e 94 78 07 	call	0xef0	; 0xef0 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1abc:	78 94       	sei
    1abe:	8c ef       	ldi	r24, 0xFC	; 252
    1ac0:	2f c0       	rjmp	.+94     	; 0x1b20 <xQueueCRReceive+0x84>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    1ac2:	78 94       	sei
    1ac4:	80 e0       	ldi	r24, 0x00	; 0
    1ac6:	2c c0       	rjmp	.+88     	; 0x1b20 <xQueueCRReceive+0x84>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1ac8:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1aca:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1acc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ace:	88 23       	and	r24, r24
    1ad0:	31 f1       	breq	.+76     	; 0x1b1e <xQueueCRReceive+0x82>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1ad2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1ad4:	2e 81       	ldd	r18, Y+6	; 0x06
    1ad6:	3f 81       	ldd	r19, Y+7	; 0x07
    1ad8:	28 0f       	add	r18, r24
    1ada:	31 1d       	adc	r19, r1
    1adc:	3f 83       	std	Y+7, r19	; 0x07
    1ade:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ae4:	28 17       	cp	r18, r24
    1ae6:	39 07       	cpc	r19, r25
    1ae8:	20 f0       	brcs	.+8      	; 0x1af2 <xQueueCRReceive+0x56>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1aea:	88 81       	ld	r24, Y
    1aec:	99 81       	ldd	r25, Y+1	; 0x01
    1aee:	9f 83       	std	Y+7, r25	; 0x07
    1af0:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1af2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1af4:	81 50       	subi	r24, 0x01	; 1
    1af6:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1af8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1afa:	6e 81       	ldd	r22, Y+6	; 0x06
    1afc:	7f 81       	ldd	r23, Y+7	; 0x07
    1afe:	cf 01       	movw	r24, r30
    1b00:	50 e0       	ldi	r21, 0x00	; 0
    1b02:	0e 94 17 1e 	call	0x3c2e	; 0x3c2e <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b06:	88 85       	ldd	r24, Y+8	; 0x08
    1b08:	88 23       	and	r24, r24
    1b0a:	41 f0       	breq	.+16     	; 0x1b1c <xQueueCRReceive+0x80>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b0c:	ce 01       	movw	r24, r28
    1b0e:	08 96       	adiw	r24, 0x08	; 8
    1b10:	0e 94 70 06 	call	0xce0	; 0xce0 <xCoRoutineRemoveFromEventList>
    1b14:	88 23       	and	r24, r24
    1b16:	11 f0       	breq	.+4      	; 0x1b1c <xQueueCRReceive+0x80>
    1b18:	8b ef       	ldi	r24, 0xFB	; 251
    1b1a:	01 c0       	rjmp	.+2      	; 0x1b1e <xQueueCRReceive+0x82>
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    1b1e:	78 94       	sei

		return xReturn;
	}
    1b20:	df 91       	pop	r29
    1b22:	cf 91       	pop	r28
    1b24:	08 95       	ret

00001b26 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1b26:	cf 93       	push	r28
    1b28:	df 93       	push	r29
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1b2a:	ec 01       	movw	r28, r24

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1b2c:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b2e:	0f b6       	in	r0, 0x3f	; 63
    1b30:	f8 94       	cli
    1b32:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1b34:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b36:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b38:	0f 90       	pop	r0
    1b3a:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1b3c:	89 17       	cp	r24, r25
    1b3e:	71 f4       	brne	.+28     	; 0x1b5c <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1b40:	41 15       	cp	r20, r1
    1b42:	51 05       	cpc	r21, r1
    1b44:	41 f0       	breq	.+16     	; 0x1b56 <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1b46:	28 96       	adiw	r28, 0x08	; 8
    1b48:	ca 01       	movw	r24, r20
    1b4a:	be 01       	movw	r22, r28
    1b4c:	0e 94 78 07 	call	0xef0	; 0xef0 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1b50:	78 94       	sei
    1b52:	8c ef       	ldi	r24, 0xFC	; 252
    1b54:	1b c0       	rjmp	.+54     	; 0x1b8c <xQueueCRSend+0x66>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    1b56:	78 94       	sei
    1b58:	80 e0       	ldi	r24, 0x00	; 0
    1b5a:	18 c0       	rjmp	.+48     	; 0x1b8c <xQueueCRSend+0x66>
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
    1b5c:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1b5e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b60:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b62:	89 17       	cp	r24, r25
    1b64:	10 f0       	brcs	.+4      	; 0x1b6a <xQueueCRSend+0x44>
    1b66:	80 e0       	ldi	r24, 0x00	; 0
    1b68:	10 c0       	rjmp	.+32     	; 0x1b8a <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1b6a:	ce 01       	movw	r24, r28
    1b6c:	40 e0       	ldi	r20, 0x00	; 0
    1b6e:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b72:	89 89       	ldd	r24, Y+17	; 0x11
    1b74:	88 23       	and	r24, r24
    1b76:	41 f0       	breq	.+16     	; 0x1b88 <xQueueCRSend+0x62>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b78:	ce 01       	movw	r24, r28
    1b7a:	41 96       	adiw	r24, 0x11	; 17
    1b7c:	0e 94 70 06 	call	0xce0	; 0xce0 <xCoRoutineRemoveFromEventList>
    1b80:	88 23       	and	r24, r24
    1b82:	11 f0       	breq	.+4      	; 0x1b88 <xQueueCRSend+0x62>
    1b84:	8b ef       	ldi	r24, 0xFB	; 251
    1b86:	01 c0       	rjmp	.+2      	; 0x1b8a <xQueueCRSend+0x64>
    1b88:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    1b8a:	78 94       	sei

		return xReturn;
	}
    1b8c:	df 91       	pop	r29
    1b8e:	cf 91       	pop	r28
    1b90:	08 95       	ret

00001b92 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1b92:	cf 93       	push	r28
    1b94:	df 93       	push	r29
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1b96:	ec 01       	movw	r28, r24
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    1b98:	88 81       	ld	r24, Y
    1b9a:	99 81       	ldd	r25, Y+1	; 0x01
    1b9c:	00 97       	sbiw	r24, 0x00	; 0
    1b9e:	11 f0       	breq	.+4      	; 0x1ba4 <vQueueDelete+0x12>
	{
		vPortFree( pxQueue->pcHead );
    1ba0:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortFree>
	}
	vPortFree( pxQueue );
    1ba4:	ce 01       	movw	r24, r28
    1ba6:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortFree>
}
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	08 95       	ret

00001bb0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1bb0:	0f 93       	push	r16
    1bb2:	1f 93       	push	r17
    1bb4:	cf 93       	push	r28
    1bb6:	df 93       	push	r29
    1bb8:	8a 01       	movw	r16, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1bba:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bbc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1bbe:	88 23       	and	r24, r24
    1bc0:	e9 f0       	breq	.+58     	; 0x1bfc <xQueueReceiveFromISR+0x4c>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1bc2:	ce 01       	movw	r24, r28
    1bc4:	0e 94 c1 0c 	call	0x1982	; 0x1982 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1bc8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1bca:	81 50       	subi	r24, 0x01	; 1
    1bcc:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1bce:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1bd0:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd2:	81 f4       	brne	.+32     	; 0x1bf4 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1bd4:	88 85       	ldd	r24, Y+8	; 0x08
    1bd6:	88 23       	and	r24, r24
    1bd8:	81 f0       	breq	.+32     	; 0x1bfa <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bda:	ce 01       	movw	r24, r28
    1bdc:	08 96       	adiw	r24, 0x08	; 8
    1bde:	0e 94 36 11 	call	0x226c	; 0x226c <xTaskRemoveFromEventList>
    1be2:	88 23       	and	r24, r24
    1be4:	51 f0       	breq	.+20     	; 0x1bfa <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1be6:	01 15       	cp	r16, r1
    1be8:	11 05       	cpc	r17, r1
    1bea:	39 f0       	breq	.+14     	; 0x1bfa <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	f8 01       	movw	r30, r16
    1bf0:	80 83       	st	Z, r24
    1bf2:	04 c0       	rjmp	.+8      	; 0x1bfc <xQueueReceiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1bf4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1bf6:	8f 5f       	subi	r24, 0xFF	; 255
    1bf8:	8d 8f       	std	Y+29, r24	; 0x1d
    1bfa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1bfc:	df 91       	pop	r29
    1bfe:	cf 91       	pop	r28
    1c00:	1f 91       	pop	r17
    1c02:	0f 91       	pop	r16
    1c04:	08 95       	ret

00001c06 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1c06:	0f 93       	push	r16
    1c08:	1f 93       	push	r17
    1c0a:	cf 93       	push	r28
    1c0c:	df 93       	push	r29
    1c0e:	8a 01       	movw	r16, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1c10:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1c12:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c14:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c16:	98 17       	cp	r25, r24
    1c18:	20 f0       	brcs	.+8      	; 0x1c22 <xQueueGenericSendFromISR+0x1c>
    1c1a:	22 30       	cpi	r18, 0x02	; 2
    1c1c:	11 f0       	breq	.+4      	; 0x1c22 <xQueueGenericSendFromISR+0x1c>
    1c1e:	80 e0       	ldi	r24, 0x00	; 0
    1c20:	23 c0       	rjmp	.+70     	; 0x1c68 <xQueueGenericSendFromISR+0x62>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1c22:	ce 01       	movw	r24, r28
    1c24:	42 2f       	mov	r20, r18
    1c26:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvCopyDataToQueue>
    1c2a:	88 23       	and	r24, r24
    1c2c:	31 f0       	breq	.+12     	; 0x1c3a <xQueueGenericSendFromISR+0x34>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1c2e:	01 15       	cp	r16, r1
    1c30:	11 05       	cpc	r17, r1
    1c32:	19 f0       	breq	.+6      	; 0x1c3a <xQueueGenericSendFromISR+0x34>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	f8 01       	movw	r30, r16
    1c38:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1c3a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1c3e:	81 f4       	brne	.+32     	; 0x1c60 <xQueueGenericSendFromISR+0x5a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c40:	89 89       	ldd	r24, Y+17	; 0x11
    1c42:	88 23       	and	r24, r24
    1c44:	81 f0       	breq	.+32     	; 0x1c66 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c46:	ce 01       	movw	r24, r28
    1c48:	41 96       	adiw	r24, 0x11	; 17
    1c4a:	0e 94 36 11 	call	0x226c	; 0x226c <xTaskRemoveFromEventList>
    1c4e:	88 23       	and	r24, r24
    1c50:	51 f0       	breq	.+20     	; 0x1c66 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1c52:	01 15       	cp	r16, r1
    1c54:	11 05       	cpc	r17, r1
    1c56:	39 f0       	breq	.+14     	; 0x1c66 <xQueueGenericSendFromISR+0x60>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1c58:	81 e0       	ldi	r24, 0x01	; 1
    1c5a:	f8 01       	movw	r30, r16
    1c5c:	80 83       	st	Z, r24
    1c5e:	04 c0       	rjmp	.+8      	; 0x1c68 <xQueueGenericSendFromISR+0x62>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1c60:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c62:	8f 5f       	subi	r24, 0xFF	; 255
    1c64:	8e 8f       	std	Y+30, r24	; 0x1e
    1c66:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1c68:	df 91       	pop	r29
    1c6a:	cf 91       	pop	r28
    1c6c:	1f 91       	pop	r17
    1c6e:	0f 91       	pop	r16
    1c70:	08 95       	ret

00001c72 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1c72:	0f 93       	push	r16
    1c74:	1f 93       	push	r17
    1c76:	cf 93       	push	r28
    1c78:	df 93       	push	r29
    1c7a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1c7c:	0f b6       	in	r0, 0x3f	; 63
    1c7e:	f8 94       	cli
    1c80:	0f 92       	push	r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c82:	8c 01       	movw	r16, r24
    1c84:	0f 5e       	subi	r16, 0xEF	; 239
    1c86:	1f 4f       	sbci	r17, 0xFF	; 255
    1c88:	0d c0       	rjmp	.+26     	; 0x1ca4 <prvUnlockQueue+0x32>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c8a:	89 89       	ldd	r24, Y+17	; 0x11
    1c8c:	88 23       	and	r24, r24
    1c8e:	69 f0       	breq	.+26     	; 0x1caa <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c90:	c8 01       	movw	r24, r16
    1c92:	0e 94 36 11 	call	0x226c	; 0x226c <xTaskRemoveFromEventList>
    1c96:	88 23       	and	r24, r24
    1c98:	11 f0       	breq	.+4      	; 0x1c9e <prvUnlockQueue+0x2c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1c9a:	0e 94 e6 10 	call	0x21cc	; 0x21cc <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1c9e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ca0:	81 50       	subi	r24, 0x01	; 1
    1ca2:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1ca4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ca6:	18 16       	cp	r1, r24
    1ca8:	84 f3       	brlt	.-32     	; 0x1c8a <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1caa:	8f ef       	ldi	r24, 0xFF	; 255
    1cac:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1cae:	0f 90       	pop	r0
    1cb0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cb8:	8e 01       	movw	r16, r28
    1cba:	08 5f       	subi	r16, 0xF8	; 248
    1cbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1cbe:	0d c0       	rjmp	.+26     	; 0x1cda <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1cc0:	88 85       	ldd	r24, Y+8	; 0x08
    1cc2:	88 23       	and	r24, r24
    1cc4:	69 f0       	breq	.+26     	; 0x1ce0 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cc6:	c8 01       	movw	r24, r16
    1cc8:	0e 94 36 11 	call	0x226c	; 0x226c <xTaskRemoveFromEventList>
    1ccc:	88 23       	and	r24, r24
    1cce:	11 f0       	breq	.+4      	; 0x1cd4 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    1cd0:	0e 94 e6 10 	call	0x21cc	; 0x21cc <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1cd4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1cd6:	81 50       	subi	r24, 0x01	; 1
    1cd8:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1cda:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1cdc:	18 16       	cp	r1, r24
    1cde:	84 f3       	brlt	.-32     	; 0x1cc0 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1ce0:	8f ef       	ldi	r24, 0xFF	; 255
    1ce2:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1ce4:	0f 90       	pop	r0
    1ce6:	0f be       	out	0x3f, r0	; 63
}
    1ce8:	df 91       	pop	r29
    1cea:	cf 91       	pop	r28
    1cec:	1f 91       	pop	r17
    1cee:	0f 91       	pop	r16
    1cf0:	08 95       	ret

00001cf2 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1cf2:	7f 92       	push	r7
    1cf4:	8f 92       	push	r8
    1cf6:	9f 92       	push	r9
    1cf8:	af 92       	push	r10
    1cfa:	bf 92       	push	r11
    1cfc:	cf 92       	push	r12
    1cfe:	df 92       	push	r13
    1d00:	ef 92       	push	r14
    1d02:	ff 92       	push	r15
    1d04:	0f 93       	push	r16
    1d06:	1f 93       	push	r17
    1d08:	df 93       	push	r29
    1d0a:	cf 93       	push	r28
    1d0c:	00 d0       	rcall	.+0      	; 0x1d0e <xQueueGenericReceive+0x1c>
    1d0e:	00 d0       	rcall	.+0      	; 0x1d10 <xQueueGenericReceive+0x1e>
    1d10:	0f 92       	push	r0
    1d12:	cd b7       	in	r28, 0x3d	; 61
    1d14:	de b7       	in	r29, 0x3e	; 62
    1d16:	5b 01       	movw	r10, r22
    1d18:	5d 83       	std	Y+5, r21	; 0x05
    1d1a:	4c 83       	std	Y+4, r20	; 0x04
    1d1c:	72 2e       	mov	r7, r18
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d1e:	8c 01       	movw	r16, r24
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d20:	91 e1       	ldi	r25, 0x11	; 17
    1d22:	c9 2e       	mov	r12, r25
    1d24:	d1 2c       	mov	r13, r1
    1d26:	c0 0e       	add	r12, r16
    1d28:	d1 1e       	adc	r13, r17
    1d2a:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1d2c:	7e 01       	movw	r14, r28
    1d2e:	08 94       	sec
    1d30:	e1 1c       	adc	r14, r1
    1d32:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d34:	84 e0       	ldi	r24, 0x04	; 4
    1d36:	88 2e       	mov	r8, r24
    1d38:	91 2c       	mov	r9, r1
    1d3a:	8c 0e       	add	r8, r28
    1d3c:	9d 1e       	adc	r9, r29
    1d3e:	01 c0       	rjmp	.+2      	; 0x1d42 <xQueueGenericReceive+0x50>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d40:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1d42:	0f b6       	in	r0, 0x3f	; 63
    1d44:	f8 94       	cli
    1d46:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d48:	f8 01       	movw	r30, r16
    1d4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d4c:	88 23       	and	r24, r24
    1d4e:	39 f1       	breq	.+78     	; 0x1d9e <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1d50:	e6 80       	ldd	r14, Z+6	; 0x06
    1d52:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d54:	c8 01       	movw	r24, r16
    1d56:	b5 01       	movw	r22, r10
    1d58:	0e 94 c1 0c 	call	0x1982	; 0x1982 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1d5c:	77 20       	and	r7, r7
    1d5e:	71 f4       	brne	.+28     	; 0x1d7c <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1d60:	f8 01       	movw	r30, r16
    1d62:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d64:	81 50       	subi	r24, 0x01	; 1
    1d66:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d68:	80 85       	ldd	r24, Z+8	; 0x08
    1d6a:	88 23       	and	r24, r24
    1d6c:	a1 f0       	breq	.+40     	; 0x1d96 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1d6e:	c8 01       	movw	r24, r16
    1d70:	08 96       	adiw	r24, 0x08	; 8
    1d72:	0e 94 36 11 	call	0x226c	; 0x226c <xTaskRemoveFromEventList>
    1d76:	81 30       	cpi	r24, 0x01	; 1
    1d78:	71 f4       	brne	.+28     	; 0x1d96 <xQueueGenericReceive+0xa4>
    1d7a:	0b c0       	rjmp	.+22     	; 0x1d92 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1d7c:	f8 01       	movw	r30, r16
    1d7e:	f7 82       	std	Z+7, r15	; 0x07
    1d80:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d82:	81 89       	ldd	r24, Z+17	; 0x11
    1d84:	88 23       	and	r24, r24
    1d86:	39 f0       	breq	.+14     	; 0x1d96 <xQueueGenericReceive+0xa4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d88:	c6 01       	movw	r24, r12
    1d8a:	0e 94 36 11 	call	0x226c	; 0x226c <xTaskRemoveFromEventList>
    1d8e:	88 23       	and	r24, r24
    1d90:	11 f0       	breq	.+4      	; 0x1d96 <xQueueGenericReceive+0xa4>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1d92:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1d96:	0f 90       	pop	r0
    1d98:	0f be       	out	0x3f, r0	; 63
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	4a c0       	rjmp	.+148    	; 0x1e32 <xQueueGenericReceive+0x140>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1d9e:	8c 81       	ldd	r24, Y+4	; 0x04
    1da0:	9d 81       	ldd	r25, Y+5	; 0x05
    1da2:	89 2b       	or	r24, r25
    1da4:	19 f4       	brne	.+6      	; 0x1dac <xQueueGenericReceive+0xba>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1da6:	0f 90       	pop	r0
    1da8:	0f be       	out	0x3f, r0	; 63
    1daa:	42 c0       	rjmp	.+132    	; 0x1e30 <xQueueGenericReceive+0x13e>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1dac:	22 23       	and	r18, r18
    1dae:	19 f4       	brne	.+6      	; 0x1db6 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1db0:	c7 01       	movw	r24, r14
    1db2:	0e 94 a8 10 	call	0x2150	; 0x2150 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1db6:	0f 90       	pop	r0
    1db8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1dba:	0e 94 45 10 	call	0x208a	; 0x208a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	0f 92       	push	r0
    1dc4:	f8 01       	movw	r30, r16
    1dc6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dc8:	8f 3f       	cpi	r24, 0xFF	; 255
    1dca:	09 f4       	brne	.+2      	; 0x1dce <xQueueGenericReceive+0xdc>
    1dcc:	15 8e       	std	Z+29, r1	; 0x1d
    1dce:	f8 01       	movw	r30, r16
    1dd0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dd2:	8f 3f       	cpi	r24, 0xFF	; 255
    1dd4:	09 f4       	brne	.+2      	; 0x1dd8 <xQueueGenericReceive+0xe6>
    1dd6:	16 8e       	std	Z+30, r1	; 0x1e
    1dd8:	0f 90       	pop	r0
    1dda:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ddc:	c7 01       	movw	r24, r14
    1dde:	b4 01       	movw	r22, r8
    1de0:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskCheckForTimeOut>
    1de4:	88 23       	and	r24, r24
    1de6:	f9 f4       	brne	.+62     	; 0x1e26 <xQueueGenericReceive+0x134>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1de8:	0f b6       	in	r0, 0x3f	; 63
    1dea:	f8 94       	cli
    1dec:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1dee:	f8 01       	movw	r30, r16
    1df0:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1df2:	0f 90       	pop	r0
    1df4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1df6:	88 23       	and	r24, r24
    1df8:	81 f4       	brne	.+32     	; 0x1e1a <xQueueGenericReceive+0x128>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1dfa:	6c 81       	ldd	r22, Y+4	; 0x04
    1dfc:	7d 81       	ldd	r23, Y+5	; 0x05
    1dfe:	c6 01       	movw	r24, r12
    1e00:	0e 94 9b 12 	call	0x2536	; 0x2536 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1e04:	c8 01       	movw	r24, r16
    1e06:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1e0a:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
    1e0e:	88 23       	and	r24, r24
    1e10:	09 f0       	breq	.+2      	; 0x1e14 <xQueueGenericReceive+0x122>
    1e12:	96 cf       	rjmp	.-212    	; 0x1d40 <xQueueGenericReceive+0x4e>
				{
					portYIELD_WITHIN_API();
    1e14:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
    1e18:	93 cf       	rjmp	.-218    	; 0x1d40 <xQueueGenericReceive+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1e1a:	c8 01       	movw	r24, r16
    1e1c:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1e20:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
    1e24:	8d cf       	rjmp	.-230    	; 0x1d40 <xQueueGenericReceive+0x4e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1e26:	c8 01       	movw	r24, r16
    1e28:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1e2c:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
    1e30:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    1e32:	0f 90       	pop	r0
    1e34:	0f 90       	pop	r0
    1e36:	0f 90       	pop	r0
    1e38:	0f 90       	pop	r0
    1e3a:	0f 90       	pop	r0
    1e3c:	cf 91       	pop	r28
    1e3e:	df 91       	pop	r29
    1e40:	1f 91       	pop	r17
    1e42:	0f 91       	pop	r16
    1e44:	ff 90       	pop	r15
    1e46:	ef 90       	pop	r14
    1e48:	df 90       	pop	r13
    1e4a:	cf 90       	pop	r12
    1e4c:	bf 90       	pop	r11
    1e4e:	af 90       	pop	r10
    1e50:	9f 90       	pop	r9
    1e52:	8f 90       	pop	r8
    1e54:	7f 90       	pop	r7
    1e56:	08 95       	ret

00001e58 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1e58:	6f 92       	push	r6
    1e5a:	7f 92       	push	r7
    1e5c:	9f 92       	push	r9
    1e5e:	af 92       	push	r10
    1e60:	bf 92       	push	r11
    1e62:	cf 92       	push	r12
    1e64:	df 92       	push	r13
    1e66:	ef 92       	push	r14
    1e68:	ff 92       	push	r15
    1e6a:	0f 93       	push	r16
    1e6c:	1f 93       	push	r17
    1e6e:	df 93       	push	r29
    1e70:	cf 93       	push	r28
    1e72:	00 d0       	rcall	.+0      	; 0x1e74 <xQueueGenericSend+0x1c>
    1e74:	00 d0       	rcall	.+0      	; 0x1e76 <xQueueGenericSend+0x1e>
    1e76:	0f 92       	push	r0
    1e78:	cd b7       	in	r28, 0x3d	; 61
    1e7a:	de b7       	in	r29, 0x3e	; 62
    1e7c:	6b 01       	movw	r12, r22
    1e7e:	5d 83       	std	Y+5, r21	; 0x05
    1e80:	4c 83       	std	Y+4, r20	; 0x04
    1e82:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1e84:	8c 01       	movw	r16, r24
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1e86:	48 e0       	ldi	r20, 0x08	; 8
    1e88:	e4 2e       	mov	r14, r20
    1e8a:	f1 2c       	mov	r15, r1
    1e8c:	e8 0e       	add	r14, r24
    1e8e:	f9 1e       	adc	r15, r25
    1e90:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e92:	5e 01       	movw	r10, r28
    1e94:	08 94       	sec
    1e96:	a1 1c       	adc	r10, r1
    1e98:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e9a:	34 e0       	ldi	r19, 0x04	; 4
    1e9c:	63 2e       	mov	r6, r19
    1e9e:	71 2c       	mov	r7, r1
    1ea0:	6c 0e       	add	r6, r28
    1ea2:	7d 1e       	adc	r7, r29
    1ea4:	01 c0       	rjmp	.+2      	; 0x1ea8 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ea6:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1ea8:	0f b6       	in	r0, 0x3f	; 63
    1eaa:	f8 94       	cli
    1eac:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1eae:	f8 01       	movw	r30, r16
    1eb0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1eb2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1eb4:	98 17       	cp	r25, r24
    1eb6:	18 f0       	brcs	.+6      	; 0x1ebe <xQueueGenericSend+0x66>
    1eb8:	f2 e0       	ldi	r31, 0x02	; 2
    1eba:	9f 16       	cp	r9, r31
    1ebc:	c9 f4       	brne	.+50     	; 0x1ef0 <xQueueGenericSend+0x98>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1ebe:	c8 01       	movw	r24, r16
    1ec0:	b6 01       	movw	r22, r12
    1ec2:	49 2d       	mov	r20, r9
    1ec4:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvCopyDataToQueue>
    1ec8:	98 2f       	mov	r25, r24
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1eca:	f8 01       	movw	r30, r16
    1ecc:	81 89       	ldd	r24, Z+17	; 0x11
    1ece:	88 23       	and	r24, r24
    1ed0:	39 f0       	breq	.+14     	; 0x1ee0 <xQueueGenericSend+0x88>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1ed2:	c8 01       	movw	r24, r16
    1ed4:	41 96       	adiw	r24, 0x11	; 17
    1ed6:	0e 94 36 11 	call	0x226c	; 0x226c <xTaskRemoveFromEventList>
    1eda:	81 30       	cpi	r24, 0x01	; 1
    1edc:	29 f4       	brne	.+10     	; 0x1ee8 <xQueueGenericSend+0x90>
    1ede:	02 c0       	rjmp	.+4      	; 0x1ee4 <xQueueGenericSend+0x8c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1ee0:	99 23       	and	r25, r25
    1ee2:	11 f0       	breq	.+4      	; 0x1ee8 <xQueueGenericSend+0x90>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1ee4:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1ee8:	0f 90       	pop	r0
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	81 e0       	ldi	r24, 0x01	; 1
    1eee:	4c c0       	rjmp	.+152    	; 0x1f88 <xQueueGenericSend+0x130>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1ef0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ef2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ef4:	89 2b       	or	r24, r25
    1ef6:	19 f4       	brne	.+6      	; 0x1efe <xQueueGenericSend+0xa6>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ef8:	0f 90       	pop	r0
    1efa:	0f be       	out	0x3f, r0	; 63
    1efc:	44 c0       	rjmp	.+136    	; 0x1f86 <xQueueGenericSend+0x12e>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1efe:	22 23       	and	r18, r18
    1f00:	19 f4       	brne	.+6      	; 0x1f08 <xQueueGenericSend+0xb0>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f02:	c5 01       	movw	r24, r10
    1f04:	0e 94 a8 10 	call	0x2150	; 0x2150 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f08:	0f 90       	pop	r0
    1f0a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f0c:	0e 94 45 10 	call	0x208a	; 0x208a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	0f 92       	push	r0
    1f16:	f8 01       	movw	r30, r16
    1f18:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f1a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f1c:	09 f4       	brne	.+2      	; 0x1f20 <xQueueGenericSend+0xc8>
    1f1e:	15 8e       	std	Z+29, r1	; 0x1d
    1f20:	f8 01       	movw	r30, r16
    1f22:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f24:	8f 3f       	cpi	r24, 0xFF	; 255
    1f26:	09 f4       	brne	.+2      	; 0x1f2a <xQueueGenericSend+0xd2>
    1f28:	16 8e       	std	Z+30, r1	; 0x1e
    1f2a:	0f 90       	pop	r0
    1f2c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f2e:	c5 01       	movw	r24, r10
    1f30:	b3 01       	movw	r22, r6
    1f32:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskCheckForTimeOut>
    1f36:	88 23       	and	r24, r24
    1f38:	09 f5       	brne	.+66     	; 0x1f7c <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1f3a:	0f b6       	in	r0, 0x3f	; 63
    1f3c:	f8 94       	cli
    1f3e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f40:	f8 01       	movw	r30, r16
    1f42:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1f44:	0f 90       	pop	r0
    1f46:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1f48:	f8 01       	movw	r30, r16
    1f4a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f4c:	98 17       	cp	r25, r24
    1f4e:	81 f4       	brne	.+32     	; 0x1f70 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1f50:	6c 81       	ldd	r22, Y+4	; 0x04
    1f52:	7d 81       	ldd	r23, Y+5	; 0x05
    1f54:	c7 01       	movw	r24, r14
    1f56:	0e 94 9b 12 	call	0x2536	; 0x2536 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1f5a:	c8 01       	movw	r24, r16
    1f5c:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1f60:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
    1f64:	88 23       	and	r24, r24
    1f66:	09 f0       	breq	.+2      	; 0x1f6a <xQueueGenericSend+0x112>
    1f68:	9e cf       	rjmp	.-196    	; 0x1ea6 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    1f6a:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
    1f6e:	9b cf       	rjmp	.-202    	; 0x1ea6 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f70:	c8 01       	movw	r24, r16
    1f72:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f76:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
    1f7a:	95 cf       	rjmp	.-214    	; 0x1ea6 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1f7c:	c8 01       	movw	r24, r16
    1f7e:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f82:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
    1f86:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1f88:	0f 90       	pop	r0
    1f8a:	0f 90       	pop	r0
    1f8c:	0f 90       	pop	r0
    1f8e:	0f 90       	pop	r0
    1f90:	0f 90       	pop	r0
    1f92:	cf 91       	pop	r28
    1f94:	df 91       	pop	r29
    1f96:	1f 91       	pop	r17
    1f98:	0f 91       	pop	r16
    1f9a:	ff 90       	pop	r15
    1f9c:	ef 90       	pop	r14
    1f9e:	df 90       	pop	r13
    1fa0:	cf 90       	pop	r12
    1fa2:	bf 90       	pop	r11
    1fa4:	af 90       	pop	r10
    1fa6:	9f 90       	pop	r9
    1fa8:	7f 90       	pop	r7
    1faa:	6f 90       	pop	r6
    1fac:	08 95       	ret

00001fae <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1fae:	cf 93       	push	r28
    1fb0:	df 93       	push	r29
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1fb2:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1fb4:	0f b6       	in	r0, 0x3f	; 63
    1fb6:	f8 94       	cli
    1fb8:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1fba:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1fbc:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1fbe:	e2 9f       	mul	r30, r18
    1fc0:	c0 01       	movw	r24, r0
    1fc2:	11 24       	eor	r1, r1
    1fc4:	48 81       	ld	r20, Y
    1fc6:	59 81       	ldd	r21, Y+1	; 0x01
    1fc8:	84 0f       	add	r24, r20
    1fca:	95 1f       	adc	r25, r21
    1fcc:	9b 83       	std	Y+3, r25	; 0x03
    1fce:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1fd0:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1fd2:	5d 83       	std	Y+5, r21	; 0x05
    1fd4:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1fd6:	30 e0       	ldi	r19, 0x00	; 0
    1fd8:	21 50       	subi	r18, 0x01	; 1
    1fda:	30 40       	sbci	r19, 0x00	; 0
    1fdc:	f0 e0       	ldi	r31, 0x00	; 0
    1fde:	2e 9f       	mul	r18, r30
    1fe0:	c0 01       	movw	r24, r0
    1fe2:	2f 9f       	mul	r18, r31
    1fe4:	90 0d       	add	r25, r0
    1fe6:	3e 9f       	mul	r19, r30
    1fe8:	90 0d       	add	r25, r0
    1fea:	11 24       	eor	r1, r1
    1fec:	48 0f       	add	r20, r24
    1fee:	59 1f       	adc	r21, r25
    1ff0:	5f 83       	std	Y+7, r21	; 0x07
    1ff2:	4e 83       	std	Y+6, r20	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1ff4:	8f ef       	ldi	r24, 0xFF	; 255
    1ff6:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1ff8:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1ffa:	66 23       	and	r22, r22
    1ffc:	61 f4       	brne	.+24     	; 0x2016 <xQueueGenericReset+0x68>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ffe:	88 85       	ldd	r24, Y+8	; 0x08
    2000:	88 23       	and	r24, r24
    2002:	89 f0       	breq	.+34     	; 0x2026 <xQueueGenericReset+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2004:	ce 01       	movw	r24, r28
    2006:	08 96       	adiw	r24, 0x08	; 8
    2008:	0e 94 36 11 	call	0x226c	; 0x226c <xTaskRemoveFromEventList>
    200c:	81 30       	cpi	r24, 0x01	; 1
    200e:	59 f4       	brne	.+22     	; 0x2026 <xQueueGenericReset+0x78>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2010:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
    2014:	08 c0       	rjmp	.+16     	; 0x2026 <xQueueGenericReset+0x78>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2016:	ce 01       	movw	r24, r28
    2018:	08 96       	adiw	r24, 0x08	; 8
    201a:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    201e:	ce 01       	movw	r24, r28
    2020:	41 96       	adiw	r24, 0x11	; 17
    2022:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2026:	0f 90       	pop	r0
    2028:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	df 91       	pop	r29
    202e:	cf 91       	pop	r28
    2030:	08 95       	ret

00002032 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2032:	0f 93       	push	r16
    2034:	1f 93       	push	r17
    2036:	cf 93       	push	r28
    2038:	df 93       	push	r29
    203a:	18 2f       	mov	r17, r24
    203c:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    203e:	88 23       	and	r24, r24
    2040:	e1 f0       	breq	.+56     	; 0x207a <xQueueGenericCreate+0x48>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    2042:	8f e1       	ldi	r24, 0x1F	; 31
    2044:	90 e0       	ldi	r25, 0x00	; 0
    2046:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <pvPortMalloc>
    204a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    204c:	00 97       	sbiw	r24, 0x00	; 0
    204e:	a9 f0       	breq	.+42     	; 0x207a <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    2050:	01 9f       	mul	r16, r17
    2052:	c0 01       	movw	r24, r0
    2054:	11 24       	eor	r1, r1
    2056:	01 96       	adiw	r24, 0x01	; 1
    2058:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <pvPortMalloc>
    205c:	99 83       	std	Y+1, r25	; 0x01
    205e:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    2060:	00 97       	sbiw	r24, 0x00	; 0
    2062:	41 f0       	breq	.+16     	; 0x2074 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    2064:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2066:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2068:	ce 01       	movw	r24, r28
    206a:	61 e0       	ldi	r22, 0x01	; 1
    206c:	0e 94 d7 0f 	call	0x1fae	; 0x1fae <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2070:	9e 01       	movw	r18, r28
    2072:	05 c0       	rjmp	.+10     	; 0x207e <xQueueGenericCreate+0x4c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    2074:	ce 01       	movw	r24, r28
    2076:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortFree>
    207a:	20 e0       	ldi	r18, 0x00	; 0
    207c:	30 e0       	ldi	r19, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    207e:	c9 01       	movw	r24, r18
    2080:	df 91       	pop	r29
    2082:	cf 91       	pop	r28
    2084:	1f 91       	pop	r17
    2086:	0f 91       	pop	r16
    2088:	08 95       	ret

0000208a <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    208a:	80 91 5a 06 	lds	r24, 0x065A
    208e:	8f 5f       	subi	r24, 0xFF	; 255
    2090:	80 93 5a 06 	sts	0x065A, r24
}
    2094:	08 95       	ret

00002096 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    209c:	20 91 56 06 	lds	r18, 0x0656
    20a0:	30 91 57 06 	lds	r19, 0x0657
	}
	taskEXIT_CRITICAL();
    20a4:	0f 90       	pop	r0
    20a6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    20a8:	c9 01       	movw	r24, r18
    20aa:	08 95       	ret

000020ac <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    20ac:	20 91 56 06 	lds	r18, 0x0656
    20b0:	30 91 57 06 	lds	r19, 0x0657
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    20b4:	c9 01       	movw	r24, r18
    20b6:	08 95       	ret

000020b8 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    20b8:	80 91 5c 06 	lds	r24, 0x065C
}
    20bc:	08 95       	ret

000020be <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    20be:	80 91 5a 06 	lds	r24, 0x065A
    20c2:	88 23       	and	r24, r24
    20c4:	21 f0       	breq	.+8      	; 0x20ce <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    20c6:	81 e0       	ldi	r24, 0x01	; 1
    20c8:	80 93 55 06 	sts	0x0655, r24
    20cc:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    20ce:	10 92 55 06 	sts	0x0655, r1
    20d2:	05 c0       	rjmp	.+10     	; 0x20de <vTaskSwitchContext+0x20>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    20d4:	80 91 59 06 	lds	r24, 0x0659
    20d8:	81 50       	subi	r24, 0x01	; 1
    20da:	80 93 59 06 	sts	0x0659, r24
    20de:	80 91 59 06 	lds	r24, 0x0659
    20e2:	90 e0       	ldi	r25, 0x00	; 0
    20e4:	fc 01       	movw	r30, r24
    20e6:	23 e0       	ldi	r18, 0x03	; 3
    20e8:	ee 0f       	add	r30, r30
    20ea:	ff 1f       	adc	r31, r31
    20ec:	2a 95       	dec	r18
    20ee:	e1 f7       	brne	.-8      	; 0x20e8 <vTaskSwitchContext+0x2a>
    20f0:	e8 0f       	add	r30, r24
    20f2:	f9 1f       	adc	r31, r25
    20f4:	e1 5a       	subi	r30, 0xA1	; 161
    20f6:	f9 4f       	sbci	r31, 0xF9	; 249
    20f8:	80 81       	ld	r24, Z
    20fa:	88 23       	and	r24, r24
    20fc:	59 f3       	breq	.-42     	; 0x20d4 <vTaskSwitchContext+0x16>
    20fe:	90 91 59 06 	lds	r25, 0x0659
    2102:	89 e0       	ldi	r24, 0x09	; 9
    2104:	98 9f       	mul	r25, r24
    2106:	d0 01       	movw	r26, r0
    2108:	11 24       	eor	r1, r1
    210a:	a1 5a       	subi	r26, 0xA1	; 161
    210c:	b9 4f       	sbci	r27, 0xF9	; 249
    210e:	11 96       	adiw	r26, 0x01	; 1
    2110:	ed 91       	ld	r30, X+
    2112:	fc 91       	ld	r31, X
    2114:	12 97       	sbiw	r26, 0x02	; 2
    2116:	02 80       	ldd	r0, Z+2	; 0x02
    2118:	f3 81       	ldd	r31, Z+3	; 0x03
    211a:	e0 2d       	mov	r30, r0
    211c:	12 96       	adiw	r26, 0x02	; 2
    211e:	fc 93       	st	X, r31
    2120:	ee 93       	st	-X, r30
    2122:	11 97       	sbiw	r26, 0x01	; 1
    2124:	cd 01       	movw	r24, r26
    2126:	03 96       	adiw	r24, 0x03	; 3
    2128:	e8 17       	cp	r30, r24
    212a:	f9 07       	cpc	r31, r25
    212c:	31 f4       	brne	.+12     	; 0x213a <vTaskSwitchContext+0x7c>
    212e:	82 81       	ldd	r24, Z+2	; 0x02
    2130:	93 81       	ldd	r25, Z+3	; 0x03
    2132:	12 96       	adiw	r26, 0x02	; 2
    2134:	9c 93       	st	X, r25
    2136:	8e 93       	st	-X, r24
    2138:	11 97       	sbiw	r26, 0x01	; 1
    213a:	11 96       	adiw	r26, 0x01	; 1
    213c:	ed 91       	ld	r30, X+
    213e:	fc 91       	ld	r31, X
    2140:	12 97       	sbiw	r26, 0x02	; 2
    2142:	86 81       	ldd	r24, Z+6	; 0x06
    2144:	97 81       	ldd	r25, Z+7	; 0x07
    2146:	90 93 54 06 	sts	0x0654, r25
    214a:	80 93 53 06 	sts	0x0653, r24
    214e:	08 95       	ret

00002150 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2150:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2152:	80 91 58 06 	lds	r24, 0x0658
    2156:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2158:	80 91 56 06 	lds	r24, 0x0656
    215c:	90 91 57 06 	lds	r25, 0x0657
    2160:	92 83       	std	Z+2, r25	; 0x02
    2162:	81 83       	std	Z+1, r24	; 0x01
}
    2164:	08 95       	ret

00002166 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2166:	fc 01       	movw	r30, r24
    2168:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    216a:	0f b6       	in	r0, 0x3f	; 63
    216c:	f8 94       	cli
    216e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2170:	40 91 56 06 	lds	r20, 0x0656
    2174:	50 91 57 06 	lds	r21, 0x0657
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2178:	90 91 58 06 	lds	r25, 0x0658
    217c:	80 81       	ld	r24, Z
    217e:	98 17       	cp	r25, r24
    2180:	29 f0       	breq	.+10     	; 0x218c <xTaskCheckForTimeOut+0x26>
    2182:	81 81       	ldd	r24, Z+1	; 0x01
    2184:	92 81       	ldd	r25, Z+2	; 0x02
    2186:	48 17       	cp	r20, r24
    2188:	59 07       	cpc	r21, r25
    218a:	e0 f4       	brcc	.+56     	; 0x21c4 <xTaskCheckForTimeOut+0x5e>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    218c:	21 81       	ldd	r18, Z+1	; 0x01
    218e:	32 81       	ldd	r19, Z+2	; 0x02
    2190:	6d 91       	ld	r22, X+
    2192:	7c 91       	ld	r23, X
    2194:	11 97       	sbiw	r26, 0x01	; 1
    2196:	ca 01       	movw	r24, r20
    2198:	82 1b       	sub	r24, r18
    219a:	93 0b       	sbc	r25, r19
    219c:	86 17       	cp	r24, r22
    219e:	97 07       	cpc	r25, r23
    21a0:	88 f4       	brcc	.+34     	; 0x21c4 <xTaskCheckForTimeOut+0x5e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    21a2:	24 1b       	sub	r18, r20
    21a4:	35 0b       	sbc	r19, r21
    21a6:	26 0f       	add	r18, r22
    21a8:	37 1f       	adc	r19, r23
    21aa:	2d 93       	st	X+, r18
    21ac:	3c 93       	st	X, r19
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    21ae:	80 91 58 06 	lds	r24, 0x0658
    21b2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    21b4:	80 91 56 06 	lds	r24, 0x0656
    21b8:	90 91 57 06 	lds	r25, 0x0657
    21bc:	92 83       	std	Z+2, r25	; 0x02
    21be:	81 83       	std	Z+1, r24	; 0x01
    21c0:	80 e0       	ldi	r24, 0x00	; 0
    21c2:	01 c0       	rjmp	.+2      	; 0x21c6 <xTaskCheckForTimeOut+0x60>
    21c4:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    21c6:	0f 90       	pop	r0
    21c8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    21ca:	08 95       	ret

000021cc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    21cc:	81 e0       	ldi	r24, 0x01	; 1
    21ce:	80 93 55 06 	sts	0x0655, r24
}
    21d2:	08 95       	ret

000021d4 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    21d4:	e0 91 53 06 	lds	r30, 0x0653
    21d8:	f0 91 54 06 	lds	r31, 0x0654
    21dc:	84 85       	ldd	r24, Z+12	; 0x0c
    21de:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    21e0:	a0 91 53 06 	lds	r26, 0x0653
    21e4:	b0 91 54 06 	lds	r27, 0x0654
    21e8:	e0 91 53 06 	lds	r30, 0x0653
    21ec:	f0 91 54 06 	lds	r31, 0x0654
    21f0:	46 89       	ldd	r20, Z+22	; 0x16
    21f2:	27 e0       	ldi	r18, 0x07	; 7
    21f4:	30 e0       	ldi	r19, 0x00	; 0
    21f6:	24 1b       	sub	r18, r20
    21f8:	31 09       	sbc	r19, r1
    21fa:	1d 96       	adiw	r26, 0x0d	; 13
    21fc:	3c 93       	st	X, r19
    21fe:	2e 93       	st	-X, r18
    2200:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
}
    2202:	08 95       	ret

00002204 <xTaskRemoveFromUnorderedEventList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2204:	0f 93       	push	r16
    2206:	1f 93       	push	r17
    2208:	cf 93       	push	r28
    220a:	df 93       	push	r29
    220c:	fc 01       	movw	r30, r24
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    220e:	70 68       	ori	r23, 0x80	; 128
    2210:	71 83       	std	Z+1, r23	; 0x01
    2212:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    2214:	c6 81       	ldd	r28, Z+6	; 0x06
    2216:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2218:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    221c:	8e 01       	movw	r16, r28
    221e:	0e 5f       	subi	r16, 0xFE	; 254
    2220:	1f 4f       	sbci	r17, 0xFF	; 255
    2222:	c8 01       	movw	r24, r16
    2224:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2228:	9e 89       	ldd	r25, Y+22	; 0x16
    222a:	80 91 59 06 	lds	r24, 0x0659
    222e:	89 17       	cp	r24, r25
    2230:	10 f4       	brcc	.+4      	; 0x2236 <xTaskRemoveFromUnorderedEventList+0x32>
    2232:	90 93 59 06 	sts	0x0659, r25
    2236:	89 e0       	ldi	r24, 0x09	; 9
    2238:	98 9f       	mul	r25, r24
    223a:	c0 01       	movw	r24, r0
    223c:	11 24       	eor	r1, r1
    223e:	81 5a       	subi	r24, 0xA1	; 161
    2240:	99 4f       	sbci	r25, 0xF9	; 249
    2242:	b8 01       	movw	r22, r16
    2244:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2248:	e0 91 53 06 	lds	r30, 0x0653
    224c:	f0 91 54 06 	lds	r31, 0x0654
    2250:	9e 89       	ldd	r25, Y+22	; 0x16
    2252:	86 89       	ldd	r24, Z+22	; 0x16
    2254:	89 17       	cp	r24, r25
    2256:	10 f0       	brcs	.+4      	; 0x225c <xTaskRemoveFromUnorderedEventList+0x58>
    2258:	80 e0       	ldi	r24, 0x00	; 0
    225a:	03 c0       	rjmp	.+6      	; 0x2262 <xTaskRemoveFromUnorderedEventList+0x5e>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    225c:	81 e0       	ldi	r24, 0x01	; 1
    225e:	80 93 55 06 	sts	0x0655, r24
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2262:	df 91       	pop	r29
    2264:	cf 91       	pop	r28
    2266:	1f 91       	pop	r17
    2268:	0f 91       	pop	r16
    226a:	08 95       	ret

0000226c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    226c:	0f 93       	push	r16
    226e:	1f 93       	push	r17
    2270:	cf 93       	push	r28
    2272:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2274:	dc 01       	movw	r26, r24
    2276:	15 96       	adiw	r26, 0x05	; 5
    2278:	ed 91       	ld	r30, X+
    227a:	fc 91       	ld	r31, X
    227c:	16 97       	sbiw	r26, 0x06	; 6
    227e:	c6 81       	ldd	r28, Z+6	; 0x06
    2280:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2282:	8e 01       	movw	r16, r28
    2284:	04 5f       	subi	r16, 0xF4	; 244
    2286:	1f 4f       	sbci	r17, 0xFF	; 255
    2288:	c8 01       	movw	r24, r16
    228a:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    228e:	80 91 5a 06 	lds	r24, 0x065A
    2292:	88 23       	and	r24, r24
    2294:	a1 f4       	brne	.+40     	; 0x22be <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2296:	8e 01       	movw	r16, r28
    2298:	0e 5f       	subi	r16, 0xFE	; 254
    229a:	1f 4f       	sbci	r17, 0xFF	; 255
    229c:	c8 01       	movw	r24, r16
    229e:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    22a2:	9e 89       	ldd	r25, Y+22	; 0x16
    22a4:	80 91 59 06 	lds	r24, 0x0659
    22a8:	89 17       	cp	r24, r25
    22aa:	10 f4       	brcc	.+4      	; 0x22b0 <xTaskRemoveFromEventList+0x44>
    22ac:	90 93 59 06 	sts	0x0659, r25
    22b0:	89 e0       	ldi	r24, 0x09	; 9
    22b2:	98 9f       	mul	r25, r24
    22b4:	c0 01       	movw	r24, r0
    22b6:	11 24       	eor	r1, r1
    22b8:	81 5a       	subi	r24, 0xA1	; 161
    22ba:	99 4f       	sbci	r25, 0xF9	; 249
    22bc:	02 c0       	rjmp	.+4      	; 0x22c2 <xTaskRemoveFromEventList+0x56>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    22be:	84 eb       	ldi	r24, 0xB4	; 180
    22c0:	96 e0       	ldi	r25, 0x06	; 6
    22c2:	b8 01       	movw	r22, r16
    22c4:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    22c8:	e0 91 53 06 	lds	r30, 0x0653
    22cc:	f0 91 54 06 	lds	r31, 0x0654
    22d0:	9e 89       	ldd	r25, Y+22	; 0x16
    22d2:	86 89       	ldd	r24, Z+22	; 0x16
    22d4:	89 17       	cp	r24, r25
    22d6:	10 f0       	brcs	.+4      	; 0x22dc <xTaskRemoveFromEventList+0x70>
    22d8:	80 e0       	ldi	r24, 0x00	; 0
    22da:	03 c0       	rjmp	.+6      	; 0x22e2 <xTaskRemoveFromEventList+0x76>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    22dc:	81 e0       	ldi	r24, 0x01	; 1
    22de:	80 93 55 06 	sts	0x0655, r24
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    22e2:	df 91       	pop	r29
    22e4:	cf 91       	pop	r28
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16
    22ea:	08 95       	ret

000022ec <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    22ec:	cf 92       	push	r12
    22ee:	df 92       	push	r13
    22f0:	ef 92       	push	r14
    22f2:	ff 92       	push	r15
    22f4:	0f 93       	push	r16
    22f6:	1f 93       	push	r17
    22f8:	cf 93       	push	r28
    22fa:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    22fc:	80 91 5a 06 	lds	r24, 0x065A
    2300:	88 23       	and	r24, r24
    2302:	09 f0       	breq	.+2      	; 0x2306 <xTaskIncrementTick+0x1a>
    2304:	a7 c0       	rjmp	.+334    	; 0x2454 <xTaskIncrementTick+0x168>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    2306:	80 91 56 06 	lds	r24, 0x0656
    230a:	90 91 57 06 	lds	r25, 0x0657
    230e:	01 96       	adiw	r24, 0x01	; 1
    2310:	90 93 57 06 	sts	0x0657, r25
    2314:	80 93 56 06 	sts	0x0656, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2318:	e0 90 56 06 	lds	r14, 0x0656
    231c:	f0 90 57 06 	lds	r15, 0x0657

			if( xConstTickCount == ( TickType_t ) 0U )
    2320:	e1 14       	cp	r14, r1
    2322:	f1 04       	cpc	r15, r1
    2324:	79 f5       	brne	.+94     	; 0x2384 <xTaskIncrementTick+0x98>
			{
				taskSWITCH_DELAYED_LISTS();
    2326:	20 91 b0 06 	lds	r18, 0x06B0
    232a:	30 91 b1 06 	lds	r19, 0x06B1
    232e:	80 91 b2 06 	lds	r24, 0x06B2
    2332:	90 91 b3 06 	lds	r25, 0x06B3
    2336:	90 93 b1 06 	sts	0x06B1, r25
    233a:	80 93 b0 06 	sts	0x06B0, r24
    233e:	30 93 b3 06 	sts	0x06B3, r19
    2342:	20 93 b2 06 	sts	0x06B2, r18
    2346:	80 91 58 06 	lds	r24, 0x0658
    234a:	8f 5f       	subi	r24, 0xFF	; 255
    234c:	80 93 58 06 	sts	0x0658, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2350:	e0 91 b0 06 	lds	r30, 0x06B0
    2354:	f0 91 b1 06 	lds	r31, 0x06B1
    2358:	80 81       	ld	r24, Z
    235a:	88 23       	and	r24, r24
    235c:	19 f4       	brne	.+6      	; 0x2364 <xTaskIncrementTick+0x78>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    235e:	8f ef       	ldi	r24, 0xFF	; 255
    2360:	9f ef       	ldi	r25, 0xFF	; 255
    2362:	0c c0       	rjmp	.+24     	; 0x237c <xTaskIncrementTick+0x90>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2364:	e0 91 b0 06 	lds	r30, 0x06B0
    2368:	f0 91 b1 06 	lds	r31, 0x06B1
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    236c:	05 80       	ldd	r0, Z+5	; 0x05
    236e:	f6 81       	ldd	r31, Z+6	; 0x06
    2370:	e0 2d       	mov	r30, r0
    2372:	06 80       	ldd	r0, Z+6	; 0x06
    2374:	f7 81       	ldd	r31, Z+7	; 0x07
    2376:	e0 2d       	mov	r30, r0
    2378:	82 81       	ldd	r24, Z+2	; 0x02
    237a:	93 81       	ldd	r25, Z+3	; 0x03
    237c:	90 93 0c 02 	sts	0x020C, r25
    2380:	80 93 0b 02 	sts	0x020B, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    2384:	80 91 0b 02 	lds	r24, 0x020B
    2388:	90 91 0c 02 	lds	r25, 0x020C
    238c:	e8 16       	cp	r14, r24
    238e:	f9 06       	cpc	r15, r25
    2390:	08 f4       	brcc	.+2      	; 0x2394 <xTaskIncrementTick+0xa8>
    2392:	49 c0       	rjmp	.+146    	; 0x2426 <xTaskIncrementTick+0x13a>
    2394:	dd 24       	eor	r13, r13
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    2396:	49 e0       	ldi	r20, 0x09	; 9
    2398:	c4 2e       	mov	r12, r20
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    239a:	e0 91 b0 06 	lds	r30, 0x06B0
    239e:	f0 91 b1 06 	lds	r31, 0x06B1
    23a2:	80 81       	ld	r24, Z
    23a4:	88 23       	and	r24, r24
    23a6:	19 f4       	brne	.+6      	; 0x23ae <xTaskIncrementTick+0xc2>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    23a8:	8f ef       	ldi	r24, 0xFF	; 255
    23aa:	9f ef       	ldi	r25, 0xFF	; 255
    23ac:	0e c0       	rjmp	.+28     	; 0x23ca <xTaskIncrementTick+0xde>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    23ae:	e0 91 b0 06 	lds	r30, 0x06B0
    23b2:	f0 91 b1 06 	lds	r31, 0x06B1
    23b6:	05 80       	ldd	r0, Z+5	; 0x05
    23b8:	f6 81       	ldd	r31, Z+6	; 0x06
    23ba:	e0 2d       	mov	r30, r0
    23bc:	c6 81       	ldd	r28, Z+6	; 0x06
    23be:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    23c0:	8a 81       	ldd	r24, Y+2	; 0x02
    23c2:	9b 81       	ldd	r25, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    23c4:	e8 16       	cp	r14, r24
    23c6:	f9 06       	cpc	r15, r25
    23c8:	28 f4       	brcc	.+10     	; 0x23d4 <xTaskIncrementTick+0xe8>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    23ca:	90 93 0c 02 	sts	0x020C, r25
    23ce:	80 93 0b 02 	sts	0x020B, r24
    23d2:	2a c0       	rjmp	.+84     	; 0x2428 <xTaskIncrementTick+0x13c>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    23d4:	8e 01       	movw	r16, r28
    23d6:	0e 5f       	subi	r16, 0xFE	; 254
    23d8:	1f 4f       	sbci	r17, 0xFF	; 255
    23da:	c8 01       	movw	r24, r16
    23dc:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    23e0:	8c 89       	ldd	r24, Y+20	; 0x14
    23e2:	9d 89       	ldd	r25, Y+21	; 0x15
    23e4:	89 2b       	or	r24, r25
    23e6:	21 f0       	breq	.+8      	; 0x23f0 <xTaskIncrementTick+0x104>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    23e8:	ce 01       	movw	r24, r28
    23ea:	0c 96       	adiw	r24, 0x0c	; 12
    23ec:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    23f0:	9e 89       	ldd	r25, Y+22	; 0x16
    23f2:	80 91 59 06 	lds	r24, 0x0659
    23f6:	89 17       	cp	r24, r25
    23f8:	10 f4       	brcc	.+4      	; 0x23fe <xTaskIncrementTick+0x112>
    23fa:	90 93 59 06 	sts	0x0659, r25
    23fe:	9c 9d       	mul	r25, r12
    2400:	c0 01       	movw	r24, r0
    2402:	11 24       	eor	r1, r1
    2404:	81 5a       	subi	r24, 0xA1	; 161
    2406:	99 4f       	sbci	r25, 0xF9	; 249
    2408:	b8 01       	movw	r22, r16
    240a:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    240e:	e0 91 53 06 	lds	r30, 0x0653
    2412:	f0 91 54 06 	lds	r31, 0x0654
    2416:	9e 89       	ldd	r25, Y+22	; 0x16
    2418:	86 89       	ldd	r24, Z+22	; 0x16
    241a:	98 17       	cp	r25, r24
    241c:	08 f4       	brcc	.+2      	; 0x2420 <xTaskIncrementTick+0x134>
    241e:	bd cf       	rjmp	.-134    	; 0x239a <xTaskIncrementTick+0xae>
    2420:	dd 24       	eor	r13, r13
    2422:	d3 94       	inc	r13
    2424:	ba cf       	rjmp	.-140    	; 0x239a <xTaskIncrementTick+0xae>
    2426:	dd 24       	eor	r13, r13
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2428:	e0 91 53 06 	lds	r30, 0x0653
    242c:	f0 91 54 06 	lds	r31, 0x0654
    2430:	86 89       	ldd	r24, Z+22	; 0x16
    2432:	90 e0       	ldi	r25, 0x00	; 0
    2434:	fc 01       	movw	r30, r24
    2436:	33 e0       	ldi	r19, 0x03	; 3
    2438:	ee 0f       	add	r30, r30
    243a:	ff 1f       	adc	r31, r31
    243c:	3a 95       	dec	r19
    243e:	e1 f7       	brne	.-8      	; 0x2438 <xTaskIncrementTick+0x14c>
    2440:	e8 0f       	add	r30, r24
    2442:	f9 1f       	adc	r31, r25
    2444:	e1 5a       	subi	r30, 0xA1	; 161
    2446:	f9 4f       	sbci	r31, 0xF9	; 249
    2448:	80 81       	ld	r24, Z
    244a:	82 30       	cpi	r24, 0x02	; 2
    244c:	48 f0       	brcs	.+18     	; 0x2460 <xTaskIncrementTick+0x174>
    244e:	dd 24       	eor	r13, r13
    2450:	d3 94       	inc	r13
    2452:	06 c0       	rjmp	.+12     	; 0x2460 <xTaskIncrementTick+0x174>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2454:	80 91 5b 06 	lds	r24, 0x065B
    2458:	8f 5f       	subi	r24, 0xFF	; 255
    245a:	80 93 5b 06 	sts	0x065B, r24
    245e:	dd 24       	eor	r13, r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2460:	80 91 55 06 	lds	r24, 0x0655
    2464:	88 23       	and	r24, r24
    2466:	11 f0       	breq	.+4      	; 0x246c <xTaskIncrementTick+0x180>
    2468:	dd 24       	eor	r13, r13
    246a:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    246c:	8d 2d       	mov	r24, r13
    246e:	df 91       	pop	r29
    2470:	cf 91       	pop	r28
    2472:	1f 91       	pop	r17
    2474:	0f 91       	pop	r16
    2476:	ff 90       	pop	r15
    2478:	ef 90       	pop	r14
    247a:	df 90       	pop	r13
    247c:	cf 90       	pop	r12
    247e:	08 95       	ret

00002480 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    2480:	cf 93       	push	r28
    2482:	df 93       	push	r29
    2484:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2486:	e0 91 53 06 	lds	r30, 0x0653
    248a:	f0 91 54 06 	lds	r31, 0x0654
    248e:	93 83       	std	Z+3, r25	; 0x03
    2490:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2492:	80 91 56 06 	lds	r24, 0x0656
    2496:	90 91 57 06 	lds	r25, 0x0657
    249a:	c8 17       	cp	r28, r24
    249c:	d9 07       	cpc	r29, r25
    249e:	68 f4       	brcc	.+26     	; 0x24ba <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    24a0:	80 91 b2 06 	lds	r24, 0x06B2
    24a4:	90 91 b3 06 	lds	r25, 0x06B3
    24a8:	60 91 53 06 	lds	r22, 0x0653
    24ac:	70 91 54 06 	lds	r23, 0x0654
    24b0:	6e 5f       	subi	r22, 0xFE	; 254
    24b2:	7f 4f       	sbci	r23, 0xFF	; 255
    24b4:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInsert>
    24b8:	17 c0       	rjmp	.+46     	; 0x24e8 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    24ba:	80 91 b0 06 	lds	r24, 0x06B0
    24be:	90 91 b1 06 	lds	r25, 0x06B1
    24c2:	60 91 53 06 	lds	r22, 0x0653
    24c6:	70 91 54 06 	lds	r23, 0x0654
    24ca:	6e 5f       	subi	r22, 0xFE	; 254
    24cc:	7f 4f       	sbci	r23, 0xFF	; 255
    24ce:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    24d2:	80 91 0b 02 	lds	r24, 0x020B
    24d6:	90 91 0c 02 	lds	r25, 0x020C
    24da:	c8 17       	cp	r28, r24
    24dc:	d9 07       	cpc	r29, r25
    24de:	20 f4       	brcc	.+8      	; 0x24e8 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    24e0:	d0 93 0c 02 	sts	0x020C, r29
    24e4:	c0 93 0b 02 	sts	0x020B, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    24e8:	df 91       	pop	r29
    24ea:	cf 91       	pop	r28
    24ec:	08 95       	ret

000024ee <vTaskPlaceOnUnorderedEventList>:
	#endif /* INCLUDE_vTaskSuspend */
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    24ee:	0f 93       	push	r16
    24f0:	1f 93       	push	r17
    24f2:	8a 01       	movw	r16, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    24f4:	e0 91 53 06 	lds	r30, 0x0653
    24f8:	f0 91 54 06 	lds	r31, 0x0654
    24fc:	70 68       	ori	r23, 0x80	; 128
    24fe:	75 87       	std	Z+13, r23	; 0x0d
    2500:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2502:	60 91 53 06 	lds	r22, 0x0653
    2506:	70 91 54 06 	lds	r23, 0x0654
    250a:	64 5f       	subi	r22, 0xF4	; 244
    250c:	7f 4f       	sbci	r23, 0xFF	; 255
    250e:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2512:	80 91 53 06 	lds	r24, 0x0653
    2516:	90 91 54 06 	lds	r25, 0x0654
    251a:	02 96       	adiw	r24, 0x02	; 2
    251c:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    2520:	80 91 56 06 	lds	r24, 0x0656
    2524:	90 91 57 06 	lds	r25, 0x0657
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2528:	80 0f       	add	r24, r16
    252a:	91 1f       	adc	r25, r17
    252c:	0e 94 40 12 	call	0x2480	; 0x2480 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2530:	1f 91       	pop	r17
    2532:	0f 91       	pop	r16
    2534:	08 95       	ret

00002536 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2536:	0f 93       	push	r16
    2538:	1f 93       	push	r17
    253a:	8b 01       	movw	r16, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    253c:	60 91 53 06 	lds	r22, 0x0653
    2540:	70 91 54 06 	lds	r23, 0x0654
    2544:	64 5f       	subi	r22, 0xF4	; 244
    2546:	7f 4f       	sbci	r23, 0xFF	; 255
    2548:	0e 94 bc 0a 	call	0x1578	; 0x1578 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    254c:	80 91 53 06 	lds	r24, 0x0653
    2550:	90 91 54 06 	lds	r25, 0x0654
    2554:	02 96       	adiw	r24, 0x02	; 2
    2556:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    255a:	80 91 56 06 	lds	r24, 0x0656
    255e:	90 91 57 06 	lds	r25, 0x0657
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2562:	80 0f       	add	r24, r16
    2564:	91 1f       	adc	r25, r17
    2566:	0e 94 40 12 	call	0x2480	; 0x2480 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    256a:	1f 91       	pop	r17
    256c:	0f 91       	pop	r16
    256e:	08 95       	ret

00002570 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2570:	ef 92       	push	r14
    2572:	ff 92       	push	r15
    2574:	0f 93       	push	r16
    2576:	1f 93       	push	r17
    2578:	cf 93       	push	r28
    257a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    257c:	0f b6       	in	r0, 0x3f	; 63
    257e:	f8 94       	cli
    2580:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2582:	80 91 5a 06 	lds	r24, 0x065A
    2586:	81 50       	subi	r24, 0x01	; 1
    2588:	80 93 5a 06 	sts	0x065A, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    258c:	80 91 5a 06 	lds	r24, 0x065A
    2590:	88 23       	and	r24, r24
    2592:	09 f0       	breq	.+2      	; 0x2596 <xTaskResumeAll+0x26>
    2594:	55 c0       	rjmp	.+170    	; 0x2640 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2596:	80 91 5c 06 	lds	r24, 0x065C
    259a:	88 23       	and	r24, r24
    259c:	59 f5       	brne	.+86     	; 0x25f4 <xTaskResumeAll+0x84>
    259e:	50 c0       	rjmp	.+160    	; 0x2640 <xTaskResumeAll+0xd0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    25a0:	e0 91 b9 06 	lds	r30, 0x06B9
    25a4:	f0 91 ba 06 	lds	r31, 0x06BA
    25a8:	c6 81       	ldd	r28, Z+6	; 0x06
    25aa:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    25ac:	ce 01       	movw	r24, r28
    25ae:	0c 96       	adiw	r24, 0x0c	; 12
    25b0:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    25b4:	8e 01       	movw	r16, r28
    25b6:	0e 5f       	subi	r16, 0xFE	; 254
    25b8:	1f 4f       	sbci	r17, 0xFF	; 255
    25ba:	c8 01       	movw	r24, r16
    25bc:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    25c0:	9e 89       	ldd	r25, Y+22	; 0x16
    25c2:	80 91 59 06 	lds	r24, 0x0659
    25c6:	89 17       	cp	r24, r25
    25c8:	10 f4       	brcc	.+4      	; 0x25ce <xTaskResumeAll+0x5e>
    25ca:	90 93 59 06 	sts	0x0659, r25
    25ce:	9e 9d       	mul	r25, r14
    25d0:	c0 01       	movw	r24, r0
    25d2:	11 24       	eor	r1, r1
    25d4:	81 5a       	subi	r24, 0xA1	; 161
    25d6:	99 4f       	sbci	r25, 0xF9	; 249
    25d8:	b8 01       	movw	r22, r16
    25da:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    25de:	e0 91 53 06 	lds	r30, 0x0653
    25e2:	f0 91 54 06 	lds	r31, 0x0654
    25e6:	9e 89       	ldd	r25, Y+22	; 0x16
    25e8:	86 89       	ldd	r24, Z+22	; 0x16
    25ea:	98 17       	cp	r25, r24
    25ec:	38 f0       	brcs	.+14     	; 0x25fc <xTaskResumeAll+0x8c>
					{
						xYieldPending = pdTRUE;
    25ee:	f0 92 55 06 	sts	0x0655, r15
    25f2:	04 c0       	rjmp	.+8      	; 0x25fc <xTaskResumeAll+0x8c>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
    25f4:	59 e0       	ldi	r21, 0x09	; 9
    25f6:	e5 2e       	mov	r14, r21

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    25f8:	ff 24       	eor	r15, r15
    25fa:	f3 94       	inc	r15
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    25fc:	80 91 b4 06 	lds	r24, 0x06B4
    2600:	88 23       	and	r24, r24
    2602:	71 f6       	brne	.-100    	; 0x25a0 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    2604:	80 91 5b 06 	lds	r24, 0x065B
    2608:	88 23       	and	r24, r24
    260a:	69 f4       	brne	.+26     	; 0x2626 <xTaskResumeAll+0xb6>
    260c:	11 c0       	rjmp	.+34     	; 0x2630 <xTaskResumeAll+0xc0>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    260e:	0e 94 76 11 	call	0x22ec	; 0x22ec <xTaskIncrementTick>
    2612:	88 23       	and	r24, r24
    2614:	11 f0       	breq	.+4      	; 0x261a <xTaskResumeAll+0xaa>
						{
							xYieldPending = pdTRUE;
    2616:	10 93 55 06 	sts	0x0655, r17
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    261a:	80 91 5b 06 	lds	r24, 0x065B
    261e:	81 50       	subi	r24, 0x01	; 1
    2620:	80 93 5b 06 	sts	0x065B, r24
    2624:	01 c0       	rjmp	.+2      	; 0x2628 <xTaskResumeAll+0xb8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    2626:	11 e0       	ldi	r17, 0x01	; 1
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    2628:	80 91 5b 06 	lds	r24, 0x065B
    262c:	88 23       	and	r24, r24
    262e:	79 f7       	brne	.-34     	; 0x260e <xTaskResumeAll+0x9e>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    2630:	80 91 55 06 	lds	r24, 0x0655
    2634:	81 30       	cpi	r24, 0x01	; 1
    2636:	21 f4       	brne	.+8      	; 0x2640 <xTaskResumeAll+0xd0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2638:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
    263c:	81 e0       	ldi	r24, 0x01	; 1
    263e:	01 c0       	rjmp	.+2      	; 0x2642 <xTaskResumeAll+0xd2>
    2640:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2642:	0f 90       	pop	r0
    2644:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2646:	df 91       	pop	r29
    2648:	cf 91       	pop	r28
    264a:	1f 91       	pop	r17
    264c:	0f 91       	pop	r16
    264e:	ff 90       	pop	r15
    2650:	ef 90       	pop	r14
    2652:	08 95       	ret

00002654 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2654:	80 91 5f 06 	lds	r24, 0x065F
    2658:	82 30       	cpi	r24, 0x02	; 2
    265a:	18 f0       	brcs	.+6      	; 0x2662 <prvIdleTask+0xe>
			{
				taskYIELD();
    265c:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
    2660:	f9 cf       	rjmp	.-14     	; 0x2654 <prvIdleTask>
    2662:	ff cf       	rjmp	.-2      	; 0x2662 <prvIdleTask+0xe>

00002664 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2664:	0f 93       	push	r16
    2666:	1f 93       	push	r17
    2668:	cf 93       	push	r28
    266a:	df 93       	push	r29
    266c:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    266e:	00 97       	sbiw	r24, 0x00	; 0
    2670:	c9 f0       	breq	.+50     	; 0x26a4 <vTaskDelay+0x40>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2672:	80 91 5a 06 	lds	r24, 0x065A
    2676:	8f 5f       	subi	r24, 0xFF	; 255
    2678:	80 93 5a 06 	sts	0x065A, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    267c:	00 91 56 06 	lds	r16, 0x0656
    2680:	10 91 57 06 	lds	r17, 0x0657

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2684:	80 91 53 06 	lds	r24, 0x0653
    2688:	90 91 54 06 	lds	r25, 0x0654
    268c:	02 96       	adiw	r24, 0x02	; 2
    268e:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2692:	ce 01       	movw	r24, r28
    2694:	80 0f       	add	r24, r16
    2696:	91 1f       	adc	r25, r17
    2698:	0e 94 40 12 	call	0x2480	; 0x2480 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    269c:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    26a0:	88 23       	and	r24, r24
    26a2:	11 f4       	brne	.+4      	; 0x26a8 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
    26a4:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    26a8:	df 91       	pop	r29
    26aa:	cf 91       	pop	r28
    26ac:	1f 91       	pop	r17
    26ae:	0f 91       	pop	r16
    26b0:	08 95       	ret

000026b2 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    26b2:	cf 93       	push	r28
    26b4:	df 93       	push	r29
    26b6:	fc 01       	movw	r30, r24
    26b8:	eb 01       	movw	r28, r22
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    26ba:	80 91 5a 06 	lds	r24, 0x065A
    26be:	8f 5f       	subi	r24, 0xFF	; 255
    26c0:	80 93 5a 06 	sts	0x065A, r24

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    26c4:	20 91 56 06 	lds	r18, 0x0656
    26c8:	30 91 57 06 	lds	r19, 0x0657

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    26cc:	80 81       	ld	r24, Z
    26ce:	91 81       	ldd	r25, Z+1	; 0x01
    26d0:	c8 0f       	add	r28, r24
    26d2:	d9 1f       	adc	r29, r25

			if( xConstTickCount < *pxPreviousWakeTime )
    26d4:	28 17       	cp	r18, r24
    26d6:	39 07       	cpc	r19, r25
    26d8:	28 f4       	brcc	.+10     	; 0x26e4 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    26da:	c8 17       	cp	r28, r24
    26dc:	d9 07       	cpc	r29, r25
    26de:	28 f0       	brcs	.+10     	; 0x26ea <vTaskDelayUntil+0x38>
    26e0:	80 e0       	ldi	r24, 0x00	; 0
    26e2:	08 c0       	rjmp	.+16     	; 0x26f4 <vTaskDelayUntil+0x42>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    26e4:	c8 17       	cp	r28, r24
    26e6:	d9 07       	cpc	r29, r25
    26e8:	20 f0       	brcs	.+8      	; 0x26f2 <vTaskDelayUntil+0x40>
    26ea:	80 e0       	ldi	r24, 0x00	; 0
    26ec:	2c 17       	cp	r18, r28
    26ee:	3d 07       	cpc	r19, r29
    26f0:	08 f4       	brcc	.+2      	; 0x26f4 <vTaskDelayUntil+0x42>
    26f2:	81 e0       	ldi	r24, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    26f4:	d1 83       	std	Z+1, r29	; 0x01
    26f6:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    26f8:	88 23       	and	r24, r24
    26fa:	51 f0       	breq	.+20     	; 0x2710 <vTaskDelayUntil+0x5e>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    26fc:	80 91 53 06 	lds	r24, 0x0653
    2700:	90 91 54 06 	lds	r25, 0x0654
    2704:	02 96       	adiw	r24, 0x02	; 2
    2706:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    270a:	ce 01       	movw	r24, r28
    270c:	0e 94 40 12 	call	0x2480	; 0x2480 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2710:	0e 94 b8 12 	call	0x2570	; 0x2570 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2714:	88 23       	and	r24, r24
    2716:	11 f4       	brne	.+4      	; 0x271c <vTaskDelayUntil+0x6a>
		{
			portYIELD_WITHIN_API();
    2718:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    271c:	df 91       	pop	r29
    271e:	cf 91       	pop	r28
    2720:	08 95       	ret

00002722 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2722:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2724:	10 92 5d 06 	sts	0x065D, r1
	vPortEndScheduler();
    2728:	0e 94 95 0b 	call	0x172a	; 0x172a <vPortEndScheduler>
}
    272c:	08 95       	ret

0000272e <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    272e:	2f 92       	push	r2
    2730:	3f 92       	push	r3
    2732:	4f 92       	push	r4
    2734:	5f 92       	push	r5
    2736:	7f 92       	push	r7
    2738:	8f 92       	push	r8
    273a:	9f 92       	push	r9
    273c:	af 92       	push	r10
    273e:	bf 92       	push	r11
    2740:	cf 92       	push	r12
    2742:	df 92       	push	r13
    2744:	ef 92       	push	r14
    2746:	ff 92       	push	r15
    2748:	0f 93       	push	r16
    274a:	1f 93       	push	r17
    274c:	cf 93       	push	r28
    274e:	df 93       	push	r29
    2750:	1c 01       	movw	r2, r24
    2752:	96 2e       	mov	r9, r22
    2754:	87 2e       	mov	r8, r23
    2756:	5a 01       	movw	r10, r20
    2758:	29 01       	movw	r4, r18
    275a:	70 2e       	mov	r7, r16
    275c:	e6 01       	movw	r28, r12
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    275e:	8d e2       	ldi	r24, 0x2D	; 45
    2760:	90 e0       	ldi	r25, 0x00	; 0
    2762:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <pvPortMalloc>
    2766:	6c 01       	movw	r12, r24

	if( pxNewTCB != NULL )
    2768:	00 97       	sbiw	r24, 0x00	; 0
    276a:	79 f0       	breq	.+30     	; 0x278a <xTaskGenericCreate+0x5c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    276c:	20 97       	sbiw	r28, 0x00	; 0
    276e:	21 f4       	brne	.+8      	; 0x2778 <xTaskGenericCreate+0x4a>
    2770:	c5 01       	movw	r24, r10
    2772:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <pvPortMalloc>
    2776:	ec 01       	movw	r28, r24
    2778:	f6 01       	movw	r30, r12
    277a:	d0 8f       	std	Z+24, r29	; 0x18
    277c:	c7 8b       	std	Z+23, r28	; 0x17

		if( pxNewTCB->pxStack == NULL )
    277e:	20 97       	sbiw	r28, 0x00	; 0
    2780:	09 f0       	breq	.+2      	; 0x2784 <xTaskGenericCreate+0x56>
    2782:	c4 c0       	rjmp	.+392    	; 0x290c <xTaskGenericCreate+0x1de>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2784:	c6 01       	movw	r24, r12
    2786:	0e 94 c0 09 	call	0x1380	; 0x1380 <vPortFree>
    278a:	8f ef       	ldi	r24, 0xFF	; 255
    278c:	ad c0       	rjmp	.+346    	; 0x28e8 <xTaskGenericCreate+0x1ba>
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    278e:	80 81       	ld	r24, Z
    2790:	59 96       	adiw	r26, 0x19	; 25
    2792:	8c 93       	st	X, r24
    2794:	59 97       	sbiw	r26, 0x19	; 25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    2796:	80 81       	ld	r24, Z
    2798:	88 23       	and	r24, r24
    279a:	29 f0       	breq	.+10     	; 0x27a6 <xTaskGenericCreate+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    279c:	9f 5f       	subi	r25, 0xFF	; 255
    279e:	31 96       	adiw	r30, 0x01	; 1
    27a0:	11 96       	adiw	r26, 0x01	; 1
    27a2:	94 31       	cpi	r25, 0x14	; 20
    27a4:	a1 f7       	brne	.-24     	; 0x278e <xTaskGenericCreate+0x60>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    27a6:	f6 01       	movw	r30, r12
    27a8:	14 a6       	std	Z+44, r1	; 0x2c
    27aa:	07 2d       	mov	r16, r7
    27ac:	f6 e0       	ldi	r31, 0x06	; 6
    27ae:	f7 15       	cp	r31, r7
    27b0:	08 f4       	brcc	.+2      	; 0x27b4 <xTaskGenericCreate+0x86>
    27b2:	06 e0       	ldi	r16, 0x06	; 6
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    27b4:	f6 01       	movw	r30, r12
    27b6:	06 8b       	std	Z+22, r16	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    27b8:	72 e0       	ldi	r23, 0x02	; 2
    27ba:	87 2e       	mov	r8, r23
    27bc:	91 2c       	mov	r9, r1
    27be:	8c 0c       	add	r8, r12
    27c0:	9d 1c       	adc	r9, r13
    27c2:	c4 01       	movw	r24, r8
    27c4:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    27c8:	c6 01       	movw	r24, r12
    27ca:	0c 96       	adiw	r24, 0x0c	; 12
    27cc:	0e 94 99 0a 	call	0x1532	; 0x1532 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    27d0:	f6 01       	movw	r30, r12
    27d2:	d1 86       	std	Z+9, r13	; 0x09
    27d4:	c0 86       	std	Z+8, r12	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    27d6:	87 e0       	ldi	r24, 0x07	; 7
    27d8:	90 e0       	ldi	r25, 0x00	; 0
    27da:	80 1b       	sub	r24, r16
    27dc:	91 09       	sbc	r25, r1
    27de:	95 87       	std	Z+13, r25	; 0x0d
    27e0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    27e2:	d3 8a       	std	Z+19, r13	; 0x13
    27e4:	c2 8a       	std	Z+18, r12	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    27e6:	08 94       	sec
    27e8:	a1 08       	sbc	r10, r1
    27ea:	b1 08       	sbc	r11, r1
    27ec:	ce 01       	movw	r24, r28
    27ee:	8a 0d       	add	r24, r10
    27f0:	9b 1d       	adc	r25, r11
    27f2:	b1 01       	movw	r22, r2
    27f4:	a2 01       	movw	r20, r4
    27f6:	0e 94 18 0b 	call	0x1630	; 0x1630 <pxPortInitialiseStack>
    27fa:	f6 01       	movw	r30, r12
    27fc:	91 83       	std	Z+1, r25	; 0x01
    27fe:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    2800:	e1 14       	cp	r14, r1
    2802:	f1 04       	cpc	r15, r1
    2804:	19 f0       	breq	.+6      	; 0x280c <xTaskGenericCreate+0xde>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2806:	f7 01       	movw	r30, r14
    2808:	d1 82       	std	Z+1, r13	; 0x01
    280a:	c0 82       	st	Z, r12
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    280c:	0f b6       	in	r0, 0x3f	; 63
    280e:	f8 94       	cli
    2810:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2812:	80 91 5c 06 	lds	r24, 0x065C
    2816:	8f 5f       	subi	r24, 0xFF	; 255
    2818:	80 93 5c 06 	sts	0x065C, r24
			if( pxCurrentTCB == NULL )
    281c:	80 91 53 06 	lds	r24, 0x0653
    2820:	90 91 54 06 	lds	r25, 0x0654
    2824:	89 2b       	or	r24, r25
    2826:	59 f5       	brne	.+86     	; 0x287e <xTaskGenericCreate+0x150>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2828:	d0 92 54 06 	sts	0x0654, r13
    282c:	c0 92 53 06 	sts	0x0653, r12

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2830:	80 91 5c 06 	lds	r24, 0x065C
    2834:	81 30       	cpi	r24, 0x01	; 1
    2836:	91 f5       	brne	.+100    	; 0x289c <xTaskGenericCreate+0x16e>
    2838:	cf e5       	ldi	r28, 0x5F	; 95
    283a:	d6 e0       	ldi	r29, 0x06	; 6
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    283c:	ce 01       	movw	r24, r28
    283e:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
    2842:	29 96       	adiw	r28, 0x09	; 9

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2844:	f6 e0       	ldi	r31, 0x06	; 6
    2846:	ce 39       	cpi	r28, 0x9E	; 158
    2848:	df 07       	cpc	r29, r31
    284a:	c1 f7       	brne	.-16     	; 0x283c <xTaskGenericCreate+0x10e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    284c:	6e e9       	ldi	r22, 0x9E	; 158
    284e:	e6 2e       	mov	r14, r22
    2850:	66 e0       	ldi	r22, 0x06	; 6
    2852:	f6 2e       	mov	r15, r22
    2854:	c7 01       	movw	r24, r14
    2856:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    285a:	07 ea       	ldi	r16, 0xA7	; 167
    285c:	16 e0       	ldi	r17, 0x06	; 6
    285e:	c8 01       	movw	r24, r16
    2860:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2864:	84 eb       	ldi	r24, 0xB4	; 180
    2866:	96 e0       	ldi	r25, 0x06	; 6
    2868:	0e 94 89 0a 	call	0x1512	; 0x1512 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    286c:	f0 92 b1 06 	sts	0x06B1, r15
    2870:	e0 92 b0 06 	sts	0x06B0, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2874:	10 93 b3 06 	sts	0x06B3, r17
    2878:	00 93 b2 06 	sts	0x06B2, r16
    287c:	0f c0       	rjmp	.+30     	; 0x289c <xTaskGenericCreate+0x16e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    287e:	80 91 5d 06 	lds	r24, 0x065D
    2882:	88 23       	and	r24, r24
    2884:	59 f4       	brne	.+22     	; 0x289c <xTaskGenericCreate+0x16e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2886:	e0 91 53 06 	lds	r30, 0x0653
    288a:	f0 91 54 06 	lds	r31, 0x0654
    288e:	86 89       	ldd	r24, Z+22	; 0x16
    2890:	78 16       	cp	r7, r24
    2892:	20 f0       	brcs	.+8      	; 0x289c <xTaskGenericCreate+0x16e>
					{
						pxCurrentTCB = pxNewTCB;
    2894:	d0 92 54 06 	sts	0x0654, r13
    2898:	c0 92 53 06 	sts	0x0653, r12
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    289c:	80 91 5e 06 	lds	r24, 0x065E
    28a0:	8f 5f       	subi	r24, 0xFF	; 255
    28a2:	80 93 5e 06 	sts	0x065E, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    28a6:	f6 01       	movw	r30, r12
    28a8:	96 89       	ldd	r25, Z+22	; 0x16
    28aa:	80 91 59 06 	lds	r24, 0x0659
    28ae:	89 17       	cp	r24, r25
    28b0:	10 f4       	brcc	.+4      	; 0x28b6 <xTaskGenericCreate+0x188>
    28b2:	90 93 59 06 	sts	0x0659, r25
    28b6:	89 e0       	ldi	r24, 0x09	; 9
    28b8:	98 9f       	mul	r25, r24
    28ba:	c0 01       	movw	r24, r0
    28bc:	11 24       	eor	r1, r1
    28be:	81 5a       	subi	r24, 0xA1	; 161
    28c0:	99 4f       	sbci	r25, 0xF9	; 249
    28c2:	b4 01       	movw	r22, r8
    28c4:	0e 94 9d 0a 	call	0x153a	; 0x153a <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    28c8:	0f 90       	pop	r0
    28ca:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    28cc:	80 91 5d 06 	lds	r24, 0x065D
    28d0:	88 23       	and	r24, r24
    28d2:	49 f0       	breq	.+18     	; 0x28e6 <xTaskGenericCreate+0x1b8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    28d4:	e0 91 53 06 	lds	r30, 0x0653
    28d8:	f0 91 54 06 	lds	r31, 0x0654
    28dc:	86 89       	ldd	r24, Z+22	; 0x16
    28de:	87 15       	cp	r24, r7
    28e0:	10 f4       	brcc	.+4      	; 0x28e6 <xTaskGenericCreate+0x1b8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    28e2:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <vPortYield>
    28e6:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    28e8:	df 91       	pop	r29
    28ea:	cf 91       	pop	r28
    28ec:	1f 91       	pop	r17
    28ee:	0f 91       	pop	r16
    28f0:	ff 90       	pop	r15
    28f2:	ef 90       	pop	r14
    28f4:	df 90       	pop	r13
    28f6:	cf 90       	pop	r12
    28f8:	bf 90       	pop	r11
    28fa:	af 90       	pop	r10
    28fc:	9f 90       	pop	r9
    28fe:	8f 90       	pop	r8
    2900:	7f 90       	pop	r7
    2902:	5f 90       	pop	r5
    2904:	4f 90       	pop	r4
    2906:	3f 90       	pop	r3
    2908:	2f 90       	pop	r2
    290a:	08 95       	ret
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				taskYIELD_IF_USING_PREEMPTION();
    290c:	89 2d       	mov	r24, r9
    290e:	98 2d       	mov	r25, r8
    2910:	9c 01       	movw	r18, r24
    2912:	f9 01       	movw	r30, r18
    2914:	d6 01       	movw	r26, r12
    2916:	90 e0       	ldi	r25, 0x00	; 0
    2918:	3a cf       	rjmp	.-396    	; 0x278e <xTaskGenericCreate+0x60>

0000291a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    291a:	af 92       	push	r10
    291c:	bf 92       	push	r11
    291e:	cf 92       	push	r12
    2920:	df 92       	push	r13
    2922:	ef 92       	push	r14
    2924:	ff 92       	push	r15
    2926:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    2928:	8a e2       	ldi	r24, 0x2A	; 42
    292a:	93 e1       	ldi	r25, 0x13	; 19
    292c:	68 e7       	ldi	r22, 0x78	; 120
    292e:	70 e0       	ldi	r23, 0x00	; 0
    2930:	45 e5       	ldi	r20, 0x55	; 85
    2932:	50 e0       	ldi	r21, 0x00	; 0
    2934:	20 e0       	ldi	r18, 0x00	; 0
    2936:	30 e0       	ldi	r19, 0x00	; 0
    2938:	00 e0       	ldi	r16, 0x00	; 0
    293a:	ee 24       	eor	r14, r14
    293c:	ff 24       	eor	r15, r15
    293e:	cc 24       	eor	r12, r12
    2940:	dd 24       	eor	r13, r13
    2942:	aa 24       	eor	r10, r10
    2944:	bb 24       	eor	r11, r11
    2946:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    294a:	81 30       	cpi	r24, 0x01	; 1
    294c:	49 f4       	brne	.+18     	; 0x2960 <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    294e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    2950:	80 93 5d 06 	sts	0x065D, r24
		xTickCount = ( TickType_t ) 0U;
    2954:	10 92 57 06 	sts	0x0657, r1
    2958:	10 92 56 06 	sts	0x0656, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    295c:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    2960:	0f 91       	pop	r16
    2962:	ff 90       	pop	r15
    2964:	ef 90       	pop	r14
    2966:	df 90       	pop	r13
    2968:	cf 90       	pop	r12
    296a:	bf 90       	pop	r11
    296c:	af 90       	pop	r10
    296e:	08 95       	ret

00002970 <ADC_voidInit>:
static void(* ADC_pfNotification)(u16) = NULL;

void ADC_voidInit		  (void)
{
	/* 1- Select Vref = AVCC */
	CLR_BIT(ADC_u8_ADMUX_REG, 7);
    2970:	3f 98       	cbi	0x07, 7	; 7
	SET_BIT(ADC_u8_ADMUX_REG, 6);
    2972:	3e 9a       	sbi	0x07, 6	; 7
	
	/* 2- Select Right Adjustment */
	CLR_BIT(ADC_u8_ADMUX_REG, 5);
    2974:	3d 98       	cbi	0x07, 5	; 7
	
	/* 3- Select Conversion Mode = Single Conversion Mode */
	CLR_BIT(ADC_u8_ADCSRA_REG, 5);
    2976:	35 98       	cbi	0x06, 5	; 6
	
	/* 4- Select Prescaler value = 64 for (8 MHz Clock) */
	SET_BIT(ADC_u8_ADCSRA_REG, 2);
    2978:	32 9a       	sbi	0x06, 2	; 6
	SET_BIT(ADC_u8_ADCSRA_REG, 1);
    297a:	31 9a       	sbi	0x06, 1	; 6
	CLR_BIT(ADC_u8_ADCSRA_REG, 0);
    297c:	30 98       	cbi	0x06, 0	; 6
	
	/* 5- ADC Enabele */
	SET_BIT(ADC_u8_ADCSRA_REG, 7);
    297e:	37 9a       	sbi	0x06, 7	; 6
}
    2980:	08 95       	ret

00002982 <ADC_u8GetDigitalValueSynchronous>:

u8   ADC_u8GetDigitalValueSynchronous(u8 Copy_u8ChannelNumber, u16* Copy_pu16DigitalValue)
{
    2982:	98 2f       	mov	r25, r24
    2984:	fb 01       	movw	r30, r22
	u8  Local_u8ErrorState      = STD_TYPES_OK;
	u32 Local_u32TimeOutCounter = 0;
	
	if((Copy_u8ChannelNumber<32) && (Copy_pu16DigitalValue != NULL))
    2986:	80 32       	cpi	r24, 0x20	; 32
    2988:	40 f5       	brcc	.+80     	; 0x29da <ADC_u8GetDigitalValueSynchronous+0x58>
    298a:	61 15       	cp	r22, r1
    298c:	71 05       	cpc	r23, r1
    298e:	29 f1       	breq	.+74     	; 0x29da <ADC_u8GetDigitalValueSynchronous+0x58>
	{
		/* Select Channel Number */
		ADC_u8_ADMUX_REG &= 0b11100000; /* Clear the 5 bits channel number (MUX bits) before assigning the new channel number */
    2990:	87 b1       	in	r24, 0x07	; 7
    2992:	80 7e       	andi	r24, 0xE0	; 224
    2994:	87 b9       	out	0x07, r24	; 7
		ADC_u8_ADMUX_REG |= Copy_u8ChannelNumber; /* I make it using OR logic to not lose the data in the remaining bits of the register*/
    2996:	87 b1       	in	r24, 0x07	; 7
    2998:	89 2b       	or	r24, r25
    299a:	87 b9       	out	0x07, r24	; 7
		/* Start Convrsion */
		SET_BIT(ADC_u8_ADCSRA_REG, 6);
    299c:	36 9a       	sbi	0x06, 6	; 6
    299e:	80 e0       	ldi	r24, 0x00	; 0
    29a0:	90 e0       	ldi	r25, 0x00	; 0
    29a2:	a0 e0       	ldi	r26, 0x00	; 0
    29a4:	b0 e0       	ldi	r27, 0x00	; 0
    29a6:	03 c0       	rjmp	.+6      	; 0x29ae <ADC_u8GetDigitalValueSynchronous+0x2c>
		/* Wait for ADC Flag (ADIF) to be up */
		while((GET_BIT(ADC_u8_ADCSRA_REG, 4) == 0) && (Local_u32TimeOutCounter < ADC_u32_TIMEOUT_COUNTER))
		{
			Local_u32TimeOutCounter++;
    29a8:	01 96       	adiw	r24, 0x01	; 1
    29aa:	a1 1d       	adc	r26, r1
    29ac:	b1 1d       	adc	r27, r1
		ADC_u8_ADMUX_REG &= 0b11100000; /* Clear the 5 bits channel number (MUX bits) before assigning the new channel number */
		ADC_u8_ADMUX_REG |= Copy_u8ChannelNumber; /* I make it using OR logic to not lose the data in the remaining bits of the register*/
		/* Start Convrsion */
		SET_BIT(ADC_u8_ADCSRA_REG, 6);
		/* Wait for ADC Flag (ADIF) to be up */
		while((GET_BIT(ADC_u8_ADCSRA_REG, 4) == 0) && (Local_u32TimeOutCounter < ADC_u32_TIMEOUT_COUNTER))
    29ae:	34 99       	sbic	0x06, 4	; 6
    29b0:	08 c0       	rjmp	.+16     	; 0x29c2 <ADC_u8GetDigitalValueSynchronous+0x40>
    29b2:	80 3a       	cpi	r24, 0xA0	; 160
    29b4:	26 e8       	ldi	r18, 0x86	; 134
    29b6:	92 07       	cpc	r25, r18
    29b8:	21 e0       	ldi	r18, 0x01	; 1
    29ba:	a2 07       	cpc	r26, r18
    29bc:	20 e0       	ldi	r18, 0x00	; 0
    29be:	b2 07       	cpc	r27, r18
    29c0:	99 f7       	brne	.-26     	; 0x29a8 <ADC_u8GetDigitalValueSynchronous+0x26>
		{
			Local_u32TimeOutCounter++;
		}
		
		if(GET_BIT(ADC_u8_ADCSRA_REG, 4) != 0) /* Flag was set before the counter times out */
    29c2:	86 b1       	in	r24, 0x06	; 6
    29c4:	82 95       	swap	r24
    29c6:	8f 70       	andi	r24, 0x0F	; 15
    29c8:	80 ff       	sbrs	r24, 0
    29ca:	07 c0       	rjmp	.+14     	; 0x29da <ADC_u8GetDigitalValueSynchronous+0x58>
		{
			/* Clear flag */
			SET_BIT(ADC_u8_ADCSRA_REG, 4);
    29cc:	34 9a       	sbi	0x06, 4	; 6
			/* Read Digital Value */
			*Copy_pu16DigitalValue = ADC_u16_ADC_REG; /* From ADCH and ADCL Registers */
    29ce:	84 b1       	in	r24, 0x04	; 4
    29d0:	95 b1       	in	r25, 0x05	; 5
    29d2:	91 83       	std	Z+1, r25	; 0x01
    29d4:	80 83       	st	Z, r24
    29d6:	81 e0       	ldi	r24, 0x01	; 1
    29d8:	08 95       	ret
    29da:	80 e0       	ldi	r24, 0x00	; 0
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	
	return Local_u8ErrorState;
}
    29dc:	08 95       	ret

000029de <ADC_u8GetDigitalValueAsynchronous>:

u8   ADC_u8GetDigitalValueAsynchronous(u8 Copy_u8ChannelNumber, void(*Copy_pfNotification)(u16))
{
    29de:	98 2f       	mov	r25, r24
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8ChannelNumber<32) && (Copy_pfNotification != NULL) && (ADC_u8BusyFlag == 0)) /* The flag is not busy */
    29e0:	80 32       	cpi	r24, 0x20	; 32
    29e2:	c0 f4       	brcc	.+48     	; 0x2a14 <ADC_u8GetDigitalValueAsynchronous+0x36>
    29e4:	61 15       	cp	r22, r1
    29e6:	71 05       	cpc	r23, r1
    29e8:	a9 f0       	breq	.+42     	; 0x2a14 <ADC_u8GetDigitalValueAsynchronous+0x36>
    29ea:	80 91 bf 06 	lds	r24, 0x06BF
    29ee:	88 23       	and	r24, r24
    29f0:	89 f4       	brne	.+34     	; 0x2a14 <ADC_u8GetDigitalValueAsynchronous+0x36>
	{
		/* Set Busy Flag */
		ADC_u8BusyFlag = 1;
    29f2:	81 e0       	ldi	r24, 0x01	; 1
    29f4:	80 93 bf 06 	sts	0x06BF, r24
		/* Update Global Pointers so ISR can access them */
		ADC_pfNotification = Copy_pfNotification;
    29f8:	70 93 be 06 	sts	0x06BE, r23
    29fc:	60 93 bd 06 	sts	0x06BD, r22
		/* Select Channel */
		ADC_u8_ADMUX_REG &= 0b11100000;
    2a00:	87 b1       	in	r24, 0x07	; 7
    2a02:	80 7e       	andi	r24, 0xE0	; 224
    2a04:	87 b9       	out	0x07, r24	; 7
		ADC_u8_ADMUX_REG |= Copy_u8ChannelNumber;
    2a06:	87 b1       	in	r24, 0x07	; 7
    2a08:	89 2b       	or	r24, r25
    2a0a:	87 b9       	out	0x07, r24	; 7
		/* Enable Interrupt of ADC */
		SET_BIT(ADC_u8_ADCSRA_REG, 3);
    2a0c:	33 9a       	sbi	0x06, 3	; 6
		/* Start Conversion */
		SET_BIT(ADC_u8_ADCSRA_REG, 6);
    2a0e:	36 9a       	sbi	0x06, 6	; 6
    2a10:	81 e0       	ldi	r24, 0x01	; 1
    2a12:	08 95       	ret

u8   ADC_u8GetDigitalValueAsynchronous(u8 Copy_u8ChannelNumber, void(*Copy_pfNotification)(u16))
{
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8ChannelNumber<32) && (Copy_pfNotification != NULL) && (ADC_u8BusyFlag == 0)) /* The flag is not busy */
    2a14:	80 e0       	ldi	r24, 0x00	; 0
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	
	return Local_u8ErrorState;
}
    2a16:	08 95       	ret

00002a18 <__vector_16>:

/* ADC ISR Implementation */
void __vector_16(void) __attribute__((signal));
void __vector_16(void)
{
    2a18:	1f 92       	push	r1
    2a1a:	0f 92       	push	r0
    2a1c:	0f b6       	in	r0, 0x3f	; 63
    2a1e:	0f 92       	push	r0
    2a20:	11 24       	eor	r1, r1
    2a22:	2f 93       	push	r18
    2a24:	3f 93       	push	r19
    2a26:	4f 93       	push	r20
    2a28:	5f 93       	push	r21
    2a2a:	6f 93       	push	r22
    2a2c:	7f 93       	push	r23
    2a2e:	8f 93       	push	r24
    2a30:	9f 93       	push	r25
    2a32:	af 93       	push	r26
    2a34:	bf 93       	push	r27
    2a36:	ef 93       	push	r30
    2a38:	ff 93       	push	r31
	if(ADC_pfNotification != NULL)
    2a3a:	e0 91 bd 06 	lds	r30, 0x06BD
    2a3e:	f0 91 be 06 	lds	r31, 0x06BE
    2a42:	30 97       	sbiw	r30, 0x00	; 0
    2a44:	31 f0       	breq	.+12     	; 0x2a52 <__vector_16+0x3a>
	{
		/* Disable Interrupt */
		CLR_BIT(ADC_u8_ADCSRA_REG, 3);
    2a46:	33 98       	cbi	0x06, 3	; 6
		/* Call Notification Function */
		ADC_pfNotification(ADC_u16_ADC_REG);
    2a48:	84 b1       	in	r24, 0x04	; 4
    2a4a:	95 b1       	in	r25, 0x05	; 5
    2a4c:	09 95       	icall
		/* Clear Busy Flag */
		ADC_u8BusyFlag = 0;
    2a4e:	10 92 bf 06 	sts	0x06BF, r1
	}
    2a52:	ff 91       	pop	r31
    2a54:	ef 91       	pop	r30
    2a56:	bf 91       	pop	r27
    2a58:	af 91       	pop	r26
    2a5a:	9f 91       	pop	r25
    2a5c:	8f 91       	pop	r24
    2a5e:	7f 91       	pop	r23
    2a60:	6f 91       	pop	r22
    2a62:	5f 91       	pop	r21
    2a64:	4f 91       	pop	r20
    2a66:	3f 91       	pop	r19
    2a68:	2f 91       	pop	r18
    2a6a:	0f 90       	pop	r0
    2a6c:	0f be       	out	0x3f, r0	; 63
    2a6e:	0f 90       	pop	r0
    2a70:	1f 90       	pop	r1
    2a72:	18 95       	reti

00002a74 <DIO_voidInit>:

void DIO_voidInit		  (void)
{
	/* Set Initial Direction for Ports */
	
	DIO_u8_DDRA_REG = Conc(DIO_u8_PA7_Direction, DIO_u8_PA6_Direction, DIO_u8_PA5_Direction, DIO_u8_PA4_Direction,
    2a74:	8c ef       	ldi	r24, 0xFC	; 252
    2a76:	8a bb       	out	0x1a, r24	; 26
						   DIO_u8_PA3_Direction, DIO_u8_PA2_Direction, DIO_u8_PA1_Direction, DIO_u8_PA0_Direction);
	
	DIO_u8_DDRB_REG = Conc(DIO_u8_PB7_Direction, DIO_u8_PB6_Direction, DIO_u8_PB5_Direction, DIO_u8_PB4_Direction,
    2a78:	81 e0       	ldi	r24, 0x01	; 1
    2a7a:	87 bb       	out	0x17, r24	; 23
						   DIO_u8_PB3_Direction, DIO_u8_PB2_Direction, DIO_u8_PB1_Direction, DIO_u8_PB0_Direction);
						   
	DIO_u8_DDRC_REG = Conc(DIO_u8_PC7_Direction, DIO_u8_PC6_Direction, DIO_u8_PC5_Direction, DIO_u8_PC4_Direction,
    2a7c:	8f ef       	ldi	r24, 0xFF	; 255
    2a7e:	84 bb       	out	0x14, r24	; 20
						   DIO_u8_PC3_Direction, DIO_u8_PC2_Direction, DIO_u8_PC1_Direction, DIO_u8_PC0_Direction);
						   
	DIO_u8_DDRD_REG = Conc(DIO_u8_PD7_Direction, DIO_u8_PD6_Direction, DIO_u8_PD5_Direction, DIO_u8_PD4_Direction,
    2a80:	11 ba       	out	0x11, r1	; 17
						   DIO_u8_PD3_Direction, DIO_u8_PD2_Direction, DIO_u8_PD1_Direction, DIO_u8_PD0_Direction);

	/* Set Initial Values for Ports */
	
	DIO_u8_PORTA_REG = Conc(DIO_u8_PA7_INITIAL_VALUE, DIO_u8_PA6_INITIAL_VALUE, DIO_u8_PA5_INITIAL_VALUE, DIO_u8_PA4_INITIAL_VALUE,
    2a82:	1b ba       	out	0x1b, r1	; 27
						    DIO_u8_PA3_INITIAL_VALUE, DIO_u8_PA2_INITIAL_VALUE, DIO_u8_PA1_INITIAL_VALUE, DIO_u8_PA0_INITIAL_VALUE);
																													
	DIO_u8_PORTB_REG = Conc(DIO_u8_PB7_INITIAL_VALUE, DIO_u8_PB6_INITIAL_VALUE, DIO_u8_PB5_INITIAL_VALUE, DIO_u8_PB4_INITIAL_VALUE,
    2a84:	18 ba       	out	0x18, r1	; 24
						    DIO_u8_PB3_INITIAL_VALUE, DIO_u8_PB2_INITIAL_VALUE, DIO_u8_PB1_INITIAL_VALUE, DIO_u8_PB0_INITIAL_VALUE);
																													
	DIO_u8_PORTC_REG = Conc(DIO_u8_PC7_INITIAL_VALUE, DIO_u8_PC6_INITIAL_VALUE, DIO_u8_PC5_INITIAL_VALUE, DIO_u8_PC4_INITIAL_VALUE,
    2a86:	80 ef       	ldi	r24, 0xF0	; 240
    2a88:	85 bb       	out	0x15, r24	; 21
						    DIO_u8_PC3_INITIAL_VALUE, DIO_u8_PC2_INITIAL_VALUE, DIO_u8_PC1_INITIAL_VALUE, DIO_u8_PC0_INITIAL_VALUE);
																													
	DIO_u8_PORTD_REG = Conc(DIO_u8_PD7_INITIAL_VALUE, DIO_u8_PD6_INITIAL_VALUE, DIO_u8_PD5_INITIAL_VALUE, DIO_u8_PD4_INITIAL_VALUE,
    2a8a:	82 bb       	out	0x12, r24	; 18
						    DIO_u8_PD3_INITIAL_VALUE, DIO_u8_PD2_INITIAL_VALUE, DIO_u8_PD1_INITIAL_VALUE, DIO_u8_PD0_INITIAL_VALUE);
}
    2a8c:	08 95       	ret

00002a8e <DIO_u8SetPinDirection>:
u8 DIO_u8SetPinDirection  (u8 Copy_u8PortID, u8 Copy_u8PinID, u8 Copy_u8PinDirection)
{
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	/* Make Sure I have valid PinID, PortID and PinDirection*/
	if((Copy_u8PortID <= DIO_u8_PORTD) && (Copy_u8PinID <= DIO_u8_PIN7)
    2a8e:	84 30       	cpi	r24, 0x04	; 4
    2a90:	08 f0       	brcs	.+2      	; 0x2a94 <DIO_u8SetPinDirection+0x6>
    2a92:	75 c0       	rjmp	.+234    	; 0x2b7e <DIO_u8SetPinDirection+0xf0>
    2a94:	68 30       	cpi	r22, 0x08	; 8
    2a96:	08 f0       	brcs	.+2      	; 0x2a9a <DIO_u8SetPinDirection+0xc>
    2a98:	72 c0       	rjmp	.+228    	; 0x2b7e <DIO_u8SetPinDirection+0xf0>
    2a9a:	42 30       	cpi	r20, 0x02	; 2
    2a9c:	08 f0       	brcs	.+2      	; 0x2aa0 <DIO_u8SetPinDirection+0x12>
    2a9e:	6f c0       	rjmp	.+222    	; 0x2b7e <DIO_u8SetPinDirection+0xf0>
		&& ((Copy_u8PinDirection == DIO_u8_INPUT) || (Copy_u8PinDirection == DIO_u8_OUTPUT)))
	{
		switch(Copy_u8PortID)
    2aa0:	81 30       	cpi	r24, 0x01	; 1
    2aa2:	09 f1       	breq	.+66     	; 0x2ae6 <DIO_u8SetPinDirection+0x58>
    2aa4:	81 30       	cpi	r24, 0x01	; 1
    2aa6:	30 f0       	brcs	.+12     	; 0x2ab4 <DIO_u8SetPinDirection+0x26>
    2aa8:	82 30       	cpi	r24, 0x02	; 2
    2aaa:	b1 f1       	breq	.+108    	; 0x2b18 <DIO_u8SetPinDirection+0x8a>
    2aac:	83 30       	cpi	r24, 0x03	; 3
    2aae:	09 f0       	breq	.+2      	; 0x2ab2 <DIO_u8SetPinDirection+0x24>
    2ab0:	64 c0       	rjmp	.+200    	; 0x2b7a <DIO_u8SetPinDirection+0xec>
    2ab2:	4b c0       	rjmp	.+150    	; 0x2b4a <DIO_u8SetPinDirection+0xbc>
		{
			case DIO_u8_PORTA:
				if(Copy_u8PinDirection == DIO_u8_INPUT)
    2ab4:	44 23       	and	r20, r20
    2ab6:	61 f4       	brne	.+24     	; 0x2ad0 <DIO_u8SetPinDirection+0x42>
				{
					CLR_BIT(DIO_u8_DDRA_REG, Copy_u8PinID);
    2ab8:	2a b3       	in	r18, 0x1a	; 26
    2aba:	81 e0       	ldi	r24, 0x01	; 1
    2abc:	90 e0       	ldi	r25, 0x00	; 0
    2abe:	02 c0       	rjmp	.+4      	; 0x2ac4 <DIO_u8SetPinDirection+0x36>
    2ac0:	88 0f       	add	r24, r24
    2ac2:	99 1f       	adc	r25, r25
    2ac4:	6a 95       	dec	r22
    2ac6:	e2 f7       	brpl	.-8      	; 0x2ac0 <DIO_u8SetPinDirection+0x32>
    2ac8:	80 95       	com	r24
    2aca:	82 23       	and	r24, r18
    2acc:	8a bb       	out	0x1a, r24	; 26
    2ace:	55 c0       	rjmp	.+170    	; 0x2b7a <DIO_u8SetPinDirection+0xec>
				}
				else
				{
					SET_BIT(DIO_u8_DDRA_REG, Copy_u8PinID);
    2ad0:	2a b3       	in	r18, 0x1a	; 26
    2ad2:	81 e0       	ldi	r24, 0x01	; 1
    2ad4:	90 e0       	ldi	r25, 0x00	; 0
    2ad6:	02 c0       	rjmp	.+4      	; 0x2adc <DIO_u8SetPinDirection+0x4e>
    2ad8:	88 0f       	add	r24, r24
    2ada:	99 1f       	adc	r25, r25
    2adc:	6a 95       	dec	r22
    2ade:	e2 f7       	brpl	.-8      	; 0x2ad8 <DIO_u8SetPinDirection+0x4a>
    2ae0:	28 2b       	or	r18, r24
    2ae2:	2a bb       	out	0x1a, r18	; 26
    2ae4:	4a c0       	rjmp	.+148    	; 0x2b7a <DIO_u8SetPinDirection+0xec>
				}
			break;
			
			case DIO_u8_PORTB:
				if(Copy_u8PinDirection == DIO_u8_INPUT)
    2ae6:	44 23       	and	r20, r20
    2ae8:	61 f4       	brne	.+24     	; 0x2b02 <DIO_u8SetPinDirection+0x74>
				{
					CLR_BIT(DIO_u8_DDRB_REG, Copy_u8PinID);
    2aea:	27 b3       	in	r18, 0x17	; 23
    2aec:	81 e0       	ldi	r24, 0x01	; 1
    2aee:	90 e0       	ldi	r25, 0x00	; 0
    2af0:	02 c0       	rjmp	.+4      	; 0x2af6 <DIO_u8SetPinDirection+0x68>
    2af2:	88 0f       	add	r24, r24
    2af4:	99 1f       	adc	r25, r25
    2af6:	6a 95       	dec	r22
    2af8:	e2 f7       	brpl	.-8      	; 0x2af2 <DIO_u8SetPinDirection+0x64>
    2afa:	80 95       	com	r24
    2afc:	82 23       	and	r24, r18
    2afe:	87 bb       	out	0x17, r24	; 23
    2b00:	3c c0       	rjmp	.+120    	; 0x2b7a <DIO_u8SetPinDirection+0xec>
				}
				else
				{
					SET_BIT(DIO_u8_DDRB_REG, Copy_u8PinID);
    2b02:	27 b3       	in	r18, 0x17	; 23
    2b04:	81 e0       	ldi	r24, 0x01	; 1
    2b06:	90 e0       	ldi	r25, 0x00	; 0
    2b08:	02 c0       	rjmp	.+4      	; 0x2b0e <DIO_u8SetPinDirection+0x80>
    2b0a:	88 0f       	add	r24, r24
    2b0c:	99 1f       	adc	r25, r25
    2b0e:	6a 95       	dec	r22
    2b10:	e2 f7       	brpl	.-8      	; 0x2b0a <DIO_u8SetPinDirection+0x7c>
    2b12:	28 2b       	or	r18, r24
    2b14:	27 bb       	out	0x17, r18	; 23
    2b16:	31 c0       	rjmp	.+98     	; 0x2b7a <DIO_u8SetPinDirection+0xec>
				}
			break;
			
			case DIO_u8_PORTC:
				if(Copy_u8PinDirection == DIO_u8_INPUT)
    2b18:	44 23       	and	r20, r20
    2b1a:	61 f4       	brne	.+24     	; 0x2b34 <DIO_u8SetPinDirection+0xa6>
				{
					CLR_BIT(DIO_u8_DDRC_REG, Copy_u8PinID);
    2b1c:	24 b3       	in	r18, 0x14	; 20
    2b1e:	81 e0       	ldi	r24, 0x01	; 1
    2b20:	90 e0       	ldi	r25, 0x00	; 0
    2b22:	02 c0       	rjmp	.+4      	; 0x2b28 <DIO_u8SetPinDirection+0x9a>
    2b24:	88 0f       	add	r24, r24
    2b26:	99 1f       	adc	r25, r25
    2b28:	6a 95       	dec	r22
    2b2a:	e2 f7       	brpl	.-8      	; 0x2b24 <DIO_u8SetPinDirection+0x96>
    2b2c:	80 95       	com	r24
    2b2e:	82 23       	and	r24, r18
    2b30:	84 bb       	out	0x14, r24	; 20
    2b32:	23 c0       	rjmp	.+70     	; 0x2b7a <DIO_u8SetPinDirection+0xec>
				}
				else
				{
					SET_BIT(DIO_u8_DDRC_REG, Copy_u8PinID);
    2b34:	24 b3       	in	r18, 0x14	; 20
    2b36:	81 e0       	ldi	r24, 0x01	; 1
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	02 c0       	rjmp	.+4      	; 0x2b40 <DIO_u8SetPinDirection+0xb2>
    2b3c:	88 0f       	add	r24, r24
    2b3e:	99 1f       	adc	r25, r25
    2b40:	6a 95       	dec	r22
    2b42:	e2 f7       	brpl	.-8      	; 0x2b3c <DIO_u8SetPinDirection+0xae>
    2b44:	28 2b       	or	r18, r24
    2b46:	24 bb       	out	0x14, r18	; 20
    2b48:	18 c0       	rjmp	.+48     	; 0x2b7a <DIO_u8SetPinDirection+0xec>
				}
			break;
			
			case DIO_u8_PORTD:
				if(Copy_u8PinDirection == DIO_u8_INPUT)
    2b4a:	44 23       	and	r20, r20
    2b4c:	61 f4       	brne	.+24     	; 0x2b66 <DIO_u8SetPinDirection+0xd8>
				{
					CLR_BIT(DIO_u8_DDRD_REG, Copy_u8PinID);
    2b4e:	21 b3       	in	r18, 0x11	; 17
    2b50:	81 e0       	ldi	r24, 0x01	; 1
    2b52:	90 e0       	ldi	r25, 0x00	; 0
    2b54:	02 c0       	rjmp	.+4      	; 0x2b5a <DIO_u8SetPinDirection+0xcc>
    2b56:	88 0f       	add	r24, r24
    2b58:	99 1f       	adc	r25, r25
    2b5a:	6a 95       	dec	r22
    2b5c:	e2 f7       	brpl	.-8      	; 0x2b56 <DIO_u8SetPinDirection+0xc8>
    2b5e:	80 95       	com	r24
    2b60:	82 23       	and	r24, r18
    2b62:	81 bb       	out	0x11, r24	; 17
    2b64:	0a c0       	rjmp	.+20     	; 0x2b7a <DIO_u8SetPinDirection+0xec>
				}
				else
				{
					SET_BIT(DIO_u8_DDRD_REG, Copy_u8PinID);
    2b66:	21 b3       	in	r18, 0x11	; 17
    2b68:	81 e0       	ldi	r24, 0x01	; 1
    2b6a:	90 e0       	ldi	r25, 0x00	; 0
    2b6c:	02 c0       	rjmp	.+4      	; 0x2b72 <DIO_u8SetPinDirection+0xe4>
    2b6e:	88 0f       	add	r24, r24
    2b70:	99 1f       	adc	r25, r25
    2b72:	6a 95       	dec	r22
    2b74:	e2 f7       	brpl	.-8      	; 0x2b6e <DIO_u8SetPinDirection+0xe0>
    2b76:	28 2b       	or	r18, r24
    2b78:	21 bb       	out	0x11, r18	; 17
    2b7a:	81 e0       	ldi	r24, 0x01	; 1
    2b7c:	08 95       	ret
    2b7e:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    2b80:	08 95       	ret

00002b82 <DIO_u8SetPinValue>:

u8 DIO_u8SetPinValue 	  (u8 Copy_u8PortID, u8 Copy_u8PinID, u8 Copy_u8PinValue)
{
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8PortID <= DIO_u8_PORTD) && (Copy_u8PinID <= DIO_u8_PIN7)
    2b82:	84 30       	cpi	r24, 0x04	; 4
    2b84:	08 f0       	brcs	.+2      	; 0x2b88 <DIO_u8SetPinValue+0x6>
    2b86:	75 c0       	rjmp	.+234    	; 0x2c72 <DIO_u8SetPinValue+0xf0>
    2b88:	68 30       	cpi	r22, 0x08	; 8
    2b8a:	08 f0       	brcs	.+2      	; 0x2b8e <DIO_u8SetPinValue+0xc>
    2b8c:	72 c0       	rjmp	.+228    	; 0x2c72 <DIO_u8SetPinValue+0xf0>
    2b8e:	42 30       	cpi	r20, 0x02	; 2
    2b90:	08 f0       	brcs	.+2      	; 0x2b94 <DIO_u8SetPinValue+0x12>
    2b92:	6f c0       	rjmp	.+222    	; 0x2c72 <DIO_u8SetPinValue+0xf0>
		&& ((Copy_u8PinValue == DIO_u8_HIGH) || (Copy_u8PinValue == DIO_u8_LOW)))
	{
		switch(Copy_u8PortID)
    2b94:	81 30       	cpi	r24, 0x01	; 1
    2b96:	09 f1       	breq	.+66     	; 0x2bda <DIO_u8SetPinValue+0x58>
    2b98:	81 30       	cpi	r24, 0x01	; 1
    2b9a:	30 f0       	brcs	.+12     	; 0x2ba8 <DIO_u8SetPinValue+0x26>
    2b9c:	82 30       	cpi	r24, 0x02	; 2
    2b9e:	b1 f1       	breq	.+108    	; 0x2c0c <DIO_u8SetPinValue+0x8a>
    2ba0:	83 30       	cpi	r24, 0x03	; 3
    2ba2:	09 f0       	breq	.+2      	; 0x2ba6 <DIO_u8SetPinValue+0x24>
    2ba4:	64 c0       	rjmp	.+200    	; 0x2c6e <DIO_u8SetPinValue+0xec>
    2ba6:	4b c0       	rjmp	.+150    	; 0x2c3e <DIO_u8SetPinValue+0xbc>
		{
			case DIO_u8_PORTA:
				if(Copy_u8PinValue == DIO_u8_HIGH)
    2ba8:	41 30       	cpi	r20, 0x01	; 1
    2baa:	59 f4       	brne	.+22     	; 0x2bc2 <DIO_u8SetPinValue+0x40>
				{
					SET_BIT(DIO_u8_PORTA_REG, Copy_u8PinID);
    2bac:	2b b3       	in	r18, 0x1b	; 27
    2bae:	81 e0       	ldi	r24, 0x01	; 1
    2bb0:	90 e0       	ldi	r25, 0x00	; 0
    2bb2:	02 c0       	rjmp	.+4      	; 0x2bb8 <DIO_u8SetPinValue+0x36>
    2bb4:	88 0f       	add	r24, r24
    2bb6:	99 1f       	adc	r25, r25
    2bb8:	6a 95       	dec	r22
    2bba:	e2 f7       	brpl	.-8      	; 0x2bb4 <DIO_u8SetPinValue+0x32>
    2bbc:	28 2b       	or	r18, r24
    2bbe:	2b bb       	out	0x1b, r18	; 27
    2bc0:	56 c0       	rjmp	.+172    	; 0x2c6e <DIO_u8SetPinValue+0xec>
				}
				else
				{
					CLR_BIT(DIO_u8_PORTA_REG, Copy_u8PinID);
    2bc2:	2b b3       	in	r18, 0x1b	; 27
    2bc4:	81 e0       	ldi	r24, 0x01	; 1
    2bc6:	90 e0       	ldi	r25, 0x00	; 0
    2bc8:	02 c0       	rjmp	.+4      	; 0x2bce <DIO_u8SetPinValue+0x4c>
    2bca:	88 0f       	add	r24, r24
    2bcc:	99 1f       	adc	r25, r25
    2bce:	6a 95       	dec	r22
    2bd0:	e2 f7       	brpl	.-8      	; 0x2bca <DIO_u8SetPinValue+0x48>
    2bd2:	80 95       	com	r24
    2bd4:	82 23       	and	r24, r18
    2bd6:	8b bb       	out	0x1b, r24	; 27
    2bd8:	4a c0       	rjmp	.+148    	; 0x2c6e <DIO_u8SetPinValue+0xec>
				}
			break;
			
			case DIO_u8_PORTB:
				if(Copy_u8PinValue == DIO_u8_HIGH)
    2bda:	41 30       	cpi	r20, 0x01	; 1
    2bdc:	59 f4       	brne	.+22     	; 0x2bf4 <DIO_u8SetPinValue+0x72>
				{
					SET_BIT(DIO_u8_PORTB_REG, Copy_u8PinID);
    2bde:	28 b3       	in	r18, 0x18	; 24
    2be0:	81 e0       	ldi	r24, 0x01	; 1
    2be2:	90 e0       	ldi	r25, 0x00	; 0
    2be4:	02 c0       	rjmp	.+4      	; 0x2bea <DIO_u8SetPinValue+0x68>
    2be6:	88 0f       	add	r24, r24
    2be8:	99 1f       	adc	r25, r25
    2bea:	6a 95       	dec	r22
    2bec:	e2 f7       	brpl	.-8      	; 0x2be6 <DIO_u8SetPinValue+0x64>
    2bee:	28 2b       	or	r18, r24
    2bf0:	28 bb       	out	0x18, r18	; 24
    2bf2:	3d c0       	rjmp	.+122    	; 0x2c6e <DIO_u8SetPinValue+0xec>
				}
				else
				{
					CLR_BIT(DIO_u8_PORTB_REG, Copy_u8PinID);
    2bf4:	28 b3       	in	r18, 0x18	; 24
    2bf6:	81 e0       	ldi	r24, 0x01	; 1
    2bf8:	90 e0       	ldi	r25, 0x00	; 0
    2bfa:	02 c0       	rjmp	.+4      	; 0x2c00 <DIO_u8SetPinValue+0x7e>
    2bfc:	88 0f       	add	r24, r24
    2bfe:	99 1f       	adc	r25, r25
    2c00:	6a 95       	dec	r22
    2c02:	e2 f7       	brpl	.-8      	; 0x2bfc <DIO_u8SetPinValue+0x7a>
    2c04:	80 95       	com	r24
    2c06:	82 23       	and	r24, r18
    2c08:	88 bb       	out	0x18, r24	; 24
    2c0a:	31 c0       	rjmp	.+98     	; 0x2c6e <DIO_u8SetPinValue+0xec>
				}
			break;
			
			case DIO_u8_PORTC:
				if(Copy_u8PinValue == DIO_u8_HIGH)
    2c0c:	41 30       	cpi	r20, 0x01	; 1
    2c0e:	59 f4       	brne	.+22     	; 0x2c26 <DIO_u8SetPinValue+0xa4>
				{
					SET_BIT(DIO_u8_PORTC_REG, Copy_u8PinID);
    2c10:	25 b3       	in	r18, 0x15	; 21
    2c12:	81 e0       	ldi	r24, 0x01	; 1
    2c14:	90 e0       	ldi	r25, 0x00	; 0
    2c16:	02 c0       	rjmp	.+4      	; 0x2c1c <DIO_u8SetPinValue+0x9a>
    2c18:	88 0f       	add	r24, r24
    2c1a:	99 1f       	adc	r25, r25
    2c1c:	6a 95       	dec	r22
    2c1e:	e2 f7       	brpl	.-8      	; 0x2c18 <DIO_u8SetPinValue+0x96>
    2c20:	28 2b       	or	r18, r24
    2c22:	25 bb       	out	0x15, r18	; 21
    2c24:	24 c0       	rjmp	.+72     	; 0x2c6e <DIO_u8SetPinValue+0xec>
				}
				else
				{
					CLR_BIT(DIO_u8_PORTC_REG, Copy_u8PinID);
    2c26:	25 b3       	in	r18, 0x15	; 21
    2c28:	81 e0       	ldi	r24, 0x01	; 1
    2c2a:	90 e0       	ldi	r25, 0x00	; 0
    2c2c:	02 c0       	rjmp	.+4      	; 0x2c32 <DIO_u8SetPinValue+0xb0>
    2c2e:	88 0f       	add	r24, r24
    2c30:	99 1f       	adc	r25, r25
    2c32:	6a 95       	dec	r22
    2c34:	e2 f7       	brpl	.-8      	; 0x2c2e <DIO_u8SetPinValue+0xac>
    2c36:	80 95       	com	r24
    2c38:	82 23       	and	r24, r18
    2c3a:	85 bb       	out	0x15, r24	; 21
    2c3c:	18 c0       	rjmp	.+48     	; 0x2c6e <DIO_u8SetPinValue+0xec>
				}
			break;
			
			case DIO_u8_PORTD:
				if(Copy_u8PinValue == DIO_u8_HIGH)
    2c3e:	41 30       	cpi	r20, 0x01	; 1
    2c40:	59 f4       	brne	.+22     	; 0x2c58 <DIO_u8SetPinValue+0xd6>
				{
					SET_BIT(DIO_u8_PORTD_REG, Copy_u8PinID);
    2c42:	22 b3       	in	r18, 0x12	; 18
    2c44:	81 e0       	ldi	r24, 0x01	; 1
    2c46:	90 e0       	ldi	r25, 0x00	; 0
    2c48:	02 c0       	rjmp	.+4      	; 0x2c4e <DIO_u8SetPinValue+0xcc>
    2c4a:	88 0f       	add	r24, r24
    2c4c:	99 1f       	adc	r25, r25
    2c4e:	6a 95       	dec	r22
    2c50:	e2 f7       	brpl	.-8      	; 0x2c4a <DIO_u8SetPinValue+0xc8>
    2c52:	28 2b       	or	r18, r24
    2c54:	22 bb       	out	0x12, r18	; 18
    2c56:	0b c0       	rjmp	.+22     	; 0x2c6e <DIO_u8SetPinValue+0xec>
				}
				else
				{
					CLR_BIT(DIO_u8_PORTD_REG, Copy_u8PinID);
    2c58:	22 b3       	in	r18, 0x12	; 18
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	02 c0       	rjmp	.+4      	; 0x2c64 <DIO_u8SetPinValue+0xe2>
    2c60:	88 0f       	add	r24, r24
    2c62:	99 1f       	adc	r25, r25
    2c64:	6a 95       	dec	r22
    2c66:	e2 f7       	brpl	.-8      	; 0x2c60 <DIO_u8SetPinValue+0xde>
    2c68:	80 95       	com	r24
    2c6a:	82 23       	and	r24, r18
    2c6c:	82 bb       	out	0x12, r24	; 18
    2c6e:	81 e0       	ldi	r24, 0x01	; 1
    2c70:	08 95       	ret
    2c72:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    2c74:	08 95       	ret

00002c76 <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue 	  (u8 Copy_u8PortID, u8 Copy_u8PinID, u8* Copy_pu8PinValue)
{
    2c76:	28 2f       	mov	r18, r24
    2c78:	fa 01       	movw	r30, r20
	u8 Local_u8ErrorState = STD_TYPES_OK;
	u8 Local_u8ReturnedPinValue; 			// To make the driver more generic
	
	if((Copy_u8PortID <= DIO_u8_PORTD) && (Copy_u8PinID <= DIO_u8_PIN7) && (Copy_pu8PinValue != NULL)) //Make sure user sends me address of pin needed
    2c7a:	84 30       	cpi	r24, 0x04	; 4
    2c7c:	60 f5       	brcc	.+88     	; 0x2cd6 <DIO_u8GetPinValue+0x60>
    2c7e:	68 30       	cpi	r22, 0x08	; 8
    2c80:	50 f5       	brcc	.+84     	; 0x2cd6 <DIO_u8GetPinValue+0x60>
    2c82:	41 15       	cp	r20, r1
    2c84:	51 05       	cpc	r21, r1
    2c86:	39 f1       	breq	.+78     	; 0x2cd6 <DIO_u8GetPinValue+0x60>
	{
		switch(Copy_u8PortID)
    2c88:	81 30       	cpi	r24, 0x01	; 1
    2c8a:	49 f0       	breq	.+18     	; 0x2c9e <DIO_u8GetPinValue+0x28>
    2c8c:	81 30       	cpi	r24, 0x01	; 1
    2c8e:	28 f0       	brcs	.+10     	; 0x2c9a <DIO_u8GetPinValue+0x24>
    2c90:	82 30       	cpi	r24, 0x02	; 2
    2c92:	81 f0       	breq	.+32     	; 0x2cb4 <DIO_u8GetPinValue+0x3e>
    2c94:	83 30       	cpi	r24, 0x03	; 3
    2c96:	d1 f4       	brne	.+52     	; 0x2ccc <DIO_u8GetPinValue+0x56>
    2c98:	0f c0       	rjmp	.+30     	; 0x2cb8 <DIO_u8GetPinValue+0x42>
		{
			case DIO_u8_PORTA:
				Local_u8ReturnedPinValue = GET_BIT(DIO_u8_PINA_REG, Copy_u8PinID);
    2c9a:	89 b3       	in	r24, 0x19	; 25
    2c9c:	0e c0       	rjmp	.+28     	; 0x2cba <DIO_u8GetPinValue+0x44>
					*Copy_pu8PinValue = DIO_u8_HIGH;
				}
			break;
			
			case DIO_u8_PORTB:
				Local_u8ReturnedPinValue = GET_BIT(DIO_u8_PINB_REG, Copy_u8PinID);
    2c9e:	86 b3       	in	r24, 0x16	; 22
				if(Local_u8ReturnedPinValue == 0)
    2ca0:	90 e0       	ldi	r25, 0x00	; 0
    2ca2:	02 c0       	rjmp	.+4      	; 0x2ca8 <DIO_u8GetPinValue+0x32>
    2ca4:	95 95       	asr	r25
    2ca6:	87 95       	ror	r24
    2ca8:	6a 95       	dec	r22
    2caa:	e2 f7       	brpl	.-8      	; 0x2ca4 <DIO_u8GetPinValue+0x2e>
    2cac:	80 ff       	sbrs	r24, 0
    2cae:	0d c0       	rjmp	.+26     	; 0x2cca <DIO_u8GetPinValue+0x54>
				{
					*Copy_pu8PinValue = DIO_u8_LOW;
				}
				else
				{
					*Copy_pu8PinValue = DIO_u8_HIGH;
    2cb0:	20 83       	st	Z, r18
    2cb2:	0c c0       	rjmp	.+24     	; 0x2ccc <DIO_u8GetPinValue+0x56>
				}
			break;
			
			case DIO_u8_PORTC:
				Local_u8ReturnedPinValue = GET_BIT(DIO_u8_PINC_REG, Copy_u8PinID);
    2cb4:	83 b3       	in	r24, 0x13	; 19
    2cb6:	01 c0       	rjmp	.+2      	; 0x2cba <DIO_u8GetPinValue+0x44>
					*Copy_pu8PinValue = DIO_u8_HIGH;
				}
			break;
			
			case DIO_u8_PORTD:
				Local_u8ReturnedPinValue = GET_BIT(DIO_u8_PIND_REG, Copy_u8PinID);
    2cb8:	80 b3       	in	r24, 0x10	; 16
				if(Local_u8ReturnedPinValue == 0)
    2cba:	90 e0       	ldi	r25, 0x00	; 0
    2cbc:	02 c0       	rjmp	.+4      	; 0x2cc2 <DIO_u8GetPinValue+0x4c>
    2cbe:	95 95       	asr	r25
    2cc0:	87 95       	ror	r24
    2cc2:	6a 95       	dec	r22
    2cc4:	e2 f7       	brpl	.-8      	; 0x2cbe <DIO_u8GetPinValue+0x48>
    2cc6:	80 fd       	sbrc	r24, 0
    2cc8:	03 c0       	rjmp	.+6      	; 0x2cd0 <DIO_u8GetPinValue+0x5a>
				{
					*Copy_pu8PinValue = DIO_u8_LOW;
    2cca:	10 82       	st	Z, r1
    2ccc:	81 e0       	ldi	r24, 0x01	; 1
    2cce:	08 95       	ret
				}
				else
				{
					*Copy_pu8PinValue = DIO_u8_HIGH;
    2cd0:	81 e0       	ldi	r24, 0x01	; 1
    2cd2:	80 83       	st	Z, r24
    2cd4:	08 95       	ret
    2cd6:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    2cd8:	08 95       	ret

00002cda <DIO_u8TogglePinValue>:

u8 DIO_u8TogglePinValue	  (u8 Copy_u8PortID, u8 Copy_u8PinID)
{
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8PortID <= DIO_u8_PORTD) && (Copy_u8PinID <= DIO_u8_PIN7))
    2cda:	84 30       	cpi	r24, 0x04	; 4
    2cdc:	c0 f5       	brcc	.+112    	; 0x2d4e <DIO_u8TogglePinValue+0x74>
    2cde:	68 30       	cpi	r22, 0x08	; 8
    2ce0:	b0 f5       	brcc	.+108    	; 0x2d4e <DIO_u8TogglePinValue+0x74>
	{
		switch (Copy_u8PortID)
    2ce2:	81 30       	cpi	r24, 0x01	; 1
    2ce4:	91 f0       	breq	.+36     	; 0x2d0a <DIO_u8TogglePinValue+0x30>
    2ce6:	81 30       	cpi	r24, 0x01	; 1
    2ce8:	28 f0       	brcs	.+10     	; 0x2cf4 <DIO_u8TogglePinValue+0x1a>
    2cea:	82 30       	cpi	r24, 0x02	; 2
    2cec:	c9 f0       	breq	.+50     	; 0x2d20 <DIO_u8TogglePinValue+0x46>
    2cee:	83 30       	cpi	r24, 0x03	; 3
    2cf0:	61 f5       	brne	.+88     	; 0x2d4a <DIO_u8TogglePinValue+0x70>
    2cf2:	21 c0       	rjmp	.+66     	; 0x2d36 <DIO_u8TogglePinValue+0x5c>
		{
			case DIO_u8_PORTA:
				TOGGLE_BIT(DIO_u8_PORTA_REG, Copy_u8PinID);
    2cf4:	2b b3       	in	r18, 0x1b	; 27
    2cf6:	81 e0       	ldi	r24, 0x01	; 1
    2cf8:	90 e0       	ldi	r25, 0x00	; 0
    2cfa:	02 c0       	rjmp	.+4      	; 0x2d00 <DIO_u8TogglePinValue+0x26>
    2cfc:	88 0f       	add	r24, r24
    2cfe:	99 1f       	adc	r25, r25
    2d00:	6a 95       	dec	r22
    2d02:	e2 f7       	brpl	.-8      	; 0x2cfc <DIO_u8TogglePinValue+0x22>
    2d04:	28 27       	eor	r18, r24
    2d06:	2b bb       	out	0x1b, r18	; 27
    2d08:	20 c0       	rjmp	.+64     	; 0x2d4a <DIO_u8TogglePinValue+0x70>
			break;
			
			case DIO_u8_PORTB:
				TOGGLE_BIT(DIO_u8_PORTB_REG, Copy_u8PinID);
    2d0a:	28 b3       	in	r18, 0x18	; 24
    2d0c:	81 e0       	ldi	r24, 0x01	; 1
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
    2d10:	02 c0       	rjmp	.+4      	; 0x2d16 <DIO_u8TogglePinValue+0x3c>
    2d12:	88 0f       	add	r24, r24
    2d14:	99 1f       	adc	r25, r25
    2d16:	6a 95       	dec	r22
    2d18:	e2 f7       	brpl	.-8      	; 0x2d12 <DIO_u8TogglePinValue+0x38>
    2d1a:	28 27       	eor	r18, r24
    2d1c:	28 bb       	out	0x18, r18	; 24
    2d1e:	15 c0       	rjmp	.+42     	; 0x2d4a <DIO_u8TogglePinValue+0x70>
			break;
			
			case DIO_u8_PORTC:
				TOGGLE_BIT(DIO_u8_PORTC_REG, Copy_u8PinID);
    2d20:	25 b3       	in	r18, 0x15	; 21
    2d22:	81 e0       	ldi	r24, 0x01	; 1
    2d24:	90 e0       	ldi	r25, 0x00	; 0
    2d26:	02 c0       	rjmp	.+4      	; 0x2d2c <DIO_u8TogglePinValue+0x52>
    2d28:	88 0f       	add	r24, r24
    2d2a:	99 1f       	adc	r25, r25
    2d2c:	6a 95       	dec	r22
    2d2e:	e2 f7       	brpl	.-8      	; 0x2d28 <DIO_u8TogglePinValue+0x4e>
    2d30:	28 27       	eor	r18, r24
    2d32:	25 bb       	out	0x15, r18	; 21
    2d34:	0a c0       	rjmp	.+20     	; 0x2d4a <DIO_u8TogglePinValue+0x70>
			break;
			
			case DIO_u8_PORTD:
				TOGGLE_BIT(DIO_u8_PORTD_REG, Copy_u8PinID);
    2d36:	22 b3       	in	r18, 0x12	; 18
    2d38:	81 e0       	ldi	r24, 0x01	; 1
    2d3a:	90 e0       	ldi	r25, 0x00	; 0
    2d3c:	02 c0       	rjmp	.+4      	; 0x2d42 <DIO_u8TogglePinValue+0x68>
    2d3e:	88 0f       	add	r24, r24
    2d40:	99 1f       	adc	r25, r25
    2d42:	6a 95       	dec	r22
    2d44:	e2 f7       	brpl	.-8      	; 0x2d3e <DIO_u8TogglePinValue+0x64>
    2d46:	28 27       	eor	r18, r24
    2d48:	22 bb       	out	0x12, r18	; 18
    2d4a:	81 e0       	ldi	r24, 0x01	; 1
    2d4c:	08 95       	ret
    2d4e:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    2d50:	08 95       	ret

00002d52 <DIO_u8SetPortDirection>:

u8 DIO_u8SetPortDirection (u8 Copy_u8PortID, u8 Copy_u8PortDirection)
{
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8PortID <= DIO_u8_PORTD) && ((Copy_u8PortDirection == DIO_u8_INPUT) || (Copy_u8PortDirection == DIO_u8_OUTPUT)))
    2d52:	84 30       	cpi	r24, 0x04	; 4
    2d54:	40 f5       	brcc	.+80     	; 0x2da6 <DIO_u8SetPortDirection+0x54>
    2d56:	62 30       	cpi	r22, 0x02	; 2
    2d58:	30 f5       	brcc	.+76     	; 0x2da6 <DIO_u8SetPortDirection+0x54>
	{
		switch(Copy_u8PortID)
    2d5a:	81 30       	cpi	r24, 0x01	; 1
    2d5c:	71 f0       	breq	.+28     	; 0x2d7a <DIO_u8SetPortDirection+0x28>
    2d5e:	81 30       	cpi	r24, 0x01	; 1
    2d60:	28 f0       	brcs	.+10     	; 0x2d6c <DIO_u8SetPortDirection+0x1a>
    2d62:	82 30       	cpi	r24, 0x02	; 2
    2d64:	89 f0       	breq	.+34     	; 0x2d88 <DIO_u8SetPortDirection+0x36>
    2d66:	83 30       	cpi	r24, 0x03	; 3
    2d68:	e1 f4       	brne	.+56     	; 0x2da2 <DIO_u8SetPortDirection+0x50>
    2d6a:	15 c0       	rjmp	.+42     	; 0x2d96 <DIO_u8SetPortDirection+0x44>
		{
			case DIO_u8_PORTA:
				if(Copy_u8PortDirection == DIO_u8_INPUT)
    2d6c:	66 23       	and	r22, r22
    2d6e:	11 f4       	brne	.+4      	; 0x2d74 <DIO_u8SetPortDirection+0x22>
				{
					DIO_u8_DDRA_REG = 0x00;
    2d70:	1a ba       	out	0x1a, r1	; 26
    2d72:	17 c0       	rjmp	.+46     	; 0x2da2 <DIO_u8SetPortDirection+0x50>
				}
				else
				{
					DIO_u8_DDRA_REG = 0xFF;
    2d74:	8f ef       	ldi	r24, 0xFF	; 255
    2d76:	8a bb       	out	0x1a, r24	; 26
    2d78:	14 c0       	rjmp	.+40     	; 0x2da2 <DIO_u8SetPortDirection+0x50>
				}
			break;
			
			case DIO_u8_PORTB:
				if(Copy_u8PortDirection == DIO_u8_INPUT)
    2d7a:	66 23       	and	r22, r22
    2d7c:	11 f4       	brne	.+4      	; 0x2d82 <DIO_u8SetPortDirection+0x30>
				{
					DIO_u8_DDRB_REG = 0x00;
    2d7e:	17 ba       	out	0x17, r1	; 23
    2d80:	10 c0       	rjmp	.+32     	; 0x2da2 <DIO_u8SetPortDirection+0x50>
				}
				else
				{
					DIO_u8_DDRB_REG = 0xFF;
    2d82:	8f ef       	ldi	r24, 0xFF	; 255
    2d84:	87 bb       	out	0x17, r24	; 23
    2d86:	0d c0       	rjmp	.+26     	; 0x2da2 <DIO_u8SetPortDirection+0x50>
				}
			break;
			
			case DIO_u8_PORTC:
				if(Copy_u8PortDirection == DIO_u8_INPUT)
    2d88:	66 23       	and	r22, r22
    2d8a:	11 f4       	brne	.+4      	; 0x2d90 <DIO_u8SetPortDirection+0x3e>
				{
					DIO_u8_DDRC_REG = 0x00;
    2d8c:	14 ba       	out	0x14, r1	; 20
    2d8e:	09 c0       	rjmp	.+18     	; 0x2da2 <DIO_u8SetPortDirection+0x50>
				}
				else
				{
					DIO_u8_DDRC_REG = 0xFF;
    2d90:	8f ef       	ldi	r24, 0xFF	; 255
    2d92:	84 bb       	out	0x14, r24	; 20
    2d94:	06 c0       	rjmp	.+12     	; 0x2da2 <DIO_u8SetPortDirection+0x50>
				}
			break;
			
			case DIO_u8_PORTD:
				if(Copy_u8PortDirection == DIO_u8_INPUT)
    2d96:	66 23       	and	r22, r22
    2d98:	11 f4       	brne	.+4      	; 0x2d9e <DIO_u8SetPortDirection+0x4c>
				{
					DIO_u8_DDRD_REG = 0x00;
    2d9a:	11 ba       	out	0x11, r1	; 17
    2d9c:	02 c0       	rjmp	.+4      	; 0x2da2 <DIO_u8SetPortDirection+0x50>
				}
				else
				{
					DIO_u8_DDRD_REG = 0xFF;
    2d9e:	8f ef       	ldi	r24, 0xFF	; 255
    2da0:	81 bb       	out	0x11, r24	; 17
    2da2:	81 e0       	ldi	r24, 0x01	; 1
    2da4:	08 95       	ret
    2da6:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    2da8:	08 95       	ret

00002daa <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue 	  (u8 Copy_u8PortID, u8 Copy_u8PortValue)
{
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if(Copy_u8PortID <= DIO_u8_PORTD) // This if condition can be removed and it won't affect the function
    2daa:	84 30       	cpi	r24, 0x04	; 4
    2dac:	10 f0       	brcs	.+4      	; 0x2db2 <DIO_u8SetPortValue+0x8>
    2dae:	80 e0       	ldi	r24, 0x00	; 0
    2db0:	08 95       	ret
	{
		switch(Copy_u8PortID)
    2db2:	81 30       	cpi	r24, 0x01	; 1
    2db4:	49 f0       	breq	.+18     	; 0x2dc8 <DIO_u8SetPortValue+0x1e>
    2db6:	81 30       	cpi	r24, 0x01	; 1
    2db8:	28 f0       	brcs	.+10     	; 0x2dc4 <DIO_u8SetPortValue+0x1a>
    2dba:	82 30       	cpi	r24, 0x02	; 2
    2dbc:	39 f0       	breq	.+14     	; 0x2dcc <DIO_u8SetPortValue+0x22>
    2dbe:	83 30       	cpi	r24, 0x03	; 3
    2dc0:	31 f4       	brne	.+12     	; 0x2dce <DIO_u8SetPortValue+0x24>
    2dc2:	07 c0       	rjmp	.+14     	; 0x2dd2 <DIO_u8SetPortValue+0x28>
		{
			case DIO_u8_PORTA:
				DIO_u8_PORTA_REG = Copy_u8PortValue;
    2dc4:	6b bb       	out	0x1b, r22	; 27
    2dc6:	03 c0       	rjmp	.+6      	; 0x2dce <DIO_u8SetPortValue+0x24>
			break;
			
			case DIO_u8_PORTB:
				DIO_u8_PORTB_REG = Copy_u8PortValue;
    2dc8:	68 bb       	out	0x18, r22	; 24
    2dca:	01 c0       	rjmp	.+2      	; 0x2dce <DIO_u8SetPortValue+0x24>
			break;
			
			case DIO_u8_PORTC:
				DIO_u8_PORTC_REG = Copy_u8PortValue;
    2dcc:	65 bb       	out	0x15, r22	; 21
    2dce:	81 e0       	ldi	r24, 0x01	; 1
    2dd0:	08 95       	ret
			break;
			
			case DIO_u8_PORTD:
				DIO_u8_PORTD_REG = Copy_u8PortValue;
    2dd2:	62 bb       	out	0x12, r22	; 18
    2dd4:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    2dd6:	08 95       	ret

00002dd8 <DIO_u8GetPortValue>:

u8 DIO_u8GetPortValue 	  (u8 Copy_u8PortID, u8* Copy_pu8PortValue)
{
    2dd8:	fb 01       	movw	r30, r22
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if(Copy_u8PortID <= DIO_u8_PORTD && Copy_pu8PortValue != NULL)
    2dda:	84 30       	cpi	r24, 0x04	; 4
    2ddc:	b0 f4       	brcc	.+44     	; 0x2e0a <DIO_u8GetPortValue+0x32>
    2dde:	61 15       	cp	r22, r1
    2de0:	71 05       	cpc	r23, r1
    2de2:	99 f0       	breq	.+38     	; 0x2e0a <DIO_u8GetPortValue+0x32>
	{
		switch(Copy_u8PortID)
    2de4:	81 30       	cpi	r24, 0x01	; 1
    2de6:	49 f0       	breq	.+18     	; 0x2dfa <DIO_u8GetPortValue+0x22>
    2de8:	81 30       	cpi	r24, 0x01	; 1
    2dea:	28 f0       	brcs	.+10     	; 0x2df6 <DIO_u8GetPortValue+0x1e>
    2dec:	82 30       	cpi	r24, 0x02	; 2
    2dee:	39 f0       	breq	.+14     	; 0x2dfe <DIO_u8GetPortValue+0x26>
    2df0:	83 30       	cpi	r24, 0x03	; 3
    2df2:	49 f4       	brne	.+18     	; 0x2e06 <DIO_u8GetPortValue+0x2e>
    2df4:	06 c0       	rjmp	.+12     	; 0x2e02 <DIO_u8GetPortValue+0x2a>
		{
			case DIO_u8_PORTA:
				*Copy_pu8PortValue = DIO_u8_PINA_REG;
    2df6:	89 b3       	in	r24, 0x19	; 25
    2df8:	05 c0       	rjmp	.+10     	; 0x2e04 <DIO_u8GetPortValue+0x2c>
			break;
			
			case DIO_u8_PORTB:
				*Copy_pu8PortValue = DIO_u8_PINB_REG;
    2dfa:	86 b3       	in	r24, 0x16	; 22
    2dfc:	03 c0       	rjmp	.+6      	; 0x2e04 <DIO_u8GetPortValue+0x2c>
			break;
			
			case DIO_u8_PORTC:
				*Copy_pu8PortValue = DIO_u8_PINC_REG;
    2dfe:	83 b3       	in	r24, 0x13	; 19
    2e00:	01 c0       	rjmp	.+2      	; 0x2e04 <DIO_u8GetPortValue+0x2c>
			break;
			
			case DIO_u8_PORTD:
				*Copy_pu8PortValue = DIO_u8_PIND_REG;
    2e02:	80 b3       	in	r24, 0x10	; 16
    2e04:	80 83       	st	Z, r24
    2e06:	81 e0       	ldi	r24, 0x01	; 1
    2e08:	08 95       	ret
    2e0a:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    2e0c:	08 95       	ret

00002e0e <KPD_u8GetSwitch>:
#include "KPD_Interface.h"
#include "KPD_Private.h"
#include "KPD_Config.h"

u8 KPD_u8GetSwitch(u8* Copy_Pu8ReturnedSwitch)
{
    2e0e:	af 92       	push	r10
    2e10:	bf 92       	push	r11
    2e12:	cf 92       	push	r12
    2e14:	df 92       	push	r13
    2e16:	ef 92       	push	r14
    2e18:	ff 92       	push	r15
    2e1a:	0f 93       	push	r16
    2e1c:	1f 93       	push	r17
    2e1e:	df 93       	push	r29
    2e20:	cf 93       	push	r28
    2e22:	00 d0       	rcall	.+0      	; 0x2e24 <KPD_u8GetSwitch+0x16>
    2e24:	cd b7       	in	r28, 0x3d	; 61
    2e26:	de b7       	in	r29, 0x3e	; 62
    2e28:	7c 01       	movw	r14, r24
	static u8 Local_Au8RowsPinsArr[KPD_u8_ROWS_NUMBER] 						= KPD_ROWS_PINS;  /* Also make a Ports array if the ins are on different ports */
	static u8 Local_Au8ColsPinsArr[KPD_u8_COLS_NUMBER] 						= KPD_COLS_PINS;
	static u8 Local_Au8KPDValuesArr[KPD_u8_ROWS_NUMBER][KPD_u8_COLS_NUMBER] = KPD_KEYS;
	/* Made them static so it doesn't get pushed every time I call the function */
	
	if(Copy_Pu8ReturnedSwitch != NULL)
    2e2a:	00 97       	sbiw	r24, 0x00	; 0
    2e2c:	11 f4       	brne	.+4      	; 0x2e32 <KPD_u8GetSwitch+0x24>
    2e2e:	80 e0       	ldi	r24, 0x00	; 0
    2e30:	6c c0       	rjmp	.+216    	; 0x2f0a <KPD_u8GetSwitch+0xfc>
	{
		*Copy_Pu8ReturnedSwitch = KPD_u8_NOT_PRESSED;
    2e32:	8f ef       	ldi	r24, 0xFF	; 255
    2e34:	f7 01       	movw	r30, r14
    2e36:	80 83       	st	Z, r24
    2e38:	1a 82       	std	Y+2, r1	; 0x02
    2e3a:	00 e0       	ldi	r16, 0x00	; 0
    2e3c:	10 e0       	ldi	r17, 0x00	; 0
			DIO_u8SetPinValue(KPD_u8_ROWS_PORT, Local_Au8RowsPinsArr[Local_u8RowsCounter], DIO_u8_LOW);
			/* Check Column Pins*/
			for(u8 Local_u8ColsCounter = 0; Local_u8ColsCounter<KPD_u8_COLS_NUMBER; Local_u8ColsCounter++)
			{
				/* Check if a Column is low */
				DIO_u8GetPinValue(KPD_u8_COLUMNS_PORT, Local_Au8ColsPinsArr[Local_u8ColsCounter], &Local_u8PinValue);
    2e3e:	5e 01       	movw	r10, r28
    2e40:	08 94       	sec
    2e42:	a1 1c       	adc	r10, r1
    2e44:	b1 1c       	adc	r11, r1
	{
		*Copy_Pu8ReturnedSwitch = KPD_u8_NOT_PRESSED;
		for(u8 Local_u8RowsCounter = 0; Local_u8RowsCounter<KPD_u8_ROWS_NUMBER; Local_u8RowsCounter++)
		{
			/* Activate each Row */
			DIO_u8SetPinValue(KPD_u8_ROWS_PORT, Local_Au8RowsPinsArr[Local_u8RowsCounter], DIO_u8_LOW);
    2e46:	f8 01       	movw	r30, r16
    2e48:	ec 5d       	subi	r30, 0xDC	; 220
    2e4a:	fd 4f       	sbci	r31, 0xFD	; 253
    2e4c:	c0 80       	ld	r12, Z
    2e4e:	82 e0       	ldi	r24, 0x02	; 2
    2e50:	6c 2d       	mov	r22, r12
    2e52:	40 e0       	ldi	r20, 0x00	; 0
    2e54:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
			/* Check Column Pins*/
			for(u8 Local_u8ColsCounter = 0; Local_u8ColsCounter<KPD_u8_COLS_NUMBER; Local_u8ColsCounter++)
			{
				/* Check if a Column is low */
				DIO_u8GetPinValue(KPD_u8_COLUMNS_PORT, Local_Au8ColsPinsArr[Local_u8ColsCounter], &Local_u8PinValue);
    2e58:	64 e0       	ldi	r22, 0x04	; 4
    2e5a:	d6 2e       	mov	r13, r22
    2e5c:	83 e0       	ldi	r24, 0x03	; 3
    2e5e:	64 e0       	ldi	r22, 0x04	; 4
    2e60:	a5 01       	movw	r20, r10
    2e62:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <DIO_u8GetPinValue>
				if(Local_u8PinValue == DIO_u8_LOW)
    2e66:	89 81       	ldd	r24, Y+1	; 0x01
    2e68:	88 23       	and	r24, r24
    2e6a:	19 f4       	brne	.+6      	; 0x2e72 <KPD_u8GetSwitch+0x64>
    2e6c:	80 e0       	ldi	r24, 0x00	; 0
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
    2e70:	26 c0       	rjmp	.+76     	; 0x2ebe <KPD_u8GetSwitch+0xb0>
			DIO_u8SetPinValue(KPD_u8_ROWS_PORT, Local_Au8RowsPinsArr[Local_u8RowsCounter], DIO_u8_LOW);
			/* Check Column Pins*/
			for(u8 Local_u8ColsCounter = 0; Local_u8ColsCounter<KPD_u8_COLS_NUMBER; Local_u8ColsCounter++)
			{
				/* Check if a Column is low */
				DIO_u8GetPinValue(KPD_u8_COLUMNS_PORT, Local_Au8ColsPinsArr[Local_u8ColsCounter], &Local_u8PinValue);
    2e72:	55 e0       	ldi	r21, 0x05	; 5
    2e74:	d5 2e       	mov	r13, r21
    2e76:	83 e0       	ldi	r24, 0x03	; 3
    2e78:	65 e0       	ldi	r22, 0x05	; 5
    2e7a:	a5 01       	movw	r20, r10
    2e7c:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <DIO_u8GetPinValue>
				if(Local_u8PinValue == DIO_u8_LOW)
    2e80:	89 81       	ldd	r24, Y+1	; 0x01
    2e82:	88 23       	and	r24, r24
    2e84:	19 f4       	brne	.+6      	; 0x2e8c <KPD_u8GetSwitch+0x7e>
    2e86:	81 e0       	ldi	r24, 0x01	; 1
    2e88:	90 e0       	ldi	r25, 0x00	; 0
    2e8a:	19 c0       	rjmp	.+50     	; 0x2ebe <KPD_u8GetSwitch+0xb0>
			DIO_u8SetPinValue(KPD_u8_ROWS_PORT, Local_Au8RowsPinsArr[Local_u8RowsCounter], DIO_u8_LOW);
			/* Check Column Pins*/
			for(u8 Local_u8ColsCounter = 0; Local_u8ColsCounter<KPD_u8_COLS_NUMBER; Local_u8ColsCounter++)
			{
				/* Check if a Column is low */
				DIO_u8GetPinValue(KPD_u8_COLUMNS_PORT, Local_Au8ColsPinsArr[Local_u8ColsCounter], &Local_u8PinValue);
    2e8c:	46 e0       	ldi	r20, 0x06	; 6
    2e8e:	d4 2e       	mov	r13, r20
    2e90:	83 e0       	ldi	r24, 0x03	; 3
    2e92:	66 e0       	ldi	r22, 0x06	; 6
    2e94:	a5 01       	movw	r20, r10
    2e96:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <DIO_u8GetPinValue>
				if(Local_u8PinValue == DIO_u8_LOW)
    2e9a:	89 81       	ldd	r24, Y+1	; 0x01
    2e9c:	88 23       	and	r24, r24
    2e9e:	19 f4       	brne	.+6      	; 0x2ea6 <KPD_u8GetSwitch+0x98>
    2ea0:	82 e0       	ldi	r24, 0x02	; 2
    2ea2:	90 e0       	ldi	r25, 0x00	; 0
    2ea4:	0c c0       	rjmp	.+24     	; 0x2ebe <KPD_u8GetSwitch+0xb0>
			DIO_u8SetPinValue(KPD_u8_ROWS_PORT, Local_Au8RowsPinsArr[Local_u8RowsCounter], DIO_u8_LOW);
			/* Check Column Pins*/
			for(u8 Local_u8ColsCounter = 0; Local_u8ColsCounter<KPD_u8_COLS_NUMBER; Local_u8ColsCounter++)
			{
				/* Check if a Column is low */
				DIO_u8GetPinValue(KPD_u8_COLUMNS_PORT, Local_Au8ColsPinsArr[Local_u8ColsCounter], &Local_u8PinValue);
    2ea6:	37 e0       	ldi	r19, 0x07	; 7
    2ea8:	d3 2e       	mov	r13, r19
    2eaa:	83 e0       	ldi	r24, 0x03	; 3
    2eac:	67 e0       	ldi	r22, 0x07	; 7
    2eae:	a5 01       	movw	r20, r10
    2eb0:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <DIO_u8GetPinValue>
				if(Local_u8PinValue == DIO_u8_LOW)
    2eb4:	89 81       	ldd	r24, Y+1	; 0x01
    2eb6:	88 23       	and	r24, r24
    2eb8:	c9 f4       	brne	.+50     	; 0x2eec <KPD_u8GetSwitch+0xde>
    2eba:	83 e0       	ldi	r24, 0x03	; 3
    2ebc:	90 e0       	ldi	r25, 0x00	; 0
				{
					*Copy_Pu8ReturnedSwitch = Local_Au8KPDValuesArr[Local_u8RowsCounter][Local_u8ColsCounter];
    2ebe:	f8 01       	movw	r30, r16
    2ec0:	ee 0f       	add	r30, r30
    2ec2:	ff 1f       	adc	r31, r31
    2ec4:	ee 0f       	add	r30, r30
    2ec6:	ff 1f       	adc	r31, r31
    2ec8:	e8 0f       	add	r30, r24
    2eca:	f9 1f       	adc	r31, r25
    2ecc:	ec 5e       	subi	r30, 0xEC	; 236
    2ece:	fd 4f       	sbci	r31, 0xFD	; 253
    2ed0:	80 81       	ld	r24, Z
    2ed2:	f7 01       	movw	r30, r14
    2ed4:	80 83       	st	Z, r24
    2ed6:	05 c0       	rjmp	.+10     	; 0x2ee2 <KPD_u8GetSwitch+0xd4>
					/* To make the function stuck so the number is returned only one time */
					while(Local_u8PinValue == DIO_u8_LOW)
					{
						DIO_u8GetPinValue(KPD_u8_COLUMNS_PORT, Local_Au8ColsPinsArr[Local_u8ColsCounter], &Local_u8PinValue);
    2ed8:	83 e0       	ldi	r24, 0x03	; 3
    2eda:	6d 2d       	mov	r22, r13
    2edc:	a5 01       	movw	r20, r10
    2ede:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <DIO_u8GetPinValue>
				DIO_u8GetPinValue(KPD_u8_COLUMNS_PORT, Local_Au8ColsPinsArr[Local_u8ColsCounter], &Local_u8PinValue);
				if(Local_u8PinValue == DIO_u8_LOW)
				{
					*Copy_Pu8ReturnedSwitch = Local_Au8KPDValuesArr[Local_u8RowsCounter][Local_u8ColsCounter];
					/* To make the function stuck so the number is returned only one time */
					while(Local_u8PinValue == DIO_u8_LOW)
    2ee2:	89 81       	ldd	r24, Y+1	; 0x01
    2ee4:	88 23       	and	r24, r24
    2ee6:	c1 f3       	breq	.-16     	; 0x2ed8 <KPD_u8GetSwitch+0xca>
    2ee8:	f1 e0       	ldi	r31, 0x01	; 1
    2eea:	fa 83       	std	Y+2, r31	; 0x02
					Local_u8Flag = 1; /* A flag that indicates that i found the pressed switch */
					break;
				}
			}
			/* Deactivate current Row by adding High again */
			DIO_u8SetPinValue(KPD_u8_ROWS_PORT, Local_Au8RowsPinsArr[Local_u8RowsCounter], DIO_u8_HIGH);
    2eec:	82 e0       	ldi	r24, 0x02	; 2
    2eee:	6c 2d       	mov	r22, r12
    2ef0:	41 e0       	ldi	r20, 0x01	; 1
    2ef2:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
			if(Local_u8Flag == 1)
    2ef6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ef8:	81 30       	cpi	r24, 0x01	; 1
    2efa:	31 f0       	breq	.+12     	; 0x2f08 <KPD_u8GetSwitch+0xfa>
			{
				break;
    2efc:	0f 5f       	subi	r16, 0xFF	; 255
    2efe:	1f 4f       	sbci	r17, 0xFF	; 255
	/* Made them static so it doesn't get pushed every time I call the function */
	
	if(Copy_Pu8ReturnedSwitch != NULL)
	{
		*Copy_Pu8ReturnedSwitch = KPD_u8_NOT_PRESSED;
		for(u8 Local_u8RowsCounter = 0; Local_u8RowsCounter<KPD_u8_ROWS_NUMBER; Local_u8RowsCounter++)
    2f00:	04 30       	cpi	r16, 0x04	; 4
    2f02:	11 05       	cpc	r17, r1
    2f04:	09 f0       	breq	.+2      	; 0x2f08 <KPD_u8GetSwitch+0xfa>
    2f06:	9f cf       	rjmp	.-194    	; 0x2e46 <KPD_u8GetSwitch+0x38>
    2f08:	81 e0       	ldi	r24, 0x01	; 1
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	
	return Local_u8ErrorState;
    2f0a:	0f 90       	pop	r0
    2f0c:	0f 90       	pop	r0
    2f0e:	cf 91       	pop	r28
    2f10:	df 91       	pop	r29
    2f12:	1f 91       	pop	r17
    2f14:	0f 91       	pop	r16
    2f16:	ff 90       	pop	r15
    2f18:	ef 90       	pop	r14
    2f1a:	df 90       	pop	r13
    2f1c:	cf 90       	pop	r12
    2f1e:	bf 90       	pop	r11
    2f20:	af 90       	pop	r10
    2f22:	08 95       	ret

00002f24 <Private_voidWriteHalfPort>:
	LCD_voidSetCursor(Copy_u8LineNum, Copy_u8Position);
	LCD_voidWriteChar(Copy_u8PatternPosition);
}

static void Private_voidWriteHalfPort(u8 Copy_u8Value)
{
    2f24:	1f 93       	push	r17
    2f26:	18 2f       	mov	r17, r24
	u8 Local_u8BitValue;
	
	Local_u8BitValue = GET_BIT(Copy_u8Value,0);
	
	if(Local_u8BitValue == DIO_u8_HIGH) 
    2f28:	80 ff       	sbrs	r24, 0
    2f2a:	04 c0       	rjmp	.+8      	; 0x2f34 <Private_voidWriteHalfPort+0x10>
	{
		DIO_u8SetPinValue(LCD_u8_D4_PORT, LCD_u8_D4_PIN, DIO_u8_HIGH);
    2f2c:	80 e0       	ldi	r24, 0x00	; 0
    2f2e:	63 e0       	ldi	r22, 0x03	; 3
    2f30:	41 e0       	ldi	r20, 0x01	; 1
    2f32:	03 c0       	rjmp	.+6      	; 0x2f3a <Private_voidWriteHalfPort+0x16>
	}
	else 
	{
		DIO_u8SetPinValue(LCD_u8_D4_PORT, LCD_u8_D4_PIN, DIO_u8_LOW);
    2f34:	80 e0       	ldi	r24, 0x00	; 0
    2f36:	63 e0       	ldi	r22, 0x03	; 3
    2f38:	40 e0       	ldi	r20, 0x00	; 0
    2f3a:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	}
	
	Local_u8BitValue = GET_BIT(Copy_u8Value,1);
	
	if(Local_u8BitValue == DIO_u8_HIGH) 
    2f3e:	11 ff       	sbrs	r17, 1
    2f40:	04 c0       	rjmp	.+8      	; 0x2f4a <Private_voidWriteHalfPort+0x26>
	{
		DIO_u8SetPinValue(LCD_u8_D5_PORT, LCD_u8_D5_PIN, DIO_u8_HIGH);
    2f42:	80 e0       	ldi	r24, 0x00	; 0
    2f44:	64 e0       	ldi	r22, 0x04	; 4
    2f46:	41 e0       	ldi	r20, 0x01	; 1
    2f48:	03 c0       	rjmp	.+6      	; 0x2f50 <Private_voidWriteHalfPort+0x2c>
	}
	else 
	{
		DIO_u8SetPinValue(LCD_u8_D5_PORT, LCD_u8_D5_PIN, DIO_u8_LOW);
    2f4a:	80 e0       	ldi	r24, 0x00	; 0
    2f4c:	64 e0       	ldi	r22, 0x04	; 4
    2f4e:	40 e0       	ldi	r20, 0x00	; 0
    2f50:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	}
	
	Local_u8BitValue = GET_BIT(Copy_u8Value,2);
	
	if(Local_u8BitValue == DIO_u8_HIGH) 
    2f54:	12 ff       	sbrs	r17, 2
    2f56:	04 c0       	rjmp	.+8      	; 0x2f60 <Private_voidWriteHalfPort+0x3c>
	{
		DIO_u8SetPinValue(LCD_u8_D6_PORT, LCD_u8_D6_PIN, DIO_u8_HIGH);
    2f58:	80 e0       	ldi	r24, 0x00	; 0
    2f5a:	65 e0       	ldi	r22, 0x05	; 5
    2f5c:	41 e0       	ldi	r20, 0x01	; 1
    2f5e:	03 c0       	rjmp	.+6      	; 0x2f66 <Private_voidWriteHalfPort+0x42>
	}
	else 
	{
		DIO_u8SetPinValue(LCD_u8_D6_PORT, LCD_u8_D6_PIN, DIO_u8_LOW);
    2f60:	80 e0       	ldi	r24, 0x00	; 0
    2f62:	65 e0       	ldi	r22, 0x05	; 5
    2f64:	40 e0       	ldi	r20, 0x00	; 0
    2f66:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	}
	
	Local_u8BitValue = GET_BIT(Copy_u8Value,3);
	
	if(Local_u8BitValue == DIO_u8_HIGH) 
    2f6a:	13 ff       	sbrs	r17, 3
    2f6c:	04 c0       	rjmp	.+8      	; 0x2f76 <Private_voidWriteHalfPort+0x52>
	{
		DIO_u8SetPinValue(LCD_u8_D7_PORT, LCD_u8_D7_PIN, DIO_u8_HIGH);
    2f6e:	80 e0       	ldi	r24, 0x00	; 0
    2f70:	66 e0       	ldi	r22, 0x06	; 6
    2f72:	41 e0       	ldi	r20, 0x01	; 1
    2f74:	03 c0       	rjmp	.+6      	; 0x2f7c <Private_voidWriteHalfPort+0x58>
	}
	else 
	{
		DIO_u8SetPinValue(LCD_u8_D7_PORT, LCD_u8_D7_PIN, DIO_u8_LOW);
    2f76:	80 e0       	ldi	r24, 0x00	; 0
    2f78:	66 e0       	ldi	r22, 0x06	; 6
    2f7a:	40 e0       	ldi	r20, 0x00	; 0
    2f7c:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	}	
}
    2f80:	1f 91       	pop	r17
    2f82:	08 95       	ret

00002f84 <LCD_voidWriteChar>:
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_LOW);
#endif
}

void LCD_voidWriteChar(u8 Copy_u8Char)
{
    2f84:	ff 92       	push	r15
    2f86:	0f 93       	push	r16
    2f88:	1f 93       	push	r17
    2f8a:	f8 2e       	mov	r15, r24
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT, LCD_u8_En_PIN, DIO_u8_HIGH);
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT, LCD_u8_En_PIN, DIO_u8_LOW);

#elif LCD_u8_MODE == LCD_u8_4_BIT_MODE
	DIO_u8SetPinValue(LCD_u8_RS_PORT, LCD_u8_RS_PIN, DIO_u8_HIGH);
    2f8c:	80 e0       	ldi	r24, 0x00	; 0
    2f8e:	67 e0       	ldi	r22, 0x07	; 7
    2f90:	41 e0       	ldi	r20, 0x01	; 1
    2f92:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_RW_PORT, LCD_u8_RW_PIN, DIO_u8_LOW);
    2f96:	83 e0       	ldi	r24, 0x03	; 3
    2f98:	60 e0       	ldi	r22, 0x00	; 0
    2f9a:	40 e0       	ldi	r20, 0x00	; 0
    2f9c:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>

	/* Send to LCD the MOST 4 bits of command */	
	Private_voidWriteHalfPort(Copy_u8Char>>4); 
    2fa0:	8f 2d       	mov	r24, r15
    2fa2:	82 95       	swap	r24
    2fa4:	8f 70       	andi	r24, 0x0F	; 15
    2fa6:	0e 94 92 17 	call	0x2f24	; 0x2f24 <Private_voidWriteHalfPort>
	/* Enable Pulse *//* H => L */
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_HIGH);
    2faa:	80 e0       	ldi	r24, 0x00	; 0
    2fac:	62 e0       	ldi	r22, 0x02	; 2
    2fae:	41 e0       	ldi	r20, 0x01	; 1
    2fb0:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2fb4:	00 ed       	ldi	r16, 0xD0	; 208
    2fb6:	17 e0       	ldi	r17, 0x07	; 7
    2fb8:	c8 01       	movw	r24, r16
    2fba:	01 97       	sbiw	r24, 0x01	; 1
    2fbc:	f1 f7       	brne	.-4      	; 0x2fba <LCD_voidWriteChar+0x36>
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_LOW);
    2fbe:	80 e0       	ldi	r24, 0x00	; 0
    2fc0:	62 e0       	ldi	r22, 0x02	; 2
    2fc2:	40 e0       	ldi	r20, 0x00	; 0
    2fc4:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	
	/* Send to LCD the LEAST 4 bits of command */
	Private_voidWriteHalfPort(Copy_u8Char); 
    2fc8:	8f 2d       	mov	r24, r15
    2fca:	0e 94 92 17 	call	0x2f24	; 0x2f24 <Private_voidWriteHalfPort>
	/* Enable Pulse *//* H => L */
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_HIGH);
    2fce:	80 e0       	ldi	r24, 0x00	; 0
    2fd0:	62 e0       	ldi	r22, 0x02	; 2
    2fd2:	41 e0       	ldi	r20, 0x01	; 1
    2fd4:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    2fd8:	c8 01       	movw	r24, r16
    2fda:	01 97       	sbiw	r24, 0x01	; 1
    2fdc:	f1 f7       	brne	.-4      	; 0x2fda <LCD_voidWriteChar+0x56>
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_LOW);
    2fde:	80 e0       	ldi	r24, 0x00	; 0
    2fe0:	62 e0       	ldi	r22, 0x02	; 2
    2fe2:	40 e0       	ldi	r20, 0x00	; 0
    2fe4:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
#endif
}
    2fe8:	1f 91       	pop	r17
    2fea:	0f 91       	pop	r16
    2fec:	ff 90       	pop	r15
    2fee:	08 95       	ret

00002ff0 <LCD_voidWriteNumber>:
		LCD_voidWriteChar(Copy_Pu8Str[i]);
	}
}

void LCD_voidWriteNumber(u32  Copy_u8Number)
{
    2ff0:	af 92       	push	r10
    2ff2:	bf 92       	push	r11
    2ff4:	cf 92       	push	r12
    2ff6:	df 92       	push	r13
    2ff8:	ef 92       	push	r14
    2ffa:	ff 92       	push	r15
    2ffc:	0f 93       	push	r16
    2ffe:	df 93       	push	r29
    3000:	cf 93       	push	r28
    3002:	cd b7       	in	r28, 0x3d	; 61
    3004:	de b7       	in	r29, 0x3e	; 62
    3006:	66 97       	sbiw	r28, 0x16	; 22
    3008:	0f b6       	in	r0, 0x3f	; 63
    300a:	f8 94       	cli
    300c:	de bf       	out	0x3e, r29	; 62
    300e:	0f be       	out	0x3f, r0	; 63
    3010:	cd bf       	out	0x3d, r28	; 61
    3012:	6b 01       	movw	r12, r22
    3014:	7c 01       	movw	r14, r24
	u8 Local_u8ADigits[20];
	u8 Local_u8Char;
	u8 Local_u8DigitIndex = 0;
	
	if(Copy_u8Number == 0) LCD_voidWriteChar('0');
    3016:	61 15       	cp	r22, r1
    3018:	71 05       	cpc	r23, r1
    301a:	81 05       	cpc	r24, r1
    301c:	91 05       	cpc	r25, r1
    301e:	21 f4       	brne	.+8      	; 0x3028 <LCD_voidWriteNumber+0x38>
    3020:	80 e3       	ldi	r24, 0x30	; 48
    3022:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
    3026:	3c c0       	rjmp	.+120    	; 0x30a0 <LCD_voidWriteNumber+0xb0>
    3028:	00 e0       	ldi	r16, 0x00	; 0
	else
	{
		for(;Copy_u8Number>0; Local_u8DigitIndex++)
		{
			Local_u8ADigits[Local_u8DigitIndex] = Copy_u8Number%10;
    302a:	5e 01       	movw	r10, r28
    302c:	08 94       	sec
    302e:	a1 1c       	adc	r10, r1
    3030:	b1 1c       	adc	r11, r1
    3032:	c5 01       	movw	r24, r10
    3034:	80 0f       	add	r24, r16
    3036:	91 1d       	adc	r25, r1
    3038:	9e 8b       	std	Y+22, r25	; 0x16
    303a:	8d 8b       	std	Y+21, r24	; 0x15
    303c:	c7 01       	movw	r24, r14
    303e:	b6 01       	movw	r22, r12
    3040:	2a e0       	ldi	r18, 0x0A	; 10
    3042:	30 e0       	ldi	r19, 0x00	; 0
    3044:	40 e0       	ldi	r20, 0x00	; 0
    3046:	50 e0       	ldi	r21, 0x00	; 0
    3048:	0e 94 a3 1d 	call	0x3b46	; 0x3b46 <__udivmodsi4>
    304c:	ed 89       	ldd	r30, Y+21	; 0x15
    304e:	fe 89       	ldd	r31, Y+22	; 0x16
    3050:	60 83       	st	Z, r22
			Copy_u8Number = Copy_u8Number/10;
    3052:	c7 01       	movw	r24, r14
    3054:	b6 01       	movw	r22, r12
    3056:	2a e0       	ldi	r18, 0x0A	; 10
    3058:	30 e0       	ldi	r19, 0x00	; 0
    305a:	40 e0       	ldi	r20, 0x00	; 0
    305c:	50 e0       	ldi	r21, 0x00	; 0
    305e:	0e 94 a3 1d 	call	0x3b46	; 0x3b46 <__udivmodsi4>
    3062:	c9 01       	movw	r24, r18
    3064:	da 01       	movw	r26, r20
    3066:	6c 01       	movw	r12, r24
    3068:	7d 01       	movw	r14, r26
	u8 Local_u8DigitIndex = 0;
	
	if(Copy_u8Number == 0) LCD_voidWriteChar('0');
	else
	{
		for(;Copy_u8Number>0; Local_u8DigitIndex++)
    306a:	0f 5f       	subi	r16, 0xFF	; 255
    306c:	c1 14       	cp	r12, r1
    306e:	d1 04       	cpc	r13, r1
    3070:	e1 04       	cpc	r14, r1
    3072:	f1 04       	cpc	r15, r1
    3074:	f1 f6       	brne	.-68     	; 0x3032 <LCD_voidWriteNumber+0x42>
		{
			Local_u8ADigits[Local_u8DigitIndex] = Copy_u8Number%10;
			Copy_u8Number = Copy_u8Number/10;
		}
		Local_u8DigitIndex--;
		for(unsigned int i=Local_u8DigitIndex; i>=0; i--)
    3076:	01 50       	subi	r16, 0x01	; 1
    3078:	e0 2e       	mov	r14, r16
    307a:	ff 24       	eor	r15, r15
    307c:	65 01       	movw	r12, r10
    307e:	ce 0c       	add	r12, r14
    3080:	df 1c       	adc	r13, r15
		{
			Local_u8Char = Local_u8ADigits[i]+48;
			LCD_voidWriteChar(Local_u8Char);
    3082:	f6 01       	movw	r30, r12
    3084:	80 81       	ld	r24, Z
    3086:	80 5d       	subi	r24, 0xD0	; 208
    3088:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
    308c:	08 94       	sec
    308e:	c1 08       	sbc	r12, r1
    3090:	d1 08       	sbc	r13, r1
			if(i==0) break;
    3092:	e1 14       	cp	r14, r1
    3094:	f1 04       	cpc	r15, r1
    3096:	21 f0       	breq	.+8      	; 0x30a0 <LCD_voidWriteNumber+0xb0>
		{
			Local_u8ADigits[Local_u8DigitIndex] = Copy_u8Number%10;
			Copy_u8Number = Copy_u8Number/10;
		}
		Local_u8DigitIndex--;
		for(unsigned int i=Local_u8DigitIndex; i>=0; i--)
    3098:	08 94       	sec
    309a:	e1 08       	sbc	r14, r1
    309c:	f1 08       	sbc	r15, r1
    309e:	f1 cf       	rjmp	.-30     	; 0x3082 <LCD_voidWriteNumber+0x92>
			Local_u8Char = Local_u8ADigits[i]+48;
			LCD_voidWriteChar(Local_u8Char);
			if(i==0) break;
		}
	}
}
    30a0:	66 96       	adiw	r28, 0x16	; 22
    30a2:	0f b6       	in	r0, 0x3f	; 63
    30a4:	f8 94       	cli
    30a6:	de bf       	out	0x3e, r29	; 62
    30a8:	0f be       	out	0x3f, r0	; 63
    30aa:	cd bf       	out	0x3d, r28	; 61
    30ac:	cf 91       	pop	r28
    30ae:	df 91       	pop	r29
    30b0:	0f 91       	pop	r16
    30b2:	ff 90       	pop	r15
    30b4:	ef 90       	pop	r14
    30b6:	df 90       	pop	r13
    30b8:	cf 90       	pop	r12
    30ba:	bf 90       	pop	r11
    30bc:	af 90       	pop	r10
    30be:	08 95       	ret

000030c0 <LCD_voidWriteStr>:
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_LOW);
#endif
}

void LCD_voidWriteStr (const u8* Copy_Pu8Str)
{
    30c0:	cf 93       	push	r28
    30c2:	df 93       	push	r29
    30c4:	ec 01       	movw	r28, r24
    30c6:	02 c0       	rjmp	.+4      	; 0x30cc <LCD_voidWriteStr+0xc>
	for(int i = 0; Copy_Pu8Str[i] != '\0'; i++)
	{
		LCD_voidWriteChar(Copy_Pu8Str[i]);
    30c8:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
#endif
}

void LCD_voidWriteStr (const u8* Copy_Pu8Str)
{
	for(int i = 0; Copy_Pu8Str[i] != '\0'; i++)
    30cc:	89 91       	ld	r24, Y+
    30ce:	88 23       	and	r24, r24
    30d0:	d9 f7       	brne	.-10     	; 0x30c8 <LCD_voidWriteStr+0x8>
	{
		LCD_voidWriteChar(Copy_Pu8Str[i]);
	}
}
    30d2:	df 91       	pop	r29
    30d4:	cf 91       	pop	r28
    30d6:	08 95       	ret

000030d8 <LCD_voidSendCmd>:
	/* Entry Mode Set Cmd */
	LCD_voidSendCmd(0b00000110);	
}

void LCD_voidSendCmd (u8 Copy_u8Cmd)
{
    30d8:	ff 92       	push	r15
    30da:	0f 93       	push	r16
    30dc:	1f 93       	push	r17
    30de:	f8 2e       	mov	r15, r24
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT, LCD_u8_En_PIN, DIO_u8_HIGH);
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT, LCD_u8_En_PIN, DIO_u8_LOW);

#elif LCD_u8_MODE == LCD_u8_4_BIT_MODE
	DIO_u8SetPinValue(LCD_u8_RS_PORT, LCD_u8_RS_PIN, DIO_u8_LOW);
    30e0:	80 e0       	ldi	r24, 0x00	; 0
    30e2:	67 e0       	ldi	r22, 0x07	; 7
    30e4:	40 e0       	ldi	r20, 0x00	; 0
    30e6:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_RW_PORT, LCD_u8_RW_PIN, DIO_u8_LOW);
    30ea:	83 e0       	ldi	r24, 0x03	; 3
    30ec:	60 e0       	ldi	r22, 0x00	; 0
    30ee:	40 e0       	ldi	r20, 0x00	; 0
    30f0:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>

	/* Send to LCD the MOST 4 bits of command */	
	Private_voidWriteHalfPort(Copy_u8Cmd>>4); 
    30f4:	8f 2d       	mov	r24, r15
    30f6:	82 95       	swap	r24
    30f8:	8f 70       	andi	r24, 0x0F	; 15
    30fa:	0e 94 92 17 	call	0x2f24	; 0x2f24 <Private_voidWriteHalfPort>
	/* Enable Pulse *//* H => L */
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_HIGH);
    30fe:	80 e0       	ldi	r24, 0x00	; 0
    3100:	62 e0       	ldi	r22, 0x02	; 2
    3102:	41 e0       	ldi	r20, 0x01	; 1
    3104:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    3108:	00 ed       	ldi	r16, 0xD0	; 208
    310a:	17 e0       	ldi	r17, 0x07	; 7
    310c:	c8 01       	movw	r24, r16
    310e:	01 97       	sbiw	r24, 0x01	; 1
    3110:	f1 f7       	brne	.-4      	; 0x310e <LCD_voidSendCmd+0x36>
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_LOW);
    3112:	80 e0       	ldi	r24, 0x00	; 0
    3114:	62 e0       	ldi	r22, 0x02	; 2
    3116:	40 e0       	ldi	r20, 0x00	; 0
    3118:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	
	/* Send to LCD the LEAST 4 bits of command */
	Private_voidWriteHalfPort(Copy_u8Cmd); 
    311c:	8f 2d       	mov	r24, r15
    311e:	0e 94 92 17 	call	0x2f24	; 0x2f24 <Private_voidWriteHalfPort>
	/* Enable Pulse *//* H => L */
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_HIGH);
    3122:	80 e0       	ldi	r24, 0x00	; 0
    3124:	62 e0       	ldi	r22, 0x02	; 2
    3126:	41 e0       	ldi	r20, 0x01	; 1
    3128:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    312c:	c8 01       	movw	r24, r16
    312e:	01 97       	sbiw	r24, 0x01	; 1
    3130:	f1 f7       	brne	.-4      	; 0x312e <LCD_voidSendCmd+0x56>
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_LOW);
    3132:	80 e0       	ldi	r24, 0x00	; 0
    3134:	62 e0       	ldi	r22, 0x02	; 2
    3136:	40 e0       	ldi	r20, 0x00	; 0
    3138:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
#endif
}
    313c:	1f 91       	pop	r17
    313e:	0f 91       	pop	r16
    3140:	ff 90       	pop	r15
    3142:	08 95       	ret

00003144 <LCD_voidClear>:
	}	
}

void LCD_voidClear()
{
	LCD_voidSendCmd(0b0000001);
    3144:	81 e0       	ldi	r24, 0x01	; 1
    3146:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <LCD_voidSendCmd>
    314a:	08 95       	ret

0000314c <LCD_voidSetCursor>:
	}
}

void LCD_voidSetCursor	(u8 Copy_u8LineNum, u8 Copy_u8Position)
{
	switch(Copy_u8LineNum)
    314c:	81 30       	cpi	r24, 0x01	; 1
    314e:	19 f0       	breq	.+6      	; 0x3156 <LCD_voidSetCursor+0xa>
    3150:	82 30       	cpi	r24, 0x02	; 2
    3152:	51 f4       	brne	.+20     	; 0x3168 <LCD_voidSetCursor+0x1c>
    3154:	05 c0       	rjmp	.+10     	; 0x3160 <LCD_voidSetCursor+0x14>
	{
		case LCD_u8_LINE_ONE:
			LCD_voidSendCmd(0x80+Copy_u8Position); /* 0x80 is the start of the first line */
    3156:	86 2f       	mov	r24, r22
    3158:	80 58       	subi	r24, 0x80	; 128
    315a:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <LCD_voidSendCmd>
    315e:	08 95       	ret
		break;
		
		case LCD_u8_LINE_TWO:
			LCD_voidSendCmd(0xC0+Copy_u8Position);	/* 0xC0 is the start of the second line */
    3160:	86 2f       	mov	r24, r22
    3162:	80 54       	subi	r24, 0x40	; 64
    3164:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <LCD_voidSendCmd>
    3168:	08 95       	ret

0000316a <LCD_voidWriteSpecialCharacter>:
		break;
	}
}

void LCD_voidWriteSpecialCharacter(u8* Copy_Pu8Pattern, u8 Copy_u8PatternPosition, u8 Copy_u8LineNum, u8 Copy_u8Position)
{
    316a:	df 92       	push	r13
    316c:	ef 92       	push	r14
    316e:	ff 92       	push	r15
    3170:	0f 93       	push	r16
    3172:	1f 93       	push	r17
    3174:	8c 01       	movw	r16, r24
    3176:	f6 2e       	mov	r15, r22
    3178:	e4 2e       	mov	r14, r20
    317a:	d2 2e       	mov	r13, r18
	/* Move AC to start of CGRAM */
	LCD_voidSendCmd(0b01000000 + Copy_u8PatternPosition*8);
    317c:	86 2f       	mov	r24, r22
    317e:	88 0f       	add	r24, r24
    3180:	88 0f       	add	r24, r24
    3182:	88 0f       	add	r24, r24
    3184:	80 5c       	subi	r24, 0xC0	; 192
    3186:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <LCD_voidSendCmd>
	/* Draw the character in the CGRAM */
	LCD_voidWriteChar(Copy_Pu8Pattern[0]);
    318a:	f8 01       	movw	r30, r16
    318c:	80 81       	ld	r24, Z
    318e:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
	LCD_voidWriteChar(Copy_Pu8Pattern[1]);
    3192:	f8 01       	movw	r30, r16
    3194:	81 81       	ldd	r24, Z+1	; 0x01
    3196:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
	LCD_voidWriteChar(Copy_Pu8Pattern[2]);
    319a:	f8 01       	movw	r30, r16
    319c:	82 81       	ldd	r24, Z+2	; 0x02
    319e:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
	LCD_voidWriteChar(Copy_Pu8Pattern[3]);
    31a2:	f8 01       	movw	r30, r16
    31a4:	83 81       	ldd	r24, Z+3	; 0x03
    31a6:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
	LCD_voidWriteChar(Copy_Pu8Pattern[4]);
    31aa:	f8 01       	movw	r30, r16
    31ac:	84 81       	ldd	r24, Z+4	; 0x04
    31ae:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
	LCD_voidWriteChar(Copy_Pu8Pattern[5]);
    31b2:	f8 01       	movw	r30, r16
    31b4:	85 81       	ldd	r24, Z+5	; 0x05
    31b6:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
	LCD_voidWriteChar(Copy_Pu8Pattern[6]);
    31ba:	f8 01       	movw	r30, r16
    31bc:	86 81       	ldd	r24, Z+6	; 0x06
    31be:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
	LCD_voidWriteChar(Copy_Pu8Pattern[7]);
    31c2:	f8 01       	movw	r30, r16
    31c4:	87 81       	ldd	r24, Z+7	; 0x07
    31c6:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
	
	/* Go back to DDRAM to Display the character */
	LCD_voidSetCursor(Copy_u8LineNum, Copy_u8Position);
    31ca:	8e 2d       	mov	r24, r14
    31cc:	6d 2d       	mov	r22, r13
    31ce:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
	LCD_voidWriteChar(Copy_u8PatternPosition);
    31d2:	8f 2d       	mov	r24, r15
    31d4:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
}
    31d8:	1f 91       	pop	r17
    31da:	0f 91       	pop	r16
    31dc:	ff 90       	pop	r15
    31de:	ef 90       	pop	r14
    31e0:	df 90       	pop	r13
    31e2:	08 95       	ret

000031e4 <LCD_voidInit>:
	/* Function Set Cmd */
	LCD_voidSendCmd(0b00111000); 
	_delay_us(45);
	
#elif LCD_u8_MODE == LCD_u8_4_BIT_MODE
	DIO_u8SetPinValue(LCD_u8_RS_PORT, LCD_u8_RS_PIN, DIO_u8_LOW);
    31e4:	80 e0       	ldi	r24, 0x00	; 0
    31e6:	67 e0       	ldi	r22, 0x07	; 7
    31e8:	40 e0       	ldi	r20, 0x00	; 0
    31ea:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(LCD_u8_RW_PORT, LCD_u8_RW_PIN, DIO_u8_LOW);
    31ee:	83 e0       	ldi	r24, 0x03	; 3
    31f0:	60 e0       	ldi	r22, 0x00	; 0
    31f2:	40 e0       	ldi	r20, 0x00	; 0
    31f4:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	
	Private_voidWriteHalfPort(0b0010);
    31f8:	82 e0       	ldi	r24, 0x02	; 2
    31fa:	0e 94 92 17 	call	0x2f24	; 0x2f24 <Private_voidWriteHalfPort>
	/* Enable Pulse *//* H => L */
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_HIGH);
    31fe:	80 e0       	ldi	r24, 0x00	; 0
    3200:	62 e0       	ldi	r22, 0x02	; 2
    3202:	41 e0       	ldi	r20, 0x01	; 1
    3204:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    3208:	80 ed       	ldi	r24, 0xD0	; 208
    320a:	97 e0       	ldi	r25, 0x07	; 7
    320c:	01 97       	sbiw	r24, 0x01	; 1
    320e:	f1 f7       	brne	.-4      	; 0x320c <LCD_voidInit+0x28>
	_delay_ms(1);
	DIO_u8SetPinValue(LCD_u8_En_PORT, LCD_u8_En_PIN, DIO_u8_LOW);
    3210:	80 e0       	ldi	r24, 0x00	; 0
    3212:	62 e0       	ldi	r22, 0x02	; 2
    3214:	40 e0       	ldi	r20, 0x00	; 0
    3216:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	
	LCD_voidSendCmd(0b00101000);
    321a:	88 e2       	ldi	r24, 0x28	; 40
    321c:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <LCD_voidSendCmd>
#endif	
/**** The next commands are same for both modes initialiazation ****/

	/* Diplay On/Off Control Cmd */
	LCD_voidSendCmd(0b00001110); /* Display = On / Cursor = On / Cursor_Blink = On*/
    3220:	8e e0       	ldi	r24, 0x0E	; 14
    3222:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <LCD_voidSendCmd>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3226:	88 e7       	ldi	r24, 0x78	; 120
    3228:	8a 95       	dec	r24
    322a:	f1 f7       	brne	.-4      	; 0x3228 <LCD_voidInit+0x44>
	_delay_us(45);
	
	/* Display Clear Cmd*/
	LCD_voidSendCmd(0b00000001);
    322c:	81 e0       	ldi	r24, 0x01	; 1
    322e:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <LCD_voidSendCmd>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3232:	80 ea       	ldi	r24, 0xA0	; 160
    3234:	9f e0       	ldi	r25, 0x0F	; 15
    3236:	01 97       	sbiw	r24, 0x01	; 1
    3238:	f1 f7       	brne	.-4      	; 0x3236 <LCD_voidInit+0x52>
	_delay_ms(2);
	
	/* Entry Mode Set Cmd */
	LCD_voidSendCmd(0b00000110);	
    323a:	86 e0       	ldi	r24, 0x06	; 6
    323c:	0e 94 6c 18 	call	0x30d8	; 0x30d8 <LCD_voidSendCmd>
}
    3240:	08 95       	ret

00003242 <LED_u8Toggle>:
	}
	return Local_u8ErrorState;
}

u8 LED_u8Toggle	(LED_t* Copy_u8LED)
{
    3242:	fc 01       	movw	r30, r24
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8LED->LED_u8PORTID <= DIO_u8_PORTD) && (Copy_u8LED->LED_u8PINID <= DIO_u8_PIN7))
    3244:	80 81       	ld	r24, Z
    3246:	84 30       	cpi	r24, 0x04	; 4
    3248:	38 f4       	brcc	.+14     	; 0x3258 <LED_u8Toggle+0x16>
    324a:	61 81       	ldd	r22, Z+1	; 0x01
    324c:	68 30       	cpi	r22, 0x08	; 8
    324e:	20 f4       	brcc	.+8      	; 0x3258 <LED_u8Toggle+0x16>
	{
		DIO_u8TogglePinValue(Copy_u8LED->LED_u8PORTID, Copy_u8LED->LED_u8PINID);
    3250:	0e 94 6d 16 	call	0x2cda	; 0x2cda <DIO_u8TogglePinValue>
    3254:	81 e0       	ldi	r24, 0x01	; 1
    3256:	08 95       	ret

u8 LED_u8Toggle	(LED_t* Copy_u8LED)
{
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8LED->LED_u8PORTID <= DIO_u8_PORTD) && (Copy_u8LED->LED_u8PINID <= DIO_u8_PIN7))
    3258:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    325a:	08 95       	ret

0000325c <LED_u8TurnOff>:
	}
	return Local_u8ErrorState;
}

u8 LED_u8TurnOff(LED_t* Copy_u8LED)
{
    325c:	fc 01       	movw	r30, r24
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8LED->LED_u8PORTID <= DIO_u8_PORTD) && (Copy_u8LED->LED_u8PINID <= DIO_u8_PIN7)
    325e:	80 81       	ld	r24, Z
    3260:	84 30       	cpi	r24, 0x04	; 4
    3262:	88 f4       	brcc	.+34     	; 0x3286 <LED_u8TurnOff+0x2a>
    3264:	61 81       	ldd	r22, Z+1	; 0x01
    3266:	68 30       	cpi	r22, 0x08	; 8
    3268:	70 f4       	brcc	.+28     	; 0x3286 <LED_u8TurnOff+0x2a>
    326a:	92 81       	ldd	r25, Z+2	; 0x02
    326c:	92 30       	cpi	r25, 0x02	; 2
    326e:	58 f4       	brcc	.+22     	; 0x3286 <LED_u8TurnOff+0x2a>
    3270:	ef 2b       	or	r30, r31
    3272:	49 f0       	breq	.+18     	; 0x3286 <LED_u8TurnOff+0x2a>
		&& ((Copy_u8LED->LED_u8ConnectionType == LED_u8_ACTIVE_HIGH) || (Copy_u8LED->LED_u8ConnectionType == LED_u8_ACTIVE_LOW)) && Copy_u8LED != NULL)
	{
		if(Copy_u8LED->LED_u8ConnectionType == LED_u8_ACTIVE_HIGH)
    3274:	91 30       	cpi	r25, 0x01	; 1
    3276:	11 f4       	brne	.+4      	; 0x327c <LED_u8TurnOff+0x20>
		{
			DIO_u8SetPinValue(Copy_u8LED->LED_u8PORTID, Copy_u8LED->LED_u8PINID, DIO_u8_LOW);
    3278:	40 e0       	ldi	r20, 0x00	; 0
    327a:	01 c0       	rjmp	.+2      	; 0x327e <LED_u8TurnOff+0x22>
		}
		else
		{
			DIO_u8SetPinValue(Copy_u8LED->LED_u8PORTID, Copy_u8LED->LED_u8PINID, DIO_u8_HIGH);
    327c:	41 e0       	ldi	r20, 0x01	; 1
    327e:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    3282:	81 e0       	ldi	r24, 0x01	; 1
    3284:	08 95       	ret
    3286:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    3288:	08 95       	ret

0000328a <LED_u8TurnOn>:
#include "LED_Private.h"
#include "LED_Config.h"


u8 LED_u8TurnOn	(LED_t* Copy_u8LED)
{
    328a:	fc 01       	movw	r30, r24
	u8 Local_u8ErrorState = STD_TYPES_OK;
	
	if((Copy_u8LED->LED_u8PORTID <= DIO_u8_PORTD) && (Copy_u8LED->LED_u8PINID <= DIO_u8_PIN7)
    328c:	80 81       	ld	r24, Z
    328e:	84 30       	cpi	r24, 0x04	; 4
    3290:	88 f4       	brcc	.+34     	; 0x32b4 <LED_u8TurnOn+0x2a>
    3292:	61 81       	ldd	r22, Z+1	; 0x01
    3294:	68 30       	cpi	r22, 0x08	; 8
    3296:	70 f4       	brcc	.+28     	; 0x32b4 <LED_u8TurnOn+0x2a>
    3298:	92 81       	ldd	r25, Z+2	; 0x02
    329a:	92 30       	cpi	r25, 0x02	; 2
    329c:	58 f4       	brcc	.+22     	; 0x32b4 <LED_u8TurnOn+0x2a>
    329e:	ef 2b       	or	r30, r31
    32a0:	49 f0       	breq	.+18     	; 0x32b4 <LED_u8TurnOn+0x2a>
		&& ((Copy_u8LED->LED_u8ConnectionType == LED_u8_ACTIVE_HIGH) || (Copy_u8LED->LED_u8ConnectionType == LED_u8_ACTIVE_LOW)) && Copy_u8LED != NULL)
	{
		if(Copy_u8LED->LED_u8ConnectionType == LED_u8_ACTIVE_HIGH)
    32a2:	91 30       	cpi	r25, 0x01	; 1
    32a4:	11 f4       	brne	.+4      	; 0x32aa <LED_u8TurnOn+0x20>
		{
			DIO_u8SetPinValue(Copy_u8LED->LED_u8PORTID, Copy_u8LED->LED_u8PINID, DIO_u8_HIGH);
    32a6:	41 e0       	ldi	r20, 0x01	; 1
    32a8:	01 c0       	rjmp	.+2      	; 0x32ac <LED_u8TurnOn+0x22>
		}
		else
		{
			DIO_u8SetPinValue(Copy_u8LED->LED_u8PORTID, Copy_u8LED->LED_u8PINID, DIO_u8_LOW);
    32aa:	40 e0       	ldi	r20, 0x00	; 0
    32ac:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	08 95       	ret
    32b4:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
	}
	return Local_u8ErrorState;
}
    32b6:	08 95       	ret

000032b8 <Motors_voidDCMotorOFF>:
	}
}

void Motors_voidDCMotorOFF		(void)
{
	DIO_u8SetPinValue(MOTORS_u8_DC_CCW_PORT, MOTORS_u8_DC_CCW_PIN, DIO_u8_LOW);
    32b8:	82 e0       	ldi	r24, 0x02	; 2
    32ba:	62 e0       	ldi	r22, 0x02	; 2
    32bc:	40 e0       	ldi	r20, 0x00	; 0
    32be:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(MOTORS_u8_DC_CW_PORT, MOTORS_u8_DC_CW_PIN, DIO_u8_LOW);
    32c2:	82 e0       	ldi	r24, 0x02	; 2
    32c4:	61 e0       	ldi	r22, 0x01	; 1
    32c6:	40 e0       	ldi	r20, 0x00	; 0
    32c8:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    32cc:	08 95       	ret

000032ce <Motors_voidDCMotorON>:
	DIO_u8SetPinValue(MOTORS_u8_ORANGE_PORT, MOTORS_u8_ORANGE_PIN, DIO_u8_HIGH);
}

void Motors_voidDCMotorON (u8 Copy_u8Direction)
{
	if(Copy_u8Direction == MOTORS_u8_DC_CW)
    32ce:	81 30       	cpi	r24, 0x01	; 1
    32d0:	59 f4       	brne	.+22     	; 0x32e8 <Motors_voidDCMotorON+0x1a>
	{
		DIO_u8SetPinValue(MOTORS_u8_DC_CCW_PORT, MOTORS_u8_DC_CCW_PIN, DIO_u8_LOW);
    32d2:	82 e0       	ldi	r24, 0x02	; 2
    32d4:	62 e0       	ldi	r22, 0x02	; 2
    32d6:	40 e0       	ldi	r20, 0x00	; 0
    32d8:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_DC_CW_PORT, MOTORS_u8_DC_CW_PIN, DIO_u8_HIGH); 
    32dc:	82 e0       	ldi	r24, 0x02	; 2
    32de:	61 e0       	ldi	r22, 0x01	; 1
    32e0:	41 e0       	ldi	r20, 0x01	; 1
    32e2:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    32e6:	08 95       	ret
	}
	else if(Copy_u8Direction == MOTORS_u8_DC_CCW)
    32e8:	88 23       	and	r24, r24
    32ea:	51 f4       	brne	.+20     	; 0x3300 <Motors_voidDCMotorON+0x32>
	{
		DIO_u8SetPinValue(MOTORS_u8_DC_CW_PORT, MOTORS_u8_DC_CW_PIN, DIO_u8_LOW);
    32ec:	82 e0       	ldi	r24, 0x02	; 2
    32ee:	61 e0       	ldi	r22, 0x01	; 1
    32f0:	40 e0       	ldi	r20, 0x00	; 0
    32f2:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_DC_CCW_PORT, MOTORS_u8_DC_CCW_PIN, DIO_u8_HIGH);
    32f6:	82 e0       	ldi	r24, 0x02	; 2
    32f8:	62 e0       	ldi	r22, 0x02	; 2
    32fa:	41 e0       	ldi	r20, 0x01	; 1
    32fc:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    3300:	08 95       	ret

00003302 <Motors_voidStepperMotorOFF>:
	}
}

void Motors_voidStepperMotorOFF(void)
{
	DIO_u8SetPinValue(MOTORS_u8_COMMON_PORT, MOTORS_u8_COMMON_PIN, DIO_u8_LOW);
    3302:	80 e0       	ldi	r24, 0x00	; 0
    3304:	60 e0       	ldi	r22, 0x00	; 0
    3306:	40 e0       	ldi	r20, 0x00	; 0
    3308:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	
	DIO_u8SetPinValue(MOTORS_u8_BLUE_PORT, MOTORS_u8_BLUE_PIN, DIO_u8_HIGH);
    330c:	80 e0       	ldi	r24, 0x00	; 0
    330e:	61 e0       	ldi	r22, 0x01	; 1
    3310:	41 e0       	ldi	r20, 0x01	; 1
    3312:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(MOTORS_u8_PINK_PORT, MOTORS_u8_PINK_PIN, DIO_u8_HIGH);
    3316:	80 e0       	ldi	r24, 0x00	; 0
    3318:	62 e0       	ldi	r22, 0x02	; 2
    331a:	41 e0       	ldi	r20, 0x01	; 1
    331c:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(MOTORS_u8_YELLOW_PORT, MOTORS_u8_YELLOW_PIN, DIO_u8_HIGH);
    3320:	80 e0       	ldi	r24, 0x00	; 0
    3322:	63 e0       	ldi	r22, 0x03	; 3
    3324:	41 e0       	ldi	r20, 0x01	; 1
    3326:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	DIO_u8SetPinValue(MOTORS_u8_ORANGE_PORT, MOTORS_u8_ORANGE_PIN, DIO_u8_HIGH);
    332a:	80 e0       	ldi	r24, 0x00	; 0
    332c:	64 e0       	ldi	r22, 0x04	; 4
    332e:	41 e0       	ldi	r20, 0x01	; 1
    3330:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
}
    3334:	08 95       	ret

00003336 <Motors_voidStepperMotorON>:
#include "MOTORS_Interface.h"
#include "MOTORS_Private.h"
#include "MOTORS_Config.h"

void Motors_voidStepperMotorON(u8 Copy_u8Angle)
{
    3336:	ef 92       	push	r14
    3338:	ff 92       	push	r15
    333a:	0f 93       	push	r16
    333c:	1f 93       	push	r17
    333e:	cf 93       	push	r28
    3340:	df 93       	push	r29
    3342:	e8 2e       	mov	r14, r24
	float Local_floatFullStep = 2*Local_floatHalfStep;
	u8	  Local_u8StepsNumber = Copy_u8Angle/Local_floatFullStep;
	u8	  Local_u8Iterator    = 0;
	
	/* Set Common Pin with High (From datasheet) */
	DIO_u8SetPinValue(MOTORS_u8_COMMON_PORT, MOTORS_u8_COMMON_PIN, DIO_u8_HIGH);
    3344:	80 e0       	ldi	r24, 0x00	; 0
    3346:	60 e0       	ldi	r22, 0x00	; 0
    3348:	41 e0       	ldi	r20, 0x01	; 1
    334a:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
	
	for(Local_u8Iterator = 0; Local_u8Iterator<Local_u8StepsNumber/4; Local_u8Iterator++)
    334e:	ff 24       	eor	r15, r15
    3350:	00 27       	eor	r16, r16
    3352:	f7 fc       	sbrc	r15, 7
    3354:	00 95       	com	r16
    3356:	10 2f       	mov	r17, r16
    3358:	c8 01       	movw	r24, r16
    335a:	b7 01       	movw	r22, r14
    335c:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <__floatsisf>
    3360:	20 e0       	ldi	r18, 0x00	; 0
    3362:	30 e0       	ldi	r19, 0x00	; 0
    3364:	44 e3       	ldi	r20, 0x34	; 52
    3366:	5e e3       	ldi	r21, 0x3E	; 62
    3368:	0e 94 1f 02 	call	0x43e	; 0x43e <__divsf3>
    336c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3370:	e6 2e       	mov	r14, r22
    3372:	e6 94       	lsr	r14
    3374:	e6 94       	lsr	r14
    3376:	10 e0       	ldi	r17, 0x00	; 0
    3378:	c0 e2       	ldi	r28, 0x20	; 32
    337a:	de e4       	ldi	r29, 0x4E	; 78
    337c:	5d c0       	rjmp	.+186    	; 0x3438 <Motors_voidStepperMotorON+0x102>
	{
		
		DIO_u8SetPinValue(MOTORS_u8_BLUE_PORT, MOTORS_u8_BLUE_PIN, DIO_u8_LOW);
    337e:	80 e0       	ldi	r24, 0x00	; 0
    3380:	61 e0       	ldi	r22, 0x01	; 1
    3382:	40 e0       	ldi	r20, 0x00	; 0
    3384:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_PINK_PORT, MOTORS_u8_PINK_PIN, DIO_u8_HIGH);
    3388:	80 e0       	ldi	r24, 0x00	; 0
    338a:	62 e0       	ldi	r22, 0x02	; 2
    338c:	41 e0       	ldi	r20, 0x01	; 1
    338e:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_YELLOW_PORT, MOTORS_u8_YELLOW_PIN, DIO_u8_HIGH);
    3392:	80 e0       	ldi	r24, 0x00	; 0
    3394:	63 e0       	ldi	r22, 0x03	; 3
    3396:	41 e0       	ldi	r20, 0x01	; 1
    3398:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_ORANGE_PORT, MOTORS_u8_ORANGE_PIN, DIO_u8_HIGH);
    339c:	80 e0       	ldi	r24, 0x00	; 0
    339e:	64 e0       	ldi	r22, 0x04	; 4
    33a0:	41 e0       	ldi	r20, 0x01	; 1
    33a2:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    33a6:	ce 01       	movw	r24, r28
    33a8:	01 97       	sbiw	r24, 0x01	; 1
    33aa:	f1 f7       	brne	.-4      	; 0x33a8 <Motors_voidStepperMotorON+0x72>
		_delay_ms(10);
		
		DIO_u8SetPinValue(MOTORS_u8_BLUE_PORT, MOTORS_u8_BLUE_PIN, DIO_u8_HIGH);
    33ac:	80 e0       	ldi	r24, 0x00	; 0
    33ae:	61 e0       	ldi	r22, 0x01	; 1
    33b0:	41 e0       	ldi	r20, 0x01	; 1
    33b2:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_PINK_PORT, MOTORS_u8_PINK_PIN, DIO_u8_LOW);
    33b6:	80 e0       	ldi	r24, 0x00	; 0
    33b8:	62 e0       	ldi	r22, 0x02	; 2
    33ba:	40 e0       	ldi	r20, 0x00	; 0
    33bc:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_YELLOW_PORT, MOTORS_u8_YELLOW_PIN, DIO_u8_HIGH);
    33c0:	80 e0       	ldi	r24, 0x00	; 0
    33c2:	63 e0       	ldi	r22, 0x03	; 3
    33c4:	41 e0       	ldi	r20, 0x01	; 1
    33c6:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_ORANGE_PORT, MOTORS_u8_ORANGE_PIN, DIO_u8_HIGH);
    33ca:	80 e0       	ldi	r24, 0x00	; 0
    33cc:	64 e0       	ldi	r22, 0x04	; 4
    33ce:	41 e0       	ldi	r20, 0x01	; 1
    33d0:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    33d4:	ce 01       	movw	r24, r28
    33d6:	01 97       	sbiw	r24, 0x01	; 1
    33d8:	f1 f7       	brne	.-4      	; 0x33d6 <Motors_voidStepperMotorON+0xa0>
		_delay_ms(10);
		
		DIO_u8SetPinValue(MOTORS_u8_BLUE_PORT, MOTORS_u8_BLUE_PIN, DIO_u8_HIGH);
    33da:	80 e0       	ldi	r24, 0x00	; 0
    33dc:	61 e0       	ldi	r22, 0x01	; 1
    33de:	41 e0       	ldi	r20, 0x01	; 1
    33e0:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_PINK_PORT, MOTORS_u8_PINK_PIN, DIO_u8_HIGH);
    33e4:	80 e0       	ldi	r24, 0x00	; 0
    33e6:	62 e0       	ldi	r22, 0x02	; 2
    33e8:	41 e0       	ldi	r20, 0x01	; 1
    33ea:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_YELLOW_PORT, MOTORS_u8_YELLOW_PIN, DIO_u8_LOW);
    33ee:	80 e0       	ldi	r24, 0x00	; 0
    33f0:	63 e0       	ldi	r22, 0x03	; 3
    33f2:	40 e0       	ldi	r20, 0x00	; 0
    33f4:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_ORANGE_PORT, MOTORS_u8_ORANGE_PIN, DIO_u8_HIGH);
    33f8:	80 e0       	ldi	r24, 0x00	; 0
    33fa:	64 e0       	ldi	r22, 0x04	; 4
    33fc:	41 e0       	ldi	r20, 0x01	; 1
    33fe:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    3402:	ce 01       	movw	r24, r28
    3404:	01 97       	sbiw	r24, 0x01	; 1
    3406:	f1 f7       	brne	.-4      	; 0x3404 <Motors_voidStepperMotorON+0xce>
		_delay_ms(10);
		
		DIO_u8SetPinValue(MOTORS_u8_BLUE_PORT, MOTORS_u8_BLUE_PIN, DIO_u8_HIGH);
    3408:	80 e0       	ldi	r24, 0x00	; 0
    340a:	61 e0       	ldi	r22, 0x01	; 1
    340c:	41 e0       	ldi	r20, 0x01	; 1
    340e:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_PINK_PORT, MOTORS_u8_PINK_PIN, DIO_u8_HIGH);
    3412:	80 e0       	ldi	r24, 0x00	; 0
    3414:	62 e0       	ldi	r22, 0x02	; 2
    3416:	41 e0       	ldi	r20, 0x01	; 1
    3418:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_YELLOW_PORT, MOTORS_u8_YELLOW_PIN, DIO_u8_HIGH);
    341c:	80 e0       	ldi	r24, 0x00	; 0
    341e:	63 e0       	ldi	r22, 0x03	; 3
    3420:	41 e0       	ldi	r20, 0x01	; 1
    3422:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		DIO_u8SetPinValue(MOTORS_u8_ORANGE_PORT, MOTORS_u8_ORANGE_PIN, DIO_u8_LOW);
    3426:	80 e0       	ldi	r24, 0x00	; 0
    3428:	64 e0       	ldi	r22, 0x04	; 4
    342a:	40 e0       	ldi	r20, 0x00	; 0
    342c:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
    3430:	ce 01       	movw	r24, r28
    3432:	01 97       	sbiw	r24, 0x01	; 1
    3434:	f1 f7       	brne	.-4      	; 0x3432 <Motors_voidStepperMotorON+0xfc>
	u8	  Local_u8Iterator    = 0;
	
	/* Set Common Pin with High (From datasheet) */
	DIO_u8SetPinValue(MOTORS_u8_COMMON_PORT, MOTORS_u8_COMMON_PIN, DIO_u8_HIGH);
	
	for(Local_u8Iterator = 0; Local_u8Iterator<Local_u8StepsNumber/4; Local_u8Iterator++)
    3436:	1f 5f       	subi	r17, 0xFF	; 255
    3438:	1e 15       	cp	r17, r14
    343a:	08 f4       	brcc	.+2      	; 0x343e <Motors_voidStepperMotorON+0x108>
    343c:	a0 cf       	rjmp	.-192    	; 0x337e <Motors_voidStepperMotorON+0x48>
		DIO_u8SetPinValue(MOTORS_u8_PINK_PORT, MOTORS_u8_PINK_PIN, DIO_u8_HIGH);
		DIO_u8SetPinValue(MOTORS_u8_YELLOW_PORT, MOTORS_u8_YELLOW_PIN, DIO_u8_HIGH);
		DIO_u8SetPinValue(MOTORS_u8_ORANGE_PORT, MOTORS_u8_ORANGE_PIN, DIO_u8_LOW);
		_delay_ms(10);
	}
}
    343e:	df 91       	pop	r29
    3440:	cf 91       	pop	r28
    3442:	1f 91       	pop	r17
    3444:	0f 91       	pop	r16
    3446:	ff 90       	pop	r15
    3448:	ef 90       	pop	r14
    344a:	08 95       	ret

0000344c <system_init>:
	}
}

void system_init(void)
{
	DIO_voidInit();
    344c:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <DIO_voidInit>
	ADC_voidInit();
    3450:	0e 94 b8 14 	call	0x2970	; 0x2970 <ADC_voidInit>
	LCD_voidInit();
    3454:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <LCD_voidInit>
	usart_init(9600);
    3458:	80 e8       	ldi	r24, 0x80	; 128
    345a:	95 e2       	ldi	r25, 0x25	; 37
    345c:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <usart_init>
	usart_puts("   Smart Home  \r\n");
    3460:	8d e7       	ldi	r24, 0x7D	; 125
    3462:	90 e0       	ldi	r25, 0x00	; 0
    3464:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <usart_puts>
	usart_puts("     Group 1   \r\n");
    3468:	8f e8       	ldi	r24, 0x8F	; 143
    346a:	90 e0       	ldi	r25, 0x00	; 0
    346c:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <usart_puts>
}
    3470:	08 95       	ret

00003472 <T_Display>:
		vTaskDelay(100);
	}
}

void T_Display(void* pvParam)
{
    3472:	0f 93       	push	r16
    3474:	1f 93       	push	r17
    3476:	cf 93       	push	r28
    3478:	df 93       	push	r29
	xEventGroupSetBits(egStates,E_MAIN);
    347a:	80 91 ce 06 	lds	r24, 0x06CE
    347e:	90 91 cf 06 	lds	r25, 0x06CF
    3482:	61 e0       	ldi	r22, 0x01	; 1
    3484:	70 e0       	ldi	r23, 0x00	; 0
    3486:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
    348a:	c8 ec       	ldi	r28, 0xC8	; 200
    348c:	d0 e0       	ldi	r29, 0x00	; 0
	while(1)
	{
		ebStateBits = xEventGroupWaitBits(egStates,
    348e:	80 91 ce 06 	lds	r24, 0x06CE
    3492:	90 91 cf 06 	lds	r25, 0x06CF
    3496:	6f e3       	ldi	r22, 0x3F	; 63
    3498:	70 e0       	ldi	r23, 0x00	; 0
    349a:	41 e0       	ldi	r20, 0x01	; 1
    349c:	20 e0       	ldi	r18, 0x00	; 0
    349e:	0f ef       	ldi	r16, 0xFF	; 255
    34a0:	1f ef       	ldi	r17, 0xFF	; 255
    34a2:	0e 94 ba 08 	call	0x1174	; 0x1174 <xEventGroupWaitBits>
    34a6:	80 93 cc 06 	sts	0x06CC, r24
    34aa:	90 93 cd 06 	sts	0x06CD, r25
				(E_MAIN | E_ENPASS | E_ENEWPASS | E_BLOCKED | E_DOOR | E_WRONGPASS),
				1,
				0,
				portMAX_DELAY);

		if((ebStateBits&E_MAIN) == E_MAIN)
    34ae:	80 ff       	sbrs	r24, 0
    34b0:	10 c0       	rjmp	.+32     	; 0x34d2 <T_Display+0x60>
		{
			LCD_voidSetCursor(1,0);
    34b2:	81 e0       	ldi	r24, 0x01	; 1
    34b4:	60 e0       	ldi	r22, 0x00	; 0
    34b6:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
			LCD_voidWriteStr("+ Change Pass");
    34ba:	81 ea       	ldi	r24, 0xA1	; 161
    34bc:	90 e0       	ldi	r25, 0x00	; 0
    34be:	0e 94 60 18 	call	0x30c0	; 0x30c0 <LCD_voidWriteStr>
			LCD_voidSetCursor(2,0);
    34c2:	82 e0       	ldi	r24, 0x02	; 2
    34c4:	60 e0       	ldi	r22, 0x00	; 0
    34c6:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
			LCD_voidWriteStr("- Open Door");
    34ca:	8f ea       	ldi	r24, 0xAF	; 175
    34cc:	90 e0       	ldi	r25, 0x00	; 0
    34ce:	0e 94 60 18 	call	0x30c0	; 0x30c0 <LCD_voidWriteStr>
		}
		if((ebStateBits&E_ENPASS) == E_ENPASS)
    34d2:	80 91 cc 06 	lds	r24, 0x06CC
    34d6:	81 ff       	sbrs	r24, 1
    34d8:	0a c0       	rjmp	.+20     	; 0x34ee <T_Display+0x7c>
		{
			LCD_voidClear();
    34da:	0e 94 a2 18 	call	0x3144	; 0x3144 <LCD_voidClear>
			LCD_voidSetCursor(1,0);
    34de:	81 e0       	ldi	r24, 0x01	; 1
    34e0:	60 e0       	ldi	r22, 0x00	; 0
    34e2:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
			LCD_voidWriteStr("Enter Pass");
    34e6:	8b eb       	ldi	r24, 0xBB	; 187
    34e8:	90 e0       	ldi	r25, 0x00	; 0
    34ea:	0e 94 60 18 	call	0x30c0	; 0x30c0 <LCD_voidWriteStr>
		}
		if((ebStateBits&E_ENEWPASS) == E_ENEWPASS)
    34ee:	80 91 cc 06 	lds	r24, 0x06CC
    34f2:	82 ff       	sbrs	r24, 2
    34f4:	0a c0       	rjmp	.+20     	; 0x350a <T_Display+0x98>
		{
			LCD_voidClear();
    34f6:	0e 94 a2 18 	call	0x3144	; 0x3144 <LCD_voidClear>
			LCD_voidSetCursor(1,0);
    34fa:	81 e0       	ldi	r24, 0x01	; 1
    34fc:	60 e0       	ldi	r22, 0x00	; 0
    34fe:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
			LCD_voidWriteStr("Enter New Pass");
    3502:	86 ec       	ldi	r24, 0xC6	; 198
    3504:	90 e0       	ldi	r25, 0x00	; 0
    3506:	0e 94 60 18 	call	0x30c0	; 0x30c0 <LCD_voidWriteStr>
		}
		if((ebStateBits&E_BLOCKED) == E_BLOCKED)
    350a:	80 91 cc 06 	lds	r24, 0x06CC
    350e:	83 ff       	sbrs	r24, 3
    3510:	11 c0       	rjmp	.+34     	; 0x3534 <T_Display+0xc2>
		{
			LCD_voidClear();
    3512:	0e 94 a2 18 	call	0x3144	; 0x3144 <LCD_voidClear>
			LCD_voidSetCursor(1,0);
    3516:	81 e0       	ldi	r24, 0x01	; 1
    3518:	60 e0       	ldi	r22, 0x00	; 0
    351a:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
			LCD_voidWriteStr("BLOCKED !!");
    351e:	85 ed       	ldi	r24, 0xD5	; 213
    3520:	90 e0       	ldi	r25, 0x00	; 0
    3522:	0e 94 60 18 	call	0x30c0	; 0x30c0 <LCD_voidWriteStr>
    3526:	80 e2       	ldi	r24, 0x20	; 32
    3528:	9e e4       	ldi	r25, 0x4E	; 78
    352a:	fe 01       	movw	r30, r28
    352c:	31 97       	sbiw	r30, 0x01	; 1
    352e:	f1 f7       	brne	.-4      	; 0x352c <T_Display+0xba>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3530:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3532:	d9 f7       	brne	.-10     	; 0x352a <T_Display+0xb8>
			_delay_ms(2000);
		}
		if((ebStateBits&E_DOOR) == E_DOOR)
    3534:	80 91 cc 06 	lds	r24, 0x06CC
    3538:	84 ff       	sbrs	r24, 4
    353a:	14 c0       	rjmp	.+40     	; 0x3564 <T_Display+0xf2>
		{
			LCD_voidClear();
    353c:	0e 94 a2 18 	call	0x3144	; 0x3144 <LCD_voidClear>
			LCD_voidSetCursor(1,0);
    3540:	81 e0       	ldi	r24, 0x01	; 1
    3542:	60 e0       	ldi	r22, 0x00	; 0
    3544:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
			LCD_voidWriteStr("Door Opened");
    3548:	80 ee       	ldi	r24, 0xE0	; 224
    354a:	90 e0       	ldi	r25, 0x00	; 0
    354c:	0e 94 60 18 	call	0x30c0	; 0x30c0 <LCD_voidWriteStr>
			vTaskDelay(3000);
    3550:	88 eb       	ldi	r24, 0xB8	; 184
    3552:	9b e0       	ldi	r25, 0x0B	; 11
    3554:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
			LCD_voidClear();
    3558:	0e 94 a2 18 	call	0x3144	; 0x3144 <LCD_voidClear>
			LCD_voidWriteStr("Door Closed");
    355c:	8c ee       	ldi	r24, 0xEC	; 236
    355e:	90 e0       	ldi	r25, 0x00	; 0
    3560:	0e 94 60 18 	call	0x30c0	; 0x30c0 <LCD_voidWriteStr>
		}
		if((ebStateBits&E_WRONGPASS) == E_WRONGPASS)
    3564:	80 91 cc 06 	lds	r24, 0x06CC
    3568:	85 ff       	sbrs	r24, 5
    356a:	11 c0       	rjmp	.+34     	; 0x358e <T_Display+0x11c>
		{
			LCD_voidClear();
    356c:	0e 94 a2 18 	call	0x3144	; 0x3144 <LCD_voidClear>
			LCD_voidSetCursor(1,0);
    3570:	81 e0       	ldi	r24, 0x01	; 1
    3572:	60 e0       	ldi	r22, 0x00	; 0
    3574:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
			LCD_voidWriteStr("Wrong Pass");
    3578:	88 ef       	ldi	r24, 0xF8	; 248
    357a:	90 e0       	ldi	r25, 0x00	; 0
    357c:	0e 94 60 18 	call	0x30c0	; 0x30c0 <LCD_voidWriteStr>
    3580:	80 e1       	ldi	r24, 0x10	; 16
    3582:	97 e2       	ldi	r25, 0x27	; 39
    3584:	fe 01       	movw	r30, r28
    3586:	31 97       	sbiw	r30, 0x01	; 1
    3588:	f1 f7       	brne	.-4      	; 0x3586 <T_Display+0x114>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    358a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    358c:	d9 f7       	brne	.-10     	; 0x3584 <T_Display+0x112>
			_delay_ms(1000);
		}
		vTaskDelay(100);
    358e:	84 e6       	ldi	r24, 0x64	; 100
    3590:	90 e0       	ldi	r25, 0x00	; 0
    3592:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
    3596:	7b cf       	rjmp	.-266    	; 0x348e <T_Display+0x1c>

00003598 <T_LDRSensor>:
	}

}

void T_LDRSensor(void* pvParam)
{
    3598:	0f 93       	push	r16
    359a:	1f 93       	push	r17
    359c:	df 93       	push	r29
    359e:	cf 93       	push	r28
    35a0:	00 d0       	rcall	.+0      	; 0x35a2 <T_LDRSensor+0xa>
    35a2:	cd b7       	in	r28, 0x3d	; 61
    35a4:	de b7       	in	r29, 0x3e	; 62
	u16 Local_u16DigitalValue;
	u16 Local_u16AnalogValue;
	while(1)
	{
		ADC_u8GetDigitalValueSynchronous(ADC_u8_CHANNEL_1, &Local_u16DigitalValue);
    35a6:	8e 01       	movw	r16, r28
    35a8:	0f 5f       	subi	r16, 0xFF	; 255
    35aa:	1f 4f       	sbci	r17, 0xFF	; 255
    35ac:	81 e0       	ldi	r24, 0x01	; 1
    35ae:	b8 01       	movw	r22, r16
    35b0:	0e 94 c1 14 	call	0x2982	; 0x2982 <ADC_u8GetDigitalValueSynchronous>
		Local_u16AnalogValue = ((u32)Local_u16DigitalValue * 5000) / 1024;

		if(Local_u16AnalogValue > 2500)
    35b4:	69 81       	ldd	r22, Y+1	; 0x01
    35b6:	7a 81       	ldd	r23, Y+2	; 0x02
    35b8:	80 e0       	ldi	r24, 0x00	; 0
    35ba:	90 e0       	ldi	r25, 0x00	; 0
    35bc:	28 e8       	ldi	r18, 0x88	; 136
    35be:	33 e1       	ldi	r19, 0x13	; 19
    35c0:	40 e0       	ldi	r20, 0x00	; 0
    35c2:	50 e0       	ldi	r21, 0x00	; 0
    35c4:	0e 94 84 1d 	call	0x3b08	; 0x3b08 <__mulsi3>
    35c8:	2a e0       	ldi	r18, 0x0A	; 10
    35ca:	96 95       	lsr	r25
    35cc:	87 95       	ror	r24
    35ce:	77 95       	ror	r23
    35d0:	67 95       	ror	r22
    35d2:	2a 95       	dec	r18
    35d4:	d1 f7       	brne	.-12     	; 0x35ca <T_LDRSensor+0x32>
    35d6:	65 5c       	subi	r22, 0xC5	; 197
    35d8:	79 40       	sbci	r23, 0x09	; 9
    35da:	28 f0       	brcs	.+10     	; 0x35e6 <T_LDRSensor+0x4e>
		{
			LED_u8TurnOn(&Lights);
    35dc:	8d e0       	ldi	r24, 0x0D	; 13
    35de:	92 e0       	ldi	r25, 0x02	; 2
    35e0:	0e 94 45 19 	call	0x328a	; 0x328a <LED_u8TurnOn>
    35e4:	04 c0       	rjmp	.+8      	; 0x35ee <T_LDRSensor+0x56>
		}
		else
		{
			LED_u8TurnOff(&Lights);
    35e6:	8d e0       	ldi	r24, 0x0D	; 13
    35e8:	92 e0       	ldi	r25, 0x02	; 2
    35ea:	0e 94 2e 19 	call	0x325c	; 0x325c <LED_u8TurnOff>
		}
		vTaskDelay(100);
    35ee:	84 e6       	ldi	r24, 0x64	; 100
    35f0:	90 e0       	ldi	r25, 0x00	; 0
    35f2:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
    35f6:	da cf       	rjmp	.-76     	; 0x35ac <T_LDRSensor+0x14>

000035f8 <T_TemperatureSensor>:
		}
	}
}

void T_TemperatureSensor(void* pvParam)
{
    35f8:	0f 93       	push	r16
    35fa:	1f 93       	push	r17
    35fc:	df 93       	push	r29
    35fe:	cf 93       	push	r28
    3600:	00 d0       	rcall	.+0      	; 0x3602 <T_TemperatureSensor+0xa>
    3602:	cd b7       	in	r28, 0x3d	; 61
    3604:	de b7       	in	r29, 0x3e	; 62
	u16 Local_u16DigitalValue;
	u16 Local_u16AnalogValue;
	u16	Local_u16Temperature;
	while(1)
	{
		ADC_u8GetDigitalValueSynchronous(ADC_u8_CHANNEL_0, &Local_u16DigitalValue);
    3606:	8e 01       	movw	r16, r28
    3608:	0f 5f       	subi	r16, 0xFF	; 255
    360a:	1f 4f       	sbci	r17, 0xFF	; 255
    360c:	80 e0       	ldi	r24, 0x00	; 0
    360e:	b8 01       	movw	r22, r16
    3610:	0e 94 c1 14 	call	0x2982	; 0x2982 <ADC_u8GetDigitalValueSynchronous>
		Local_u16AnalogValue = ((u32)Local_u16DigitalValue * 500) / 1024;

		Local_u16Temperature = Local_u16AnalogValue;
		if(Local_u16Temperature >= 30)
    3614:	69 81       	ldd	r22, Y+1	; 0x01
    3616:	7a 81       	ldd	r23, Y+2	; 0x02
    3618:	80 e0       	ldi	r24, 0x00	; 0
    361a:	90 e0       	ldi	r25, 0x00	; 0
    361c:	24 ef       	ldi	r18, 0xF4	; 244
    361e:	31 e0       	ldi	r19, 0x01	; 1
    3620:	40 e0       	ldi	r20, 0x00	; 0
    3622:	50 e0       	ldi	r21, 0x00	; 0
    3624:	0e 94 84 1d 	call	0x3b08	; 0x3b08 <__mulsi3>
    3628:	3a e0       	ldi	r19, 0x0A	; 10
    362a:	96 95       	lsr	r25
    362c:	87 95       	ror	r24
    362e:	77 95       	ror	r23
    3630:	67 95       	ror	r22
    3632:	3a 95       	dec	r19
    3634:	d1 f7       	brne	.-12     	; 0x362a <T_TemperatureSensor+0x32>
    3636:	6e 31       	cpi	r22, 0x1E	; 30
    3638:	71 05       	cpc	r23, r1
    363a:	20 f0       	brcs	.+8      	; 0x3644 <T_TemperatureSensor+0x4c>
		{
			DIO_u8SetPinValue(DIO_u8_PORTC, DIO_u8_PIN3, DIO_u8_HIGH);
    363c:	82 e0       	ldi	r24, 0x02	; 2
    363e:	63 e0       	ldi	r22, 0x03	; 3
    3640:	41 e0       	ldi	r20, 0x01	; 1
    3642:	03 c0       	rjmp	.+6      	; 0x364a <T_TemperatureSensor+0x52>
		}
		else
		{
			DIO_u8SetPinValue(DIO_u8_PORTC, DIO_u8_PIN3, DIO_u8_LOW);
    3644:	82 e0       	ldi	r24, 0x02	; 2
    3646:	63 e0       	ldi	r22, 0x03	; 3
    3648:	40 e0       	ldi	r20, 0x00	; 0
    364a:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
		}
		vTaskDelay(100);
    364e:	84 e6       	ldi	r24, 0x64	; 100
    3650:	90 e0       	ldi	r25, 0x00	; 0
    3652:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
    3656:	da cf       	rjmp	.-76     	; 0x360c <T_TemperatureSensor+0x14>

00003658 <T_Login>:
		}
	}
}

void T_Login(void* pvParam)
{
    3658:	cf 92       	push	r12
    365a:	df 92       	push	r13
    365c:	ef 92       	push	r14
    365e:	ff 92       	push	r15
    3660:	0f 93       	push	r16
    3662:	1f 93       	push	r17
    3664:	df 93       	push	r29
    3666:	cf 93       	push	r28
    3668:	0f 92       	push	r0
    366a:	cd b7       	in	r28, 0x3d	; 61
    366c:	de b7       	in	r29, 0x3e	; 62
	u8 Local_u8KPDData 	    = 0;
    366e:	19 82       	std	Y+1, r1	; 0x01
	{
		if(xSemaphoreTake(bsPassword, portMAX_DELAY))
		{
			while(Local_u8EnteredPass != Smart.Password)
			{
				KPD_u8GetSwitch(&Local_u8KPDData);
    3670:	6e 01       	movw	r12, r28
    3672:	08 94       	sec
    3674:	c1 1c       	adc	r12, r1
    3676:	d1 1c       	adc	r13, r1
	u8 Local_u8Cursor       = 0;
	u16 Local_u8NewPass      = 0;
	u8 Local_u8Trial        = 3;
	while(1)
	{
		if(xSemaphoreTake(bsPassword, portMAX_DELAY))
    3678:	80 91 d2 06 	lds	r24, 0x06D2
    367c:	90 91 d3 06 	lds	r25, 0x06D3
    3680:	60 e0       	ldi	r22, 0x00	; 0
    3682:	70 e0       	ldi	r23, 0x00	; 0
    3684:	4f ef       	ldi	r20, 0xFF	; 255
    3686:	5f ef       	ldi	r21, 0xFF	; 255
    3688:	20 e0       	ldi	r18, 0x00	; 0
    368a:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <xQueueGenericReceive>
    368e:	88 23       	and	r24, r24
    3690:	99 f3       	breq	.-26     	; 0x3678 <T_Login+0x20>
    3692:	15 c1       	rjmp	.+554    	; 0x38be <T_Login+0x266>
		{
			while(Local_u8EnteredPass != Smart.Password)
			{
				KPD_u8GetSwitch(&Local_u8KPDData);
    3694:	c6 01       	movw	r24, r12
    3696:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <KPD_u8GetSwitch>
				switch (Local_u8KPDData)
    369a:	89 81       	ldd	r24, Y+1	; 0x01
    369c:	8b 32       	cpi	r24, 0x2B	; 43
    369e:	21 f0       	breq	.+8      	; 0x36a8 <T_Login+0x50>
    36a0:	8d 32       	cpi	r24, 0x2D	; 45
    36a2:	09 f0       	breq	.+2      	; 0x36a6 <T_Login+0x4e>
    36a4:	08 c1       	rjmp	.+528    	; 0x38b6 <T_Login+0x25e>
    36a6:	93 c0       	rjmp	.+294    	; 0x37ce <T_Login+0x176>
    36a8:	b3 e0       	ldi	r27, 0x03	; 3
    36aa:	eb 2e       	mov	r14, r27
				{
				case'+':
					Local_u8Trial	    = 3;
					while(Local_u8Trial > 0)
					{
						xEventGroupSetBits(egStates, E_ENPASS);
    36ac:	80 91 ce 06 	lds	r24, 0x06CE
    36b0:	90 91 cf 06 	lds	r25, 0x06CF
    36b4:	62 e0       	ldi	r22, 0x02	; 2
    36b6:	70 e0       	ldi	r23, 0x00	; 0
    36b8:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
						vTaskDelay(30);
    36bc:	8e e1       	ldi	r24, 0x1E	; 30
    36be:	90 e0       	ldi	r25, 0x00	; 0
    36c0:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
    36c4:	00 e0       	ldi	r16, 0x00	; 0
    36c6:	10 e0       	ldi	r17, 0x00	; 0
    36c8:	ff 24       	eor	r15, r15
						while(Local_u8Cursor<4)
						{
							KPD_u8GetSwitch(&Local_u8KPDData);
    36ca:	c6 01       	movw	r24, r12
    36cc:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <KPD_u8GetSwitch>
							if(Local_u8KPDData != KPD_u8_NOT_PRESSED)
    36d0:	29 81       	ldd	r18, Y+1	; 0x01
    36d2:	2f 3f       	cpi	r18, 0xFF	; 255
    36d4:	d1 f3       	breq	.-12     	; 0x36ca <T_Login+0x72>
							{
								Local_u8EnteredPass = (Local_u8EnteredPass*10) + (Local_u8KPDData-48);
    36d6:	c8 01       	movw	r24, r16
    36d8:	a3 e0       	ldi	r26, 0x03	; 3
    36da:	88 0f       	add	r24, r24
    36dc:	99 1f       	adc	r25, r25
    36de:	aa 95       	dec	r26
    36e0:	e1 f7       	brne	.-8      	; 0x36da <T_Login+0x82>
    36e2:	00 0f       	add	r16, r16
    36e4:	11 1f       	adc	r17, r17
    36e6:	80 0f       	add	r24, r16
    36e8:	91 1f       	adc	r25, r17
    36ea:	02 2f       	mov	r16, r18
    36ec:	10 e0       	ldi	r17, 0x00	; 0
    36ee:	00 53       	subi	r16, 0x30	; 48
    36f0:	10 40       	sbci	r17, 0x00	; 0
    36f2:	08 0f       	add	r16, r24
    36f4:	19 1f       	adc	r17, r25
								LCD_voidSetCursor(2,Local_u8Cursor);
    36f6:	82 e0       	ldi	r24, 0x02	; 2
    36f8:	6f 2d       	mov	r22, r15
    36fa:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
								LCD_voidWriteChar('*');
    36fe:	8a e2       	ldi	r24, 0x2A	; 42
    3700:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
								Local_u8Cursor++;
    3704:	f3 94       	inc	r15
					Local_u8Trial	    = 3;
					while(Local_u8Trial > 0)
					{
						xEventGroupSetBits(egStates, E_ENPASS);
						vTaskDelay(30);
						while(Local_u8Cursor<4)
    3706:	83 e0       	ldi	r24, 0x03	; 3
    3708:	8f 15       	cp	r24, r15
    370a:	f8 f6       	brcc	.-66     	; 0x36ca <T_Login+0x72>
								LCD_voidSetCursor(2,Local_u8Cursor);
								LCD_voidWriteChar('*');
								Local_u8Cursor++;
							}
						}
						if(Local_u8EnteredPass == Smart.Password)
    370c:	98 01       	movw	r18, r16
    370e:	40 e0       	ldi	r20, 0x00	; 0
    3710:	50 e0       	ldi	r21, 0x00	; 0
    3712:	80 91 10 02 	lds	r24, 0x0210
    3716:	90 91 11 02 	lds	r25, 0x0211
    371a:	a0 91 12 02 	lds	r26, 0x0212
    371e:	b0 91 13 02 	lds	r27, 0x0213
    3722:	60 91 ce 06 	lds	r22, 0x06CE
    3726:	70 91 cf 06 	lds	r23, 0x06CF
    372a:	28 17       	cp	r18, r24
    372c:	39 07       	cpc	r19, r25
    372e:	4a 07       	cpc	r20, r26
    3730:	5b 07       	cpc	r21, r27
    3732:	09 f0       	breq	.+2      	; 0x3736 <T_Login+0xde>
    3734:	3f c0       	rjmp	.+126    	; 0x37b4 <T_Login+0x15c>
						{
							Local_u8Trial	    = 0;
							Local_u8EnteredPass = 0;
							Local_u8Cursor		= 0;
							xEventGroupSetBits(egStates, E_ENEWPASS);
    3736:	cb 01       	movw	r24, r22
    3738:	64 e0       	ldi	r22, 0x04	; 4
    373a:	70 e0       	ldi	r23, 0x00	; 0
    373c:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
							vTaskDelay(100);
    3740:	84 e6       	ldi	r24, 0x64	; 100
    3742:	90 e0       	ldi	r25, 0x00	; 0
    3744:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
    3748:	ff 24       	eor	r15, r15
    374a:	00 e0       	ldi	r16, 0x00	; 0
    374c:	10 e0       	ldi	r17, 0x00	; 0
							Local_u8Cursor = 0;
							/* Get New Password */
							while(Local_u8Cursor<4)
							{
								KPD_u8GetSwitch(&Local_u8KPDData);
    374e:	c6 01       	movw	r24, r12
    3750:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <KPD_u8GetSwitch>
								if(Local_u8KPDData != KPD_u8_NOT_PRESSED)
    3754:	29 81       	ldd	r18, Y+1	; 0x01
    3756:	2f 3f       	cpi	r18, 0xFF	; 255
    3758:	d1 f3       	breq	.-12     	; 0x374e <T_Login+0xf6>
								{
									Local_u8NewPass = (Local_u8NewPass*10) + (Local_u8KPDData-48);
    375a:	c8 01       	movw	r24, r16
    375c:	e3 e0       	ldi	r30, 0x03	; 3
    375e:	88 0f       	add	r24, r24
    3760:	99 1f       	adc	r25, r25
    3762:	ea 95       	dec	r30
    3764:	e1 f7       	brne	.-8      	; 0x375e <T_Login+0x106>
    3766:	00 0f       	add	r16, r16
    3768:	11 1f       	adc	r17, r17
    376a:	80 0f       	add	r24, r16
    376c:	91 1f       	adc	r25, r17
    376e:	02 2f       	mov	r16, r18
    3770:	10 e0       	ldi	r17, 0x00	; 0
    3772:	00 53       	subi	r16, 0x30	; 48
    3774:	10 40       	sbci	r17, 0x00	; 0
    3776:	08 0f       	add	r16, r24
    3778:	19 1f       	adc	r17, r25
									LCD_voidSetCursor(2,Local_u8Cursor);
    377a:	82 e0       	ldi	r24, 0x02	; 2
    377c:	6f 2d       	mov	r22, r15
    377e:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
									LCD_voidWriteChar(Local_u8KPDData);
    3782:	89 81       	ldd	r24, Y+1	; 0x01
    3784:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
									Local_u8Cursor++;
    3788:	f3 94       	inc	r15
							Local_u8Cursor		= 0;
							xEventGroupSetBits(egStates, E_ENEWPASS);
							vTaskDelay(100);
							Local_u8Cursor = 0;
							/* Get New Password */
							while(Local_u8Cursor<4)
    378a:	83 e0       	ldi	r24, 0x03	; 3
    378c:	8f 15       	cp	r24, r15
    378e:	f8 f6       	brcc	.-66     	; 0x374e <T_Login+0xf6>
									LCD_voidSetCursor(2,Local_u8Cursor);
									LCD_voidWriteChar(Local_u8KPDData);
									Local_u8Cursor++;
								}
							}
							Smart.Password = Local_u8NewPass;
    3790:	c8 01       	movw	r24, r16
    3792:	a0 e0       	ldi	r26, 0x00	; 0
    3794:	b0 e0       	ldi	r27, 0x00	; 0
    3796:	80 93 10 02 	sts	0x0210, r24
    379a:	90 93 11 02 	sts	0x0211, r25
    379e:	a0 93 12 02 	sts	0x0212, r26
    37a2:	b0 93 13 02 	sts	0x0213, r27

							Local_u8NewPass     = 0;
							Local_u8Cursor 		= 0;
							Local_u8EnteredPass = 0;

							xEventGroupSetBits(egStates, E_MAIN);
    37a6:	80 91 ce 06 	lds	r24, 0x06CE
    37aa:	90 91 cf 06 	lds	r25, 0x06CF
    37ae:	61 e0       	ldi	r22, 0x01	; 1
    37b0:	70 e0       	ldi	r23, 0x00	; 0
    37b2:	5e c0       	rjmp	.+188    	; 0x3870 <T_Login+0x218>
						}
						else
						{
							Local_u8EnteredPass = 0;
							Local_u8Cursor = 0;
							xEventGroupSetBits(egStates, E_WRONGPASS);
    37b4:	cb 01       	movw	r24, r22
    37b6:	60 e2       	ldi	r22, 0x20	; 32
    37b8:	70 e0       	ldi	r23, 0x00	; 0
    37ba:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
							vTaskDelay(30);
    37be:	8e e1       	ldi	r24, 0x1E	; 30
    37c0:	90 e0       	ldi	r25, 0x00	; 0
    37c2:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
							Local_u8Trial --;
    37c6:	ea 94       	dec	r14
							if(Local_u8Trial == 0)
    37c8:	09 f0       	breq	.+2      	; 0x37cc <T_Login+0x174>
    37ca:	70 cf       	rjmp	.-288    	; 0x36ac <T_Login+0x54>
    37cc:	60 c0       	rjmp	.+192    	; 0x388e <T_Login+0x236>
							{
								xEventGroupSetBits(egStates, E_BLOCKED);
								xEventGroupSetBits(egActions, E_BUZZER);
								vTaskDelay(30);
    37ce:	63 e0       	ldi	r22, 0x03	; 3
    37d0:	e6 2e       	mov	r14, r22

				case'-':
					Local_u8Trial = 3;
					while(Local_u8Trial > 0)
					{
						xEventGroupSetBits(egStates, E_ENPASS);
    37d2:	80 91 ce 06 	lds	r24, 0x06CE
    37d6:	90 91 cf 06 	lds	r25, 0x06CF
    37da:	62 e0       	ldi	r22, 0x02	; 2
    37dc:	70 e0       	ldi	r23, 0x00	; 0
    37de:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
						vTaskDelay(30);
    37e2:	8e e1       	ldi	r24, 0x1E	; 30
    37e4:	90 e0       	ldi	r25, 0x00	; 0
    37e6:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
    37ea:	00 e0       	ldi	r16, 0x00	; 0
    37ec:	10 e0       	ldi	r17, 0x00	; 0
    37ee:	ff 24       	eor	r15, r15
						while(Local_u8Cursor<4)
						{
							KPD_u8GetSwitch(&Local_u8KPDData);
    37f0:	c6 01       	movw	r24, r12
    37f2:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <KPD_u8GetSwitch>
							if(Local_u8KPDData != KPD_u8_NOT_PRESSED)
    37f6:	29 81       	ldd	r18, Y+1	; 0x01
    37f8:	2f 3f       	cpi	r18, 0xFF	; 255
    37fa:	d1 f3       	breq	.-12     	; 0x37f0 <T_Login+0x198>
							{
								Local_u8EnteredPass = (Local_u8EnteredPass*10) + (Local_u8KPDData-48);
    37fc:	c8 01       	movw	r24, r16
    37fe:	53 e0       	ldi	r21, 0x03	; 3
    3800:	88 0f       	add	r24, r24
    3802:	99 1f       	adc	r25, r25
    3804:	5a 95       	dec	r21
    3806:	e1 f7       	brne	.-8      	; 0x3800 <T_Login+0x1a8>
    3808:	00 0f       	add	r16, r16
    380a:	11 1f       	adc	r17, r17
    380c:	80 0f       	add	r24, r16
    380e:	91 1f       	adc	r25, r17
    3810:	02 2f       	mov	r16, r18
    3812:	10 e0       	ldi	r17, 0x00	; 0
    3814:	00 53       	subi	r16, 0x30	; 48
    3816:	10 40       	sbci	r17, 0x00	; 0
    3818:	08 0f       	add	r16, r24
    381a:	19 1f       	adc	r17, r25
								LCD_voidSetCursor(2,Local_u8Cursor);
    381c:	82 e0       	ldi	r24, 0x02	; 2
    381e:	6f 2d       	mov	r22, r15
    3820:	0e 94 a6 18 	call	0x314c	; 0x314c <LCD_voidSetCursor>
								LCD_voidWriteChar('*');
    3824:	8a e2       	ldi	r24, 0x2A	; 42
    3826:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <LCD_voidWriteChar>
								Local_u8Cursor++;
    382a:	f3 94       	inc	r15
					Local_u8Trial = 3;
					while(Local_u8Trial > 0)
					{
						xEventGroupSetBits(egStates, E_ENPASS);
						vTaskDelay(30);
						while(Local_u8Cursor<4)
    382c:	83 e0       	ldi	r24, 0x03	; 3
    382e:	8f 15       	cp	r24, r15
    3830:	f8 f6       	brcc	.-66     	; 0x37f0 <T_Login+0x198>
								LCD_voidSetCursor(2,Local_u8Cursor);
								LCD_voidWriteChar('*');
								Local_u8Cursor++;
							}
						}
						if(Local_u8EnteredPass == Smart.Password)
    3832:	98 01       	movw	r18, r16
    3834:	40 e0       	ldi	r20, 0x00	; 0
    3836:	50 e0       	ldi	r21, 0x00	; 0
    3838:	80 91 10 02 	lds	r24, 0x0210
    383c:	90 91 11 02 	lds	r25, 0x0211
    3840:	a0 91 12 02 	lds	r26, 0x0212
    3844:	b0 91 13 02 	lds	r27, 0x0213
    3848:	60 91 ce 06 	lds	r22, 0x06CE
    384c:	70 91 cf 06 	lds	r23, 0x06CF
    3850:	28 17       	cp	r18, r24
    3852:	39 07       	cpc	r19, r25
    3854:	4a 07       	cpc	r20, r26
    3856:	5b 07       	cpc	r21, r27
    3858:	71 f4       	brne	.+28     	; 0x3876 <T_Login+0x21e>
							Local_u8Trial       = 0;
							Local_u8EnteredPass = 0;
							Local_u8NewPass     = 0;
							Local_u8Cursor		= 0;

							xEventGroupSetBits(egStates, E_OpenDoor);
    385a:	cb 01       	movw	r24, r22
    385c:	60 e1       	ldi	r22, 0x10	; 16
    385e:	70 e0       	ldi	r23, 0x00	; 0
    3860:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
							xEventGroupSetBits(egActions, E_DOOR);
    3864:	80 91 d0 06 	lds	r24, 0x06D0
    3868:	90 91 d1 06 	lds	r25, 0x06D1
    386c:	60 e1       	ldi	r22, 0x10	; 16
    386e:	70 e0       	ldi	r23, 0x00	; 0
    3870:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
    3874:	20 c0       	rjmp	.+64     	; 0x38b6 <T_Login+0x25e>
						else
						{
							Local_u8EnteredPass = 0;
							Local_u8Cursor = 0;

							xEventGroupSetBits(egStates, E_WRONGPASS);
    3876:	cb 01       	movw	r24, r22
    3878:	60 e2       	ldi	r22, 0x20	; 32
    387a:	70 e0       	ldi	r23, 0x00	; 0
    387c:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
							vTaskDelay(300);
    3880:	8c e2       	ldi	r24, 0x2C	; 44
    3882:	91 e0       	ldi	r25, 0x01	; 1
    3884:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
							Local_u8Trial --;
    3888:	ea 94       	dec	r14
							if(Local_u8Trial == 0)
    388a:	09 f0       	breq	.+2      	; 0x388e <T_Login+0x236>
    388c:	a2 cf       	rjmp	.-188    	; 0x37d2 <T_Login+0x17a>
							{
								xEventGroupSetBits(egStates, E_BLOCKED);
    388e:	80 91 ce 06 	lds	r24, 0x06CE
    3892:	90 91 cf 06 	lds	r25, 0x06CF
    3896:	68 e0       	ldi	r22, 0x08	; 8
    3898:	70 e0       	ldi	r23, 0x00	; 0
    389a:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
								xEventGroupSetBits(egActions, E_BUZZER);
    389e:	80 91 d0 06 	lds	r24, 0x06D0
    38a2:	90 91 d1 06 	lds	r25, 0x06D1
    38a6:	60 e2       	ldi	r22, 0x20	; 32
    38a8:	70 e0       	ldi	r23, 0x00	; 0
    38aa:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
								vTaskDelay(30);
    38ae:	8e e1       	ldi	r24, 0x1E	; 30
    38b0:	90 e0       	ldi	r25, 0x00	; 0
    38b2:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
					break;

				default:
					break;
				}
				vTaskDelay(10);
    38b6:	8a e0       	ldi	r24, 0x0A	; 10
    38b8:	90 e0       	ldi	r25, 0x00	; 0
    38ba:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
	u8 Local_u8Trial        = 3;
	while(1)
	{
		if(xSemaphoreTake(bsPassword, portMAX_DELAY))
		{
			while(Local_u8EnteredPass != Smart.Password)
    38be:	80 91 10 02 	lds	r24, 0x0210
    38c2:	90 91 11 02 	lds	r25, 0x0211
    38c6:	a0 91 12 02 	lds	r26, 0x0212
    38ca:	b0 91 13 02 	lds	r27, 0x0213
    38ce:	00 97       	sbiw	r24, 0x00	; 0
    38d0:	a1 05       	cpc	r26, r1
    38d2:	b1 05       	cpc	r27, r1
    38d4:	09 f0       	breq	.+2      	; 0x38d8 <T_Login+0x280>
    38d6:	de ce       	rjmp	.-580    	; 0x3694 <T_Login+0x3c>
				default:
					break;
				}
				vTaskDelay(10);
			}
			vTaskDelay(10);
    38d8:	8a e0       	ldi	r24, 0x0A	; 10
    38da:	90 e0       	ldi	r25, 0x00	; 0
    38dc:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
    38e0:	cb ce       	rjmp	.-618    	; 0x3678 <T_Login+0x20>

000038e2 <T_Actuators>:
	while(1);
	return 0;
}

void T_Actuators(void* pvParam)
{
    38e2:	0f 93       	push	r16
    38e4:	1f 93       	push	r17
	while(1)
	{
		ebBits = xEventGroupWaitBits(egActions,
    38e6:	80 91 d0 06 	lds	r24, 0x06D0
    38ea:	90 91 d1 06 	lds	r25, 0x06D1
    38ee:	60 e3       	ldi	r22, 0x30	; 48
    38f0:	70 e0       	ldi	r23, 0x00	; 0
    38f2:	41 e0       	ldi	r20, 0x01	; 1
    38f4:	20 e0       	ldi	r18, 0x00	; 0
    38f6:	0f ef       	ldi	r16, 0xFF	; 255
    38f8:	1f ef       	ldi	r17, 0xFF	; 255
    38fa:	0e 94 ba 08 	call	0x1174	; 0x1174 <xEventGroupWaitBits>
    38fe:	80 93 ca 06 	sts	0x06CA, r24
    3902:	90 93 cb 06 	sts	0x06CB, r25
				(E_OpenDoor | E_BUZZER),
				1,
				0,
				portMAX_DELAY);

		if((ebBits&E_OpenDoor) == E_OpenDoor)
    3906:	84 ff       	sbrs	r24, 4
    3908:	2d c0       	rjmp	.+90     	; 0x3964 <T_Actuators+0x82>
		{
			Motors_voidDCMotorON(MOTORS_u8_DC_CW);
    390a:	81 e0       	ldi	r24, 0x01	; 1
    390c:	0e 94 67 19 	call	0x32ce	; 0x32ce <Motors_voidDCMotorON>
			vTaskDelay(1000);
    3910:	88 ee       	ldi	r24, 0xE8	; 232
    3912:	93 e0       	ldi	r25, 0x03	; 3
    3914:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
			Motors_voidDCMotorOFF();
    3918:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <Motors_voidDCMotorOFF>
			vTaskDelay(3000);
    391c:	88 eb       	ldi	r24, 0xB8	; 184
    391e:	9b e0       	ldi	r25, 0x0B	; 11
    3920:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
			Motors_voidDCMotorON(MOTORS_u8_DC_CCW);
    3924:	80 e0       	ldi	r24, 0x00	; 0
    3926:	0e 94 67 19 	call	0x32ce	; 0x32ce <Motors_voidDCMotorON>
			vTaskDelay(1000);
    392a:	88 ee       	ldi	r24, 0xE8	; 232
    392c:	93 e0       	ldi	r25, 0x03	; 3
    392e:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
			Motors_voidDCMotorOFF();
    3932:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <Motors_voidDCMotorOFF>
			xEventGroupSetBits(egStates, E_MAIN);
    3936:	80 91 ce 06 	lds	r24, 0x06CE
    393a:	90 91 cf 06 	lds	r25, 0x06CF
    393e:	61 e0       	ldi	r22, 0x01	; 1
    3940:	70 e0       	ldi	r23, 0x00	; 0
    3942:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
			xSemaphoreGive(bsPassword);
    3946:	80 91 d2 06 	lds	r24, 0x06D2
    394a:	90 91 d3 06 	lds	r25, 0x06D3
    394e:	60 e0       	ldi	r22, 0x00	; 0
    3950:	70 e0       	ldi	r23, 0x00	; 0
    3952:	40 e0       	ldi	r20, 0x00	; 0
    3954:	50 e0       	ldi	r21, 0x00	; 0
    3956:	20 e0       	ldi	r18, 0x00	; 0
    3958:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <xQueueGenericSend>
			vTaskDelay(100);
    395c:	84 e6       	ldi	r24, 0x64	; 100
    395e:	90 e0       	ldi	r25, 0x00	; 0
    3960:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
		}
		if((ebBits&E_BUZZER) == E_BUZZER)
    3964:	80 91 ca 06 	lds	r24, 0x06CA
    3968:	85 ff       	sbrs	r24, 5
    396a:	bd cf       	rjmp	.-134    	; 0x38e6 <T_Actuators+0x4>
		{
			DIO_u8SetPinValue(DIO_u8_PORTB, DIO_u8_PIN0, DIO_u8_HIGH);
    396c:	81 e0       	ldi	r24, 0x01	; 1
    396e:	60 e0       	ldi	r22, 0x00	; 0
    3970:	41 e0       	ldi	r20, 0x01	; 1
    3972:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
			vTaskDelay(1000);
    3976:	88 ee       	ldi	r24, 0xE8	; 232
    3978:	93 e0       	ldi	r25, 0x03	; 3
    397a:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
			DIO_u8SetPinValue(DIO_u8_PORTB, DIO_u8_PIN0, DIO_u8_LOW);
    397e:	81 e0       	ldi	r24, 0x01	; 1
    3980:	60 e0       	ldi	r22, 0x00	; 0
    3982:	40 e0       	ldi	r20, 0x00	; 0
    3984:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <DIO_u8SetPinValue>
			vTaskDelay(1000);
    3988:	88 ee       	ldi	r24, 0xE8	; 232
    398a:	93 e0       	ldi	r25, 0x03	; 3
    398c:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
			xEventGroupSetBits(egStates, E_MAIN);
    3990:	80 91 ce 06 	lds	r24, 0x06CE
    3994:	90 91 cf 06 	lds	r25, 0x06CF
    3998:	61 e0       	ldi	r22, 0x01	; 1
    399a:	70 e0       	ldi	r23, 0x00	; 0
    399c:	0e 94 5e 08 	call	0x10bc	; 0x10bc <xEventGroupSetBits>
			xSemaphoreGive(bsPassword);
    39a0:	80 91 d2 06 	lds	r24, 0x06D2
    39a4:	90 91 d3 06 	lds	r25, 0x06D3
    39a8:	60 e0       	ldi	r22, 0x00	; 0
    39aa:	70 e0       	ldi	r23, 0x00	; 0
    39ac:	40 e0       	ldi	r20, 0x00	; 0
    39ae:	50 e0       	ldi	r21, 0x00	; 0
    39b0:	20 e0       	ldi	r18, 0x00	; 0
    39b2:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <xQueueGenericSend>
			vTaskDelay(100);
    39b6:	84 e6       	ldi	r24, 0x64	; 100
    39b8:	90 e0       	ldi	r25, 0x00	; 0
    39ba:	0e 94 32 13 	call	0x2664	; 0x2664 <vTaskDelay>
    39be:	93 cf       	rjmp	.-218    	; 0x38e6 <T_Actuators+0x4>

000039c0 <main>:
}Home_t;

Home_t Smart = {1234};

int main (void)
{
    39c0:	af 92       	push	r10
    39c2:	bf 92       	push	r11
    39c4:	cf 92       	push	r12
    39c6:	df 92       	push	r13
    39c8:	ef 92       	push	r14
    39ca:	ff 92       	push	r15
    39cc:	0f 93       	push	r16
	system_init();
    39ce:	0e 94 26 1a 	call	0x344c	; 0x344c <system_init>

	egActions = xEventGroupCreate();
    39d2:	0e 94 ad 09 	call	0x135a	; 0x135a <xEventGroupCreate>
    39d6:	90 93 d1 06 	sts	0x06D1, r25
    39da:	80 93 d0 06 	sts	0x06D0, r24
	egStates  = xEventGroupCreate();
    39de:	0e 94 ad 09 	call	0x135a	; 0x135a <xEventGroupCreate>
    39e2:	90 93 cf 06 	sts	0x06CF, r25
    39e6:	80 93 ce 06 	sts	0x06CE, r24
	vSemaphoreCreateBinary(bsPassword, 1);
    39ea:	81 e0       	ldi	r24, 0x01	; 1
    39ec:	60 e0       	ldi	r22, 0x00	; 0
    39ee:	43 e0       	ldi	r20, 0x03	; 3
    39f0:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueGenericCreate>
    39f4:	90 93 d3 06 	sts	0x06D3, r25
    39f8:	80 93 d2 06 	sts	0x06D2, r24
    39fc:	00 97       	sbiw	r24, 0x00	; 0
    39fe:	39 f0       	breq	.+14     	; 0x3a0e <main+0x4e>
    3a00:	60 e0       	ldi	r22, 0x00	; 0
    3a02:	70 e0       	ldi	r23, 0x00	; 0
    3a04:	40 e0       	ldi	r20, 0x00	; 0
    3a06:	50 e0       	ldi	r21, 0x00	; 0
    3a08:	20 e0       	ldi	r18, 0x00	; 0
    3a0a:	0e 94 2c 0f 	call	0x1e58	; 0x1e58 <xQueueGenericSend>

	xTaskCreate(T_Actuators, NULL, 100, NULL, 5, &Tl_handle);
    3a0e:	81 e7       	ldi	r24, 0x71	; 113
    3a10:	9c e1       	ldi	r25, 0x1C	; 28
    3a12:	60 e0       	ldi	r22, 0x00	; 0
    3a14:	70 e0       	ldi	r23, 0x00	; 0
    3a16:	44 e6       	ldi	r20, 0x64	; 100
    3a18:	50 e0       	ldi	r21, 0x00	; 0
    3a1a:	20 e0       	ldi	r18, 0x00	; 0
    3a1c:	30 e0       	ldi	r19, 0x00	; 0
    3a1e:	05 e0       	ldi	r16, 0x05	; 5
    3a20:	e0 ec       	ldi	r30, 0xC0	; 192
    3a22:	ee 2e       	mov	r14, r30
    3a24:	e6 e0       	ldi	r30, 0x06	; 6
    3a26:	fe 2e       	mov	r15, r30
    3a28:	cc 24       	eor	r12, r12
    3a2a:	dd 24       	eor	r13, r13
    3a2c:	aa 24       	eor	r10, r10
    3a2e:	bb 24       	eor	r11, r11
    3a30:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>
	xTaskCreate(T_Login, NULL, 150, NULL, 4, &T2_handle);
    3a34:	8c e2       	ldi	r24, 0x2C	; 44
    3a36:	9b e1       	ldi	r25, 0x1B	; 27
    3a38:	60 e0       	ldi	r22, 0x00	; 0
    3a3a:	70 e0       	ldi	r23, 0x00	; 0
    3a3c:	46 e9       	ldi	r20, 0x96	; 150
    3a3e:	50 e0       	ldi	r21, 0x00	; 0
    3a40:	20 e0       	ldi	r18, 0x00	; 0
    3a42:	30 e0       	ldi	r19, 0x00	; 0
    3a44:	04 e0       	ldi	r16, 0x04	; 4
    3a46:	b2 ec       	ldi	r27, 0xC2	; 194
    3a48:	eb 2e       	mov	r14, r27
    3a4a:	b6 e0       	ldi	r27, 0x06	; 6
    3a4c:	fb 2e       	mov	r15, r27
    3a4e:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>
	xTaskCreate(T_TemperatureSensor, NULL, 100, NULL, 2, &T3_handle);
    3a52:	8c ef       	ldi	r24, 0xFC	; 252
    3a54:	9a e1       	ldi	r25, 0x1A	; 26
    3a56:	60 e0       	ldi	r22, 0x00	; 0
    3a58:	70 e0       	ldi	r23, 0x00	; 0
    3a5a:	44 e6       	ldi	r20, 0x64	; 100
    3a5c:	50 e0       	ldi	r21, 0x00	; 0
    3a5e:	20 e0       	ldi	r18, 0x00	; 0
    3a60:	30 e0       	ldi	r19, 0x00	; 0
    3a62:	02 e0       	ldi	r16, 0x02	; 2
    3a64:	a4 ec       	ldi	r26, 0xC4	; 196
    3a66:	ea 2e       	mov	r14, r26
    3a68:	a6 e0       	ldi	r26, 0x06	; 6
    3a6a:	fa 2e       	mov	r15, r26
    3a6c:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>
	xTaskCreate(T_LDRSensor, NULL, 100, NULL, 1, &T4_handle);
    3a70:	8c ec       	ldi	r24, 0xCC	; 204
    3a72:	9a e1       	ldi	r25, 0x1A	; 26
    3a74:	60 e0       	ldi	r22, 0x00	; 0
    3a76:	70 e0       	ldi	r23, 0x00	; 0
    3a78:	44 e6       	ldi	r20, 0x64	; 100
    3a7a:	50 e0       	ldi	r21, 0x00	; 0
    3a7c:	20 e0       	ldi	r18, 0x00	; 0
    3a7e:	30 e0       	ldi	r19, 0x00	; 0
    3a80:	01 e0       	ldi	r16, 0x01	; 1
    3a82:	f6 ec       	ldi	r31, 0xC6	; 198
    3a84:	ef 2e       	mov	r14, r31
    3a86:	f6 e0       	ldi	r31, 0x06	; 6
    3a88:	ff 2e       	mov	r15, r31
    3a8a:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>
	xTaskCreate(T_Display, NULL, 100, NULL, 3, &T5_handle);
    3a8e:	89 e3       	ldi	r24, 0x39	; 57
    3a90:	9a e1       	ldi	r25, 0x1A	; 26
    3a92:	60 e0       	ldi	r22, 0x00	; 0
    3a94:	70 e0       	ldi	r23, 0x00	; 0
    3a96:	44 e6       	ldi	r20, 0x64	; 100
    3a98:	50 e0       	ldi	r21, 0x00	; 0
    3a9a:	20 e0       	ldi	r18, 0x00	; 0
    3a9c:	30 e0       	ldi	r19, 0x00	; 0
    3a9e:	03 e0       	ldi	r16, 0x03	; 3
    3aa0:	e8 ec       	ldi	r30, 0xC8	; 200
    3aa2:	ee 2e       	mov	r14, r30
    3aa4:	e6 e0       	ldi	r30, 0x06	; 6
    3aa6:	fe 2e       	mov	r15, r30
    3aa8:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGenericCreate>


	/* Start RTOS */
	vTaskStartScheduler();
    3aac:	0e 94 8d 14 	call	0x291a	; 0x291a <vTaskStartScheduler>
    3ab0:	ff cf       	rjmp	.-2      	; 0x3ab0 <main+0xf0>

00003ab2 <usart_init>:
#include "usart_driver.h"

void usart_init(unsigned short int baudrate)
{
	//Set baud rate
	unsigned short int UBRRVAL=(FCLK_SYSTEM/(baudrate*16UL))-1;
    3ab2:	9c 01       	movw	r18, r24
    3ab4:	40 e0       	ldi	r20, 0x00	; 0
    3ab6:	50 e0       	ldi	r21, 0x00	; 0
    3ab8:	84 e0       	ldi	r24, 0x04	; 4
    3aba:	22 0f       	add	r18, r18
    3abc:	33 1f       	adc	r19, r19
    3abe:	44 1f       	adc	r20, r20
    3ac0:	55 1f       	adc	r21, r21
    3ac2:	8a 95       	dec	r24
    3ac4:	d1 f7       	brne	.-12     	; 0x3aba <usart_init+0x8>
    3ac6:	60 e0       	ldi	r22, 0x00	; 0
    3ac8:	72 e1       	ldi	r23, 0x12	; 18
    3aca:	8a e7       	ldi	r24, 0x7A	; 122
    3acc:	90 e0       	ldi	r25, 0x00	; 0
    3ace:	0e 94 a3 1d 	call	0x3b46	; 0x3b46 <__udivmodsi4>
    3ad2:	21 50       	subi	r18, 0x01	; 1
    3ad4:	30 40       	sbci	r19, 0x00	; 0
	UBRRL=UBRRVAL; 			//low byte
    3ad6:	29 b9       	out	0x09, r18	; 9
	UBRRH=(UBRRVAL>>8); 	//high byte
    3ad8:	30 bd       	out	0x20, r19	; 32

	//Set data frame format: asynchronous mode,no parity, 1 stop bit, 8 bit size
	UCSRC=(1<<URSEL)|(0<<UMSEL)|(0<<UPM1)|(0<<UPM0)|(0<<USBS)|(0<<UCSZ2)|(1<<UCSZ1)|(1<<UCSZ0); 
    3ada:	86 e8       	ldi	r24, 0x86	; 134
    3adc:	80 bd       	out	0x20, r24	; 32

	//Enable Transmitter and Receiver
	UCSRB=(1<<RXEN)|(1<<TXEN);
    3ade:	88 e1       	ldi	r24, 0x18	; 24
    3ae0:	8a b9       	out	0x0a, r24	; 10
}
    3ae2:	08 95       	ret

00003ae4 <usart_getc>:
unsigned char usart_getc( void )
{
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
    3ae4:	5f 9b       	sbis	0x0b, 7	; 11
    3ae6:	fe cf       	rjmp	.-4      	; 0x3ae4 <usart_getc>
	/* Get and return received data from buffer */
	return UDR;
    3ae8:	8c b1       	in	r24, 0x0c	; 12
}
    3aea:	08 95       	ret

00003aec <usart_putc>:
void usart_putc( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)));
    3aec:	5d 9b       	sbis	0x0b, 5	; 11
    3aee:	fe cf       	rjmp	.-4      	; 0x3aec <usart_putc>
	/* Put data into buffer, sends the data */
	UDR = data;
    3af0:	8c b9       	out	0x0c, r24	; 12
}
    3af2:	08 95       	ret

00003af4 <usart_puts>:
void usart_puts( char* str )
{
    3af4:	fc 01       	movw	r30, r24
    3af6:	04 c0       	rjmp	.+8      	; 0x3b00 <usart_puts+0xc>
	return UDR;
}
void usart_putc( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)));
    3af8:	5d 9b       	sbis	0x0b, 5	; 11
    3afa:	fe cf       	rjmp	.-4      	; 0x3af8 <usart_puts+0x4>
	/* Put data into buffer, sends the data */
	UDR = data;
    3afc:	8c b9       	out	0x0c, r24	; 12
    3afe:	31 96       	adiw	r30, 0x01	; 1
}
void usart_puts( char* str )
{
	short int i=0;
	while(str[i])
    3b00:	80 81       	ld	r24, Z
    3b02:	88 23       	and	r24, r24
    3b04:	c9 f7       	brne	.-14     	; 0x3af8 <usart_puts+0x4>
	{
		usart_putc(str[i]);
		i++;
	}
}
    3b06:	08 95       	ret

00003b08 <__mulsi3>:
    3b08:	62 9f       	mul	r22, r18
    3b0a:	d0 01       	movw	r26, r0
    3b0c:	73 9f       	mul	r23, r19
    3b0e:	f0 01       	movw	r30, r0
    3b10:	82 9f       	mul	r24, r18
    3b12:	e0 0d       	add	r30, r0
    3b14:	f1 1d       	adc	r31, r1
    3b16:	64 9f       	mul	r22, r20
    3b18:	e0 0d       	add	r30, r0
    3b1a:	f1 1d       	adc	r31, r1
    3b1c:	92 9f       	mul	r25, r18
    3b1e:	f0 0d       	add	r31, r0
    3b20:	83 9f       	mul	r24, r19
    3b22:	f0 0d       	add	r31, r0
    3b24:	74 9f       	mul	r23, r20
    3b26:	f0 0d       	add	r31, r0
    3b28:	65 9f       	mul	r22, r21
    3b2a:	f0 0d       	add	r31, r0
    3b2c:	99 27       	eor	r25, r25
    3b2e:	72 9f       	mul	r23, r18
    3b30:	b0 0d       	add	r27, r0
    3b32:	e1 1d       	adc	r30, r1
    3b34:	f9 1f       	adc	r31, r25
    3b36:	63 9f       	mul	r22, r19
    3b38:	b0 0d       	add	r27, r0
    3b3a:	e1 1d       	adc	r30, r1
    3b3c:	f9 1f       	adc	r31, r25
    3b3e:	bd 01       	movw	r22, r26
    3b40:	cf 01       	movw	r24, r30
    3b42:	11 24       	eor	r1, r1
    3b44:	08 95       	ret

00003b46 <__udivmodsi4>:
    3b46:	a1 e2       	ldi	r26, 0x21	; 33
    3b48:	1a 2e       	mov	r1, r26
    3b4a:	aa 1b       	sub	r26, r26
    3b4c:	bb 1b       	sub	r27, r27
    3b4e:	fd 01       	movw	r30, r26
    3b50:	0d c0       	rjmp	.+26     	; 0x3b6c <__udivmodsi4_ep>

00003b52 <__udivmodsi4_loop>:
    3b52:	aa 1f       	adc	r26, r26
    3b54:	bb 1f       	adc	r27, r27
    3b56:	ee 1f       	adc	r30, r30
    3b58:	ff 1f       	adc	r31, r31
    3b5a:	a2 17       	cp	r26, r18
    3b5c:	b3 07       	cpc	r27, r19
    3b5e:	e4 07       	cpc	r30, r20
    3b60:	f5 07       	cpc	r31, r21
    3b62:	20 f0       	brcs	.+8      	; 0x3b6c <__udivmodsi4_ep>
    3b64:	a2 1b       	sub	r26, r18
    3b66:	b3 0b       	sbc	r27, r19
    3b68:	e4 0b       	sbc	r30, r20
    3b6a:	f5 0b       	sbc	r31, r21

00003b6c <__udivmodsi4_ep>:
    3b6c:	66 1f       	adc	r22, r22
    3b6e:	77 1f       	adc	r23, r23
    3b70:	88 1f       	adc	r24, r24
    3b72:	99 1f       	adc	r25, r25
    3b74:	1a 94       	dec	r1
    3b76:	69 f7       	brne	.-38     	; 0x3b52 <__udivmodsi4_loop>
    3b78:	60 95       	com	r22
    3b7a:	70 95       	com	r23
    3b7c:	80 95       	com	r24
    3b7e:	90 95       	com	r25
    3b80:	9b 01       	movw	r18, r22
    3b82:	ac 01       	movw	r20, r24
    3b84:	bd 01       	movw	r22, r26
    3b86:	cf 01       	movw	r24, r30
    3b88:	08 95       	ret

00003b8a <__divmodsi4>:
    3b8a:	97 fb       	bst	r25, 7
    3b8c:	09 2e       	mov	r0, r25
    3b8e:	05 26       	eor	r0, r21
    3b90:	0e d0       	rcall	.+28     	; 0x3bae <__divmodsi4_neg1>
    3b92:	57 fd       	sbrc	r21, 7
    3b94:	04 d0       	rcall	.+8      	; 0x3b9e <__divmodsi4_neg2>
    3b96:	d7 df       	rcall	.-82     	; 0x3b46 <__udivmodsi4>
    3b98:	0a d0       	rcall	.+20     	; 0x3bae <__divmodsi4_neg1>
    3b9a:	00 1c       	adc	r0, r0
    3b9c:	38 f4       	brcc	.+14     	; 0x3bac <__divmodsi4_exit>

00003b9e <__divmodsi4_neg2>:
    3b9e:	50 95       	com	r21
    3ba0:	40 95       	com	r20
    3ba2:	30 95       	com	r19
    3ba4:	21 95       	neg	r18
    3ba6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ba8:	4f 4f       	sbci	r20, 0xFF	; 255
    3baa:	5f 4f       	sbci	r21, 0xFF	; 255

00003bac <__divmodsi4_exit>:
    3bac:	08 95       	ret

00003bae <__divmodsi4_neg1>:
    3bae:	f6 f7       	brtc	.-4      	; 0x3bac <__divmodsi4_exit>
    3bb0:	90 95       	com	r25
    3bb2:	80 95       	com	r24
    3bb4:	70 95       	com	r23
    3bb6:	61 95       	neg	r22
    3bb8:	7f 4f       	sbci	r23, 0xFF	; 255
    3bba:	8f 4f       	sbci	r24, 0xFF	; 255
    3bbc:	9f 4f       	sbci	r25, 0xFF	; 255
    3bbe:	08 95       	ret

00003bc0 <__prologue_saves__>:
    3bc0:	2f 92       	push	r2
    3bc2:	3f 92       	push	r3
    3bc4:	4f 92       	push	r4
    3bc6:	5f 92       	push	r5
    3bc8:	6f 92       	push	r6
    3bca:	7f 92       	push	r7
    3bcc:	8f 92       	push	r8
    3bce:	9f 92       	push	r9
    3bd0:	af 92       	push	r10
    3bd2:	bf 92       	push	r11
    3bd4:	cf 92       	push	r12
    3bd6:	df 92       	push	r13
    3bd8:	ef 92       	push	r14
    3bda:	ff 92       	push	r15
    3bdc:	0f 93       	push	r16
    3bde:	1f 93       	push	r17
    3be0:	cf 93       	push	r28
    3be2:	df 93       	push	r29
    3be4:	cd b7       	in	r28, 0x3d	; 61
    3be6:	de b7       	in	r29, 0x3e	; 62
    3be8:	ca 1b       	sub	r28, r26
    3bea:	db 0b       	sbc	r29, r27
    3bec:	0f b6       	in	r0, 0x3f	; 63
    3bee:	f8 94       	cli
    3bf0:	de bf       	out	0x3e, r29	; 62
    3bf2:	0f be       	out	0x3f, r0	; 63
    3bf4:	cd bf       	out	0x3d, r28	; 61
    3bf6:	09 94       	ijmp

00003bf8 <__epilogue_restores__>:
    3bf8:	2a 88       	ldd	r2, Y+18	; 0x12
    3bfa:	39 88       	ldd	r3, Y+17	; 0x11
    3bfc:	48 88       	ldd	r4, Y+16	; 0x10
    3bfe:	5f 84       	ldd	r5, Y+15	; 0x0f
    3c00:	6e 84       	ldd	r6, Y+14	; 0x0e
    3c02:	7d 84       	ldd	r7, Y+13	; 0x0d
    3c04:	8c 84       	ldd	r8, Y+12	; 0x0c
    3c06:	9b 84       	ldd	r9, Y+11	; 0x0b
    3c08:	aa 84       	ldd	r10, Y+10	; 0x0a
    3c0a:	b9 84       	ldd	r11, Y+9	; 0x09
    3c0c:	c8 84       	ldd	r12, Y+8	; 0x08
    3c0e:	df 80       	ldd	r13, Y+7	; 0x07
    3c10:	ee 80       	ldd	r14, Y+6	; 0x06
    3c12:	fd 80       	ldd	r15, Y+5	; 0x05
    3c14:	0c 81       	ldd	r16, Y+4	; 0x04
    3c16:	1b 81       	ldd	r17, Y+3	; 0x03
    3c18:	aa 81       	ldd	r26, Y+2	; 0x02
    3c1a:	b9 81       	ldd	r27, Y+1	; 0x01
    3c1c:	ce 0f       	add	r28, r30
    3c1e:	d1 1d       	adc	r29, r1
    3c20:	0f b6       	in	r0, 0x3f	; 63
    3c22:	f8 94       	cli
    3c24:	de bf       	out	0x3e, r29	; 62
    3c26:	0f be       	out	0x3f, r0	; 63
    3c28:	cd bf       	out	0x3d, r28	; 61
    3c2a:	ed 01       	movw	r28, r26
    3c2c:	08 95       	ret

00003c2e <memcpy>:
    3c2e:	fb 01       	movw	r30, r22
    3c30:	dc 01       	movw	r26, r24
    3c32:	02 c0       	rjmp	.+4      	; 0x3c38 <memcpy+0xa>
    3c34:	01 90       	ld	r0, Z+
    3c36:	0d 92       	st	X+, r0
    3c38:	41 50       	subi	r20, 0x01	; 1
    3c3a:	50 40       	sbci	r21, 0x00	; 0
    3c3c:	d8 f7       	brcc	.-10     	; 0x3c34 <memcpy+0x6>
    3c3e:	08 95       	ret

00003c40 <_exit>:
    3c40:	f8 94       	cli

00003c42 <__stop_program>:
    3c42:	ff cf       	rjmp	.-2      	; 0x3c42 <__stop_program>
